<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Overview - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="schema-overview"><a class="header" href="#schema-overview">Schema Overview</a></h1>
<p>This guide provides an overview of SCIM schemas and how they work within the SCIM Server library. Understanding schemas is essential for extending the server with custom attributes and resource types.</p>
<h2 id="what-are-scim-schemas"><a class="header" href="#what-are-scim-schemas">What are SCIM Schemas?</a></h2>
<p>SCIM (System for Cross-domain Identity Management) schemas define the structure, attributes, and validation rules for resources like Users and Groups. They provide a standardized way to describe what data can be stored and how it should be formatted.</p>
<h3 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h3>
<ul>
<li><strong>Schema URI</strong>: Unique identifier for each schema (e.g., <code>urn:ietf:params:scim:schemas:core:2.0:User</code>)</li>
<li><strong>Resource Types</strong>: The types of objects that can be managed (User, Group, custom types)</li>
<li><strong>Attributes</strong>: The fields that make up a resource (name, email, etc.)</li>
<li><strong>Extensions</strong>: Additional schemas that add custom attributes to existing resource types</li>
</ul>
<h2 id="standard-scim-schemas"><a class="header" href="#standard-scim-schemas">Standard SCIM Schemas</a></h2>
<h3 id="core-user-schema"><a class="header" href="#core-user-schema">Core User Schema</a></h3>
<pre><code>urn:ietf:params:scim:schemas:core:2.0:User
</code></pre>
<p>Defines essential user attributes:</p>
<ul>
<li><code>id</code> - Unique identifier</li>
<li><code>userName</code> - Primary identifier for authentication</li>
<li><code>name</code> - User's full name (complex attribute)</li>
<li><code>displayName</code> - Name for display purposes</li>
<li><code>emails</code> - Email addresses (multi-valued)</li>
<li><code>phoneNumbers</code> - Phone numbers (multi-valued)</li>
<li><code>active</code> - Whether the user account is active</li>
</ul>
<h3 id="core-group-schema"><a class="header" href="#core-group-schema">Core Group Schema</a></h3>
<pre><code>urn:ietf:params:scim:schemas:core:2.0:Group
</code></pre>
<p>Defines group attributes:</p>
<ul>
<li><code>id</code> - Unique identifier</li>
<li><code>displayName</code> - Group's display name</li>
<li><code>members</code> - Group members (multi-valued complex)</li>
</ul>
<h3 id="enterprise-user-extension"><a class="header" href="#enterprise-user-extension">Enterprise User Extension</a></h3>
<pre><code>urn:ietf:params:scim:schemas:extension:enterprise:2.0:User
</code></pre>
<p>Adds enterprise-specific attributes:</p>
<ul>
<li><code>employeeNumber</code> - Employee identifier</li>
<li><code>department</code> - Department name</li>
<li><code>manager</code> - Reference to manager</li>
<li><code>organization</code> - Organization name</li>
</ul>
<h2 id="schema-architecture"><a class="header" href="#schema-architecture">Schema Architecture</a></h2>
<h3 id="schema-definition-structure"><a class="header" href="#schema-definition-structure">Schema Definition Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::{SchemaDefinition, AttributeDefinition};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaDefinition {
    pub id: String,                              // Schema URI
    pub name: String,                            // Human-readable name
    pub description: String,                     // Schema description
    pub attributes: Vec&lt;AttributeDefinition&gt;,    // Attribute definitions
    pub meta: SchemaMeta,                        // Metadata
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaMeta {
    pub resource_type: String,
    pub location: String,
    pub created: DateTime&lt;Utc&gt;,
    pub last_modified: DateTime&lt;Utc&gt;,
    pub version: String,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-definition"><a class="header" href="#attribute-definition">Attribute Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributeDefinition {
    pub name: String,                    // Attribute name
    pub attribute_type: AttributeType,   // Data type
    pub multi_valued: bool,              // Can have multiple values
    pub description: String,             // Human-readable description
    pub required: bool,                  // Must be present
    pub case_exact: bool,                // Case-sensitive comparison
    pub mutability: Mutability,          // When attribute can be modified
    pub returned: Returned,              // When attribute is returned
    pub uniqueness: Uniqueness,          // Uniqueness constraint
    pub reference_types: Option&lt;Vec&lt;String&gt;&gt;, // For reference attributes
    pub canonical_values: Option&lt;Vec&lt;String&gt;&gt;, // Predefined valid values
    pub sub_attributes: Option&lt;Vec&lt;AttributeDefinition&gt;&gt;, // For complex types
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-types"><a class="header" href="#attribute-types">Attribute Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttributeType {
    String,    // Text data
    Boolean,   // True/false values
    Decimal,   // Floating-point numbers
    Integer,   // Whole numbers
    DateTime,  // ISO 8601 date-time
    Binary,    // Base64-encoded binary data
    Reference, // Reference to another resource
    Complex,   // Nested object with sub-attributes
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mutability-levels"><a class="header" href="#mutability-levels">Mutability Levels</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Mutability {
    ReadOnly,   // Cannot be modified by client
    ReadWrite,  // Can be read and written
    Immutable,  // Can only be set during creation
    WriteOnly,  // Can be written but not read (e.g., passwords)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="return-behavior"><a class="header" href="#return-behavior">Return Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Returned {
    Always,  // Always returned
    Never,   // Never returned (e.g., passwords)
    Default, // Returned by default
    Request, // Only returned when explicitly requested
}
<span class="boring">}</span></code></pre></pre>
<h3 id="uniqueness-constraints"><a class="header" href="#uniqueness-constraints">Uniqueness Constraints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Uniqueness {
    None,   // No uniqueness constraint
    Server, // Unique within the server
    Global, // Globally unique
}
<span class="boring">}</span></code></pre></pre>
<h2 id="schema-registry"><a class="header" href="#schema-registry">Schema Registry</a></h2>
<p>The schema registry manages all available schemas and provides validation services:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::SchemaRegistry;
use std::collections::HashMap;

pub struct SchemaRegistry {
    schemas: HashMap&lt;String, SchemaDefinition&gt;,
    resource_schemas: HashMap&lt;String, Vec&lt;String&gt;&gt;, // resource_type -&gt; schema_uris
}

impl SchemaRegistry {
    pub fn new() -&gt; Self {
        let mut registry = Self {
            schemas: HashMap::new(),
            resource_schemas: HashMap::new(),
        };
        
        // Register core schemas
        registry.register_core_schemas();
        registry
    }
    
    pub fn register_schema(&amp;mut self, schema: SchemaDefinition) -&gt; Result&lt;(), SchemaError&gt; {
        // Validate schema definition
        self.validate_schema(&amp;schema)?;
        
        // Store schema
        self.schemas.insert(schema.id.clone(), schema);
        Ok(())
    }
    
    pub fn get_schema(&amp;self, schema_uri: &amp;str) -&gt; Option&lt;&amp;SchemaDefinition&gt; {
        self.schemas.get(schema_uri)
    }
    
    pub fn get_resource_schemas(&amp;self, resource_type: &amp;str) -&gt; Vec&lt;&amp;SchemaDefinition&gt; {
        if let Some(schema_uris) = self.resource_schemas.get(resource_type) {
            schema_uris.iter()
                .filter_map(|uri| self.schemas.get(uri))
                .collect()
        } else {
            Vec::new()
        }
    }
    
    pub fn validate_resource(
        &amp;self,
        resource: &amp;serde_json::Value,
        schemas: &amp;[String],
    ) -&gt; Result&lt;(), ValidationError&gt; {
        for schema_uri in schemas {
            if let Some(schema) = self.get_schema(schema_uri) {
                self.validate_against_schema(resource, schema)?;
            } else {
                return Err(ValidationError::UnknownSchema(schema_uri.clone()));
            }
        }
        Ok(())
    }
    
    fn register_core_schemas(&amp;mut self) {
        // Register User schema
        let user_schema = self.create_user_schema();
        self.schemas.insert(user_schema.id.clone(), user_schema);
        
        // Register Group schema
        let group_schema = self.create_group_schema();
        self.schemas.insert(group_schema.id.clone(), group_schema);
        
        // Register Enterprise User extension
        let enterprise_schema = self.create_enterprise_user_schema();
        self.schemas.insert(enterprise_schema.id.clone(), enterprise_schema);
        
        // Map resource types to schemas
        self.resource_schemas.insert(
            "User".to_string(),
            vec![
                "urn:ietf:params:scim:schemas:core:2.0:User".to_string(),
                "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User".to_string(),
            ]
        );
        
        self.resource_schemas.insert(
            "Group".to_string(),
            vec!["urn:ietf:params:scim:schemas:core:2.0:Group".to_string()]
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-schemas"><a class="header" href="#working-with-schemas">Working with Schemas</a></h2>
<h3 id="retrieving-schema-information"><a class="header" href="#retrieving-schema-information">Retrieving Schema Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::ScimServer;

async fn get_user_schema(server: &amp;ScimServer) -&gt; Result&lt;SchemaDefinition, ScimError&gt; {
    let registry = server.schema_registry();
    let schema = registry.get_schema("urn:ietf:params:scim:schemas:core:2.0:User")
        .ok_or(ScimError::SchemaNotFound)?;
    Ok(schema.clone())
}

async fn list_all_schemas(server: &amp;ScimServer) -&gt; Vec&lt;SchemaDefinition&gt; {
    let registry = server.schema_registry();
    registry.list_schemas()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validating-resources"><a class="header" href="#validating-resources">Validating Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::models::User;
use serde_json;

async fn validate_user(
    registry: &amp;SchemaRegistry,
    user: &amp;User,
) -&gt; Result&lt;(), ValidationError&gt; {
    let user_json = serde_json::to_value(user)?;
    
    registry.validate_resource(
        &amp;user_json,
        &amp;user.schemas,
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="schema-versioning"><a class="header" href="#schema-versioning">Schema Versioning</a></h2>
<h3 id="version-management"><a class="header" href="#version-management">Version Management</a></h3>
<p>Schemas should be versioned to handle evolution over time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SchemaVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
}

impl SchemaVersion {
    pub fn new(major: u32, minor: u32, patch: u32) -&gt; Self {
        Self { major, minor, patch }
    }
    
    pub fn is_compatible_with(&amp;self, other: &amp;SchemaVersion) -&gt; bool {
        // Same major version is compatible
        self.major == other.major
    }
}

// Schema URI with version
// urn:company:schemas:extension:employee:1.0:User
<span class="boring">}</span></code></pre></pre>
<h3 id="migration-support"><a class="header" href="#migration-support">Migration Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SchemaMigration {
    fn migrate(&amp;self, from: &amp;SchemaVersion, to: &amp;SchemaVersion, data: &amp;mut serde_json::Value) -&gt; Result&lt;(), MigrationError&gt;;
    fn supports_migration(&amp;self, from: &amp;SchemaVersion, to: &amp;SchemaVersion) -&gt; bool;
}

pub struct SchemaEvolutionManager {
    migrations: Vec&lt;Box&lt;dyn SchemaMigration&gt;&gt;,
}

impl SchemaEvolutionManager {
    pub fn migrate_data(
        &amp;self,
        data: &amp;mut serde_json::Value,
        from_version: &amp;SchemaVersion,
        to_version: &amp;SchemaVersion,
    ) -&gt; Result&lt;(), MigrationError&gt; {
        for migration in &amp;self.migrations {
            if migration.supports_migration(from_version, to_version) {
                migration.migrate(from_version, to_version, data)?;
                break;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<h3 id="schema-related-errors"><a class="header" href="#schema-related-errors">Schema-Related Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum SchemaError {
    #[error("Schema validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Unknown schema: {0}")]
    UnknownSchema(String),
    
    #[error("Schema conflict: {0}")]
    SchemaConflict(String),
    
    #[error("Invalid attribute definition: {0}")]
    InvalidAttribute(String),
    
    #[error("Schema version incompatible: {0}")]
    VersionIncompatible(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="schema-design-guidelines"><a class="header" href="#schema-design-guidelines">Schema Design Guidelines</a></h3>
<ol>
<li><strong>Use meaningful names</strong>: Attribute names should be descriptive and follow camelCase convention</li>
<li><strong>Choose appropriate types</strong>: Select the most specific type that fits your data</li>
<li><strong>Set proper constraints</strong>: Use <code>required</code>, <code>uniqueness</code>, and <code>mutability</code> appropriately</li>
<li><strong>Document thoroughly</strong>: Provide clear descriptions for schemas and attributes</li>
<li><strong>Version strategically</strong>: Plan for schema evolution from the beginning</li>
</ol>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<ol>
<li><strong>Index unique attributes</strong>: Ensure database indexes exist for attributes with uniqueness constraints</li>
<li><strong>Minimize complex attributes</strong>: Deeply nested structures can impact performance</li>
<li><strong>Cache schema definitions</strong>: Avoid repeated schema lookups during validation</li>
<li><strong>Batch validation</strong>: Validate multiple resources together when possible</li>
</ol>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li><a href="./custom-resources.html">Custom Resources</a> - Learn to create entirely new resource types</li>
<li><a href="./extensions.html">Extensions</a> - Add custom attributes to existing resources</li>
<li><a href="./validation.html">Validation</a> - Implement custom validation rules for schemas</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../providers/testing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../schemas/custom-resources.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../providers/testing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../schemas/custom-resources.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
