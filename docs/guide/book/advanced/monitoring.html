<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Monitoring and Observability - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h1>
<p>This guide covers comprehensive monitoring, metrics, logging, and observability strategies for SCIM Server deployments. Effective observability is crucial for maintaining reliable identity management systems at scale.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Observability for SCIM servers encompasses:</p>
<ul>
<li><strong>Metrics Collection</strong> - Performance and business metrics</li>
<li><strong>Logging</strong> - Structured application and audit logs</li>
<li><strong>Tracing</strong> - Distributed request tracing</li>
<li><strong>Health Checks</strong> - Service health and readiness</li>
<li><strong>Alerting</strong> - Proactive incident detection</li>
<li><strong>Dashboards</strong> - Visual monitoring and analysis</li>
</ul>
<h2 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h2>
<h3 id="built-in-metrics"><a class="header" href="#built-in-metrics">Built-in Metrics</a></h3>
<p>The SCIM Server library provides comprehensive metrics out of the box:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{MetricsConfig, MetricsCollector, PrometheusExporter};

let metrics_config = MetricsConfig::builder()
    .enable_http_metrics(true)
    .enable_business_metrics(true)
    .enable_system_metrics(true)
    .prometheus_endpoint("/metrics")
    .collection_interval_seconds(15)
    .histogram_buckets(vec![0.001, 0.01, 0.1, 1.0, 10.0])
    .build()?;

let metrics_collector = MetricsCollector::new(metrics_config);
let server = ScimServer::new(storage)
    .with_metrics(metrics_collector)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="http-metrics"><a class="header" href="#http-metrics">HTTP Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_http_requests_total</code></td><td>Counter</td><td>Total HTTP requests</td><td><code>method</code>, <code>endpoint</code>, <code>status_code</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_http_request_duration_seconds</code></td><td>Histogram</td><td>Request duration</td><td><code>method</code>, <code>endpoint</code>, <code>status_code</code></td></tr>
<tr><td><code>scim_http_request_size_bytes</code></td><td>Histogram</td><td>Request body size</td><td><code>method</code>, <code>endpoint</code></td></tr>
<tr><td><code>scim_http_response_size_bytes</code></td><td>Histogram</td><td>Response body size</td><td><code>method</code>, <code>endpoint</code></td></tr>
<tr><td><code>scim_http_requests_in_flight</code></td><td>Gauge</td><td>Concurrent requests</td><td><code>endpoint</code></td></tr>
</tbody></table>
</div>
<h3 id="business-metrics"><a class="header" href="#business-metrics">Business Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_users_total</code></td><td>Gauge</td><td>Total users in system</td><td><code>tenant_id</code>, <code>active</code></td></tr>
<tr><td><code>scim_groups_total</code></td><td>Gauge</td><td>Total groups in system</td><td><code>tenant_id</code></td></tr>
<tr><td><code>scim_operations_total</code></td><td>Counter</td><td>SCIM operations performed</td><td><code>operation</code>, <code>resource_type</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_bulk_operations_total</code></td><td>Counter</td><td>Bulk operations performed</td><td><code>tenant_id</code>, <code>status</code></td></tr>
<tr><td><code>scim_filter_queries_total</code></td><td>Counter</td><td>Filter queries executed</td><td><code>complexity</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_authentication_attempts_total</code></td><td>Counter</td><td>Authentication attempts</td><td><code>method</code>, <code>result</code>, <code>tenant_id</code></td></tr>
</tbody></table>
</div>
<h3 id="system-metrics"><a class="header" href="#system-metrics">System Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_memory_usage_bytes</code></td><td>Gauge</td><td>Memory usage</td><td><code>type</code></td></tr>
<tr><td><code>scim_cpu_usage_percentage</code></td><td>Gauge</td><td>CPU usage</td><td>-</td></tr>
<tr><td><code>scim_database_connections_active</code></td><td>Gauge</td><td>Active DB connections</td><td><code>pool</code></td></tr>
<tr><td><code>scim_database_connections_idle</code></td><td>Gauge</td><td>Idle DB connections</td><td><code>pool</code></td></tr>
<tr><td><code>scim_cache_hits_total</code></td><td>Counter</td><td>Cache hits</td><td><code>cache_type</code></td></tr>
<tr><td><code>scim_cache_misses_total</code></td><td>Counter</td><td>Cache misses</td><td><code>cache_type</code></td></tr>
</tbody></table>
</div>
<h3 id="custom-metrics"><a class="header" href="#custom-metrics">Custom Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{Counter, Histogram, Gauge, MetricRegistry};

pub struct CustomMetrics {
    tenant_provisioning_duration: Histogram,
    active_sessions: Gauge,
    password_reset_requests: Counter,
    data_sync_errors: Counter,
}

impl CustomMetrics {
    pub fn new(registry: &amp;MetricRegistry) -&gt; Self {
        Self {
            tenant_provisioning_duration: registry.register_histogram(
                "scim_tenant_provisioning_duration_seconds",
                "Time to provision new tenant",
                vec!["tenant_type"]
            ),
            active_sessions: registry.register_gauge(
                "scim_active_sessions",
                "Number of active user sessions",
                vec!["tenant_id"]
            ),
            password_reset_requests: registry.register_counter(
                "scim_password_reset_requests_total",
                "Password reset requests",
                vec!["tenant_id", "method"]
            ),
            data_sync_errors: registry.register_counter(
                "scim_data_sync_errors_total",
                "Data synchronization errors",
                vec!["source_system", "error_type"]
            ),
        }
    }
    
    pub fn record_tenant_provisioning(&amp;self, tenant_type: &amp;str, duration: Duration) {
        self.tenant_provisioning_duration
            .with_label_values(&amp;[tenant_type])
            .observe(duration.as_secs_f64());
    }
    
    pub fn update_active_sessions(&amp;self, tenant_id: &amp;str, count: i64) {
        self.active_sessions
            .with_label_values(&amp;[tenant_id])
            .set(count as f64);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h2>
<h3 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::logging::{LoggingConfig, LogFormat, LogLevel};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

let logging_config = LoggingConfig::builder()
    .level(LogLevel::Info)
    .format(LogFormat::Json)
    .enable_spans(true)
    .enable_events(true)
    .fields(vec![
        "timestamp".to_string(),
        "level".to_string(),
        "target".to_string(),
        "message".to_string(),
        "tenant_id".to_string(),
        "user_id".to_string(),
        "request_id".to_string(),
        "operation".to_string(),
        "resource_type".to_string(),
        "duration_ms".to_string(),
    ])
    .exclude_fields(vec!["password".to_string(), "token".to_string()])
    .max_log_level_per_module(HashMap::from([
        ("scim_server::auth".to_string(), LogLevel::Debug),
        ("sqlx".to_string(), LogLevel::Warn),
    ]))
    .build()?;

// Initialize structured logging
tracing_subscriber::registry()
    .with(
        tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "scim_server=info".into())
    )
    .with(
        tracing_subscriber::fmt::layer()
            .json()
            .with_current_span(false)
            .with_span_list(true)
            .with_target(true)
            .with_thread_ids(true)
            .with_thread_names(true)
    )
    .init();
<span class="boring">}</span></code></pre></pre>
<h3 id="contextual-logging"><a class="header" href="#contextual-logging">Contextual Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, debug, Span};
use tracing_futures::Instrument;

// Create request-scoped spans
#[tracing::instrument(
    name = "create_user",
    skip(user_data),
    fields(
        tenant_id = %tenant_id,
        user_name = %user_data.user_name.as_deref().unwrap_or("unknown"),
        operation = "create_user"
    )
)]
pub async fn create_user(
    tenant_id: &amp;str,
    user_data: CreateUserRequest,
) -&gt; Result&lt;User, ScimError&gt; {
    let span = Span::current();
    
    // Add dynamic fields to the span
    span.record("user_id", &amp;tracing::field::display(&amp;user_data.id));
    
    info!("Starting user creation");
    
    // Validate input
    match validate_user_data(&amp;user_data).await {
        Ok(_) =&gt; debug!("User data validation passed"),
        Err(e) =&gt; {
            warn!(error = %e, "User data validation failed");
            return Err(ScimError::ValidationError(e));
        }
    }
    
    // Create user in storage
    let start_time = Instant::now();
    let user = match storage.create_user(tenant_id, user_data).await {
        Ok(user) =&gt; {
            let duration = start_time.elapsed();
            info!(
                duration_ms = duration.as_millis(),
                user_id = %user.id,
                "User created successfully"
            );
            user
        }
        Err(e) =&gt; {
            error!(
                error = %e,
                duration_ms = start_time.elapsed().as_millis(),
                "Failed to create user"
            );
            return Err(e);
        }
    };
    
    // Log business event
    info!(
        event_type = "user_created",
        user_id = %user.id,
        tenant_id = %tenant_id,
        user_name = %user.user_name,
        active = user.active,
        "User creation completed"
    );
    
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::audit::{AuditLogger, AuditEvent, AuditLevel};
use serde_json::json;

pub struct AuditLogger {
    logger: tracing::Span,
    config: AuditConfig,
}

impl AuditLogger {
    pub async fn log_user_operation(&amp;self, event: UserOperationEvent) {
        let audit_event = AuditEvent {
            timestamp: Utc::now(),
            event_type: "user_operation".to_string(),
            actor: ActorInfo {
                user_id: event.actor_id.clone(),
                session_id: event.session_id.clone(),
                ip_address: event.ip_address,
                user_agent: event.user_agent.clone(),
            },
            resource: ResourceInfo {
                resource_type: "User".to_string(),
                resource_id: event.user_id.clone(),
                tenant_id: event.tenant_id.clone(),
            },
            operation: OperationInfo {
                operation_type: event.operation.clone(),
                method: event.http_method.clone(),
                endpoint: event.endpoint.clone(),
                success: event.success,
                error_message: event.error_message.clone(),
            },
            details: json!({
                "user_id": event.user_id,
                "fields_modified": event.fields_modified,
                "before_values": event.before_values,
                "after_values": event.after_values,
                "request_size": event.request_size,
                "response_size": event.response_size,
            }),
        };
        
        // Log to structured log
        info!(
            target: "audit",
            event_type = %audit_event.event_type,
            actor_id = %audit_event.actor.user_id,
            resource_type = %audit_event.resource.resource_type,
            resource_id = %audit_event.resource.resource_id,
            tenant_id = %audit_event.resource.tenant_id,
            operation = %audit_event.operation.operation_type,
            success = audit_event.operation.success,
            ip_address = %audit_event.actor.ip_address,
            user_agent = %audit_event.actor.user_agent.as_deref().unwrap_or("unknown"),
            "{}", serde_json::to_string(&amp;audit_event.details).unwrap_or_default()
        );
        
        // Send to external audit system
        if let Some(webhook_url) = &amp;self.config.audit_webhook_url {
            self.send_to_webhook(webhook_url, &amp;audit_event).await;
        }
        
        // Store in database for compliance
        if self.config.store_in_database {
            self.store_audit_event(&amp;audit_event).await;
        }
    }
    
    pub async fn log_authentication_event(&amp;self, event: AuthenticationEvent) {
        info!(
            target: "audit.auth",
            event_type = "authentication",
            user_id = %event.user_id.as_deref().unwrap_or("unknown"),
            tenant_id = %event.tenant_id.as_deref().unwrap_or("unknown"),
            auth_method = %event.auth_method,
            success = event.success,
            failure_reason = %event.failure_reason.as_deref().unwrap_or(""),
            ip_address = %event.ip_address,
            user_agent = %event.user_agent.as_deref().unwrap_or("unknown"),
            session_id = %event.session_id.as_deref().unwrap_or(""),
            "Authentication attempt"
        );
        
        // Increment authentication metrics
        if event.success {
            self.metrics.authentication_success.inc();
        } else {
            self.metrics.authentication_failure.inc();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="distributed-tracing"><a class="header" href="#distributed-tracing">Distributed Tracing</a></h2>
<h3 id="opentelemetry-integration"><a class="header" href="#opentelemetry-integration">OpenTelemetry Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use opentelemetry::{global, trace::TracerProvider, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use tracing_opentelemetry::OpenTelemetryLayer;

pub async fn setup_tracing() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Configure OpenTelemetry exporter
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("http://jaeger:14268/api/traces")
        )
        .with_trace_config(
            opentelemetry::sdk::trace::config()
                .with_sampler(opentelemetry::sdk::trace::Sampler::TraceIdRatioBased(0.1))
                .with_resource(opentelemetry::sdk::Resource::new(vec![
                    KeyValue::new("service.name", "scim-server"),
                    KeyValue::new("service.version", env!("CARGO_PKG_VERSION")),
                    KeyValue::new("deployment.environment", "production"),
                ]))
        )
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    // Create tracing subscriber with OpenTelemetry layer
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new("scim_server=info"))
        .with(tracing_subscriber::fmt::layer())
        .with(OpenTelemetryLayer::new(tracer))
        .init();
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trace-instrumentation"><a class="header" href="#trace-instrumentation">Trace Instrumentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{instrument, Span};
use opentelemetry::trace::{TraceContextExt, Tracer};

#[instrument(
    name = "scim.user.create",
    skip(storage, user_data),
    fields(
        scim.tenant_id = %tenant_id,
        scim.operation = "create",
        scim.resource_type = "User",
        user.name = %user_data.user_name.as_deref().unwrap_or("unknown"),
        otel.kind = "server"
    )
)]
pub async fn create_user_with_tracing(
    storage: &amp;dyn StorageProvider,
    tenant_id: &amp;str,
    user_data: CreateUserRequest,
) -&gt; Result&lt;User, ScimError&gt; {
    let span = Span::current();
    let cx = span.context();
    
    // Add custom attributes
    if let Some(trace_id) = cx.span().span_context().trace_id().to_string() {
        span.record("trace_id", &amp;tracing::field::display(&amp;trace_id));
    }
    
    // Validate user data (child span)
    validate_user_data(&amp;user_data)
        .instrument(tracing::info_span!("scim.validation", validation.type = "user"))
        .await?;
    
    // Check uniqueness (child span)
    check_user_uniqueness(storage, tenant_id, &amp;user_data.user_name)
        .instrument(tracing::info_span!(
            "scim.uniqueness_check",
            db.operation = "select",
            user.name = %user_data.user_name
        ))
        .await?;
    
    // Create user in storage (child span)
    let user = storage
        .create_user(tenant_id, user_data)
        .instrument(tracing::info_span!(
            "scim.storage.create",
            db.operation = "insert",
            db.table = "users"
        ))
        .await?;
    
    // Record successful creation
    span.record("user.id", &amp;tracing::field::display(&amp;user.id));
    span.record("scim.status", "success");
    
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h2>
<h3 id="health-check-implementation"><a class="header" href="#health-check-implementation">Health Check Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::health::{HealthChecker, HealthStatus, HealthCheckResult};

pub struct HealthChecker {
    storage: Arc&lt;dyn StorageProvider&gt;,
    auth_service: Arc&lt;dyn AuthService&gt;,
    cache: Option&lt;Arc&lt;dyn CacheProvider&gt;&gt;,
    config: HealthCheckConfig,
}

impl HealthChecker {
    pub async fn check_health(&amp;self) -&gt; HealthCheckResult {
        let mut checks = Vec::new();
        
        // Overall health check
        checks.push(self.check_application_health().await);
        
        // Storage health
        checks.push(self.check_storage_health().await);
        
        // Authentication service health
        checks.push(self.check_auth_service_health().await);
        
        // Cache health (if configured)
        if let Some(cache) = &amp;self.cache {
            checks.push(self.check_cache_health(cache).await);
        }
        
        // External dependencies
        checks.push(self.check_external_dependencies().await);
        
        let overall_status = if checks.iter().all(|c| c.status == HealthStatus::Healthy) {
            HealthStatus::Healthy
        } else if checks.iter().any(|c| c.status == HealthStatus::Critical) {
            HealthStatus::Critical
        } else {
            HealthStatus::Degraded
        };
        
        HealthCheckResult {
            status: overall_status,
            timestamp: Utc::now(),
            checks,
            version: env!("CARGO_PKG_VERSION").to_string(),
            uptime_seconds: self.get_uptime_seconds(),
        }
    }
    
    async fn check_storage_health(&amp;self) -&gt; HealthCheck {
        let start_time = Instant::now();
        
        match timeout(Duration::from_secs(5), self.storage.health_check()).await {
            Ok(Ok(_)) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Healthy,
                response_time_ms: start_time.elapsed().as_millis() as u64,
                message: Some("Storage is responsive".to_string()),
                details: None,
            },
            Ok(Err(e)) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Critical,
                response_time_ms: start_time.elapsed().as_millis() as u64,
                message: Some(format!("Storage error: {}", e)),
                details: Some(json!({
                    "error_type": "storage_error",
                    "error_details": e.to_string()
                })),
            },
            Err(_) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Critical,
                response_time_ms: 5000,
                message: Some("Storage health check timeout".to_string()),
                details: Some(json!({
                    "error_type": "timeout",
                    "timeout_seconds": 5
                })),
            },
        }
    }
    
    async fn check_application_health(&amp;self) -&gt; HealthCheck {
        let mut details = serde_json::Map::new();
        
        // Check memory usage
        let memory_usage = self.get_memory_usage();
        details.insert("memory_usage_mb".to_string(), json!(memory_usage));
        
        // Check CPU usage
        let cpu_usage = self.get_cpu_usage().await;
        details.insert("cpu_usage_percent".to_string(), json!(cpu_usage));
        
        // Check active connections
        let active_connections = self.get_active_connections();
        details.insert("active_connections".to_string(), json!(active_connections));
        
        // Determine status based on resource usage
        let status = if memory_usage &gt; 90.0 || cpu_usage &gt; 95.0 {
            HealthStatus::Critical
        } else if memory_usage &gt; 80.0 || cpu_usage &gt; 85.0 {
            HealthStatus::Degraded
        } else {
            HealthStatus::Healthy
        };
        
        HealthCheck {
            name: "application".to_string(),
            status,
            response_time_ms: 0,
            message: Some("Application resource usage check".to_string()),
            details: Some(json!(details)),
        }
    }
}

// Health check endpoints
async fn health_live() -&gt; Result&lt;Json&lt;HealthCheckResult&gt;, StatusCode&gt; {
    // Simple liveness check
    Ok(Json(HealthCheckResult {
        status: HealthStatus::Healthy,
        timestamp: Utc::now(),
        checks: vec![],
        version: env!("CARGO_PKG_VERSION").to_string(),
        uptime_seconds: get_uptime_seconds(),
    }))
}

async fn health_ready(
    State(health_checker): State&lt;Arc&lt;HealthChecker&gt;&gt;,
) -&gt; Result&lt;Json&lt;HealthCheckResult&gt;, StatusCode&gt; {
    let result = health_checker.check_health().await;
    
    match result.status {
        HealthStatus::Healthy =&gt; Ok(Json(result)),
        HealthStatus::Degraded =&gt; {
            warn!("Health check returned degraded status: {:?}", result);
            Ok(Json(result))
        }
        HealthStatus::Critical =&gt; {
            error!("Health check returned critical status: {:?}", result);
            Err(StatusCode::SERVICE_UNAVAILABLE)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="alerting"><a class="header" href="#alerting">Alerting</a></h2>
<h3 id="alert-configuration"><a class="header" href="#alert-configuration">Alert Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::alerting::{AlertManager, AlertRule, AlertSeverity, AlertChannel};

pub struct AlertManager {
    rules: Vec&lt;AlertRule&gt;,
    channels: Vec&lt;AlertChannel&gt;,
    metrics_client: MetricsClient,
}

impl AlertManager {
    pub fn new() -&gt; Self {
        let rules = vec![
            // High error rate
            AlertRule {
                name: "high_error_rate".to_string(),
                description: "HTTP error rate above 5%".to_string(),
                query: "rate(scim_http_requests_total{status_code=~'5..'}[5m]) / rate(scim_http_requests_total[5m]) &gt; 0.05".to_string(),
                severity: AlertSeverity::Critical,
                for_duration: Duration::from_secs(300), // 5 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "error_rate".to_string()),
                ]),
            },
            
            // High response time
            AlertRule {
                name: "high_response_time".to_string(),
                description: "95th percentile response time above 1 second".to_string(),
                query: "histogram_quantile(0.95, rate(scim_http_request_duration_seconds_bucket[5m])) &gt; 1.0".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(600), // 10 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "performance".to_string()),
                ]),
            },
            
            // Database connection issues
            AlertRule {
                name: "database_connection_exhaustion".to_string(),
                description: "Database connection pool nearly exhausted".to_string(),
                query: "scim_database_connections_active / (scim_database_connections_active + scim_database_connections_idle) &gt; 0.9".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(120), // 2 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "database".to_string()),
                ]),
            },
            
            // Authentication failures
            AlertRule {
                name: "high_auth_failure_rate".to_string(),
                description: "Authentication failure rate above 10%".to_string(),
                query: "rate(scim_authentication_attempts_total{result='failure'}[5m]) / rate(scim_authentication_attempts_total[5m]) &gt; 0.1".to_string(),
                severity: AlertSeverity::Critical,
                for_duration: Duration::from_secs(180), // 3 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "security".to_string()),
                ]),
            },
            
            // Memory usage
            AlertRule {
                name: "high_memory_usage".to_string(),
                description: "Memory usage above 85%".to_string(),
                query: "scim_memory_usage_bytes{type='heap'} / scim_memory_usage_bytes{type='total'} &gt; 0.85".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(600), // 10 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "resource".to_string()),
                ]),
            },
        ];
        
        let channels = vec![
            AlertChannel::Slack {
                webhook_url: std::env::var("SLACK_WEBHOOK_URL").unwrap(),
                channel: "#alerts".to_string(),
                username: "SCIM Monitor".to_string(),
            },
            AlertChannel::PagerDuty {
                integration_key: std::env::var("PAGERDUTY_INTEGRATION_KEY").unwrap(),
            },
            AlertChannel::Email {
                smtp_server: "smtp.company.com".to_string(),
                recipients: vec![
                    "oncall@company.com".to_string(),
                    "devops@company.com".to_string(),
                ],
            },
        ];
        
        Self {
            rules,
            channels,
            metrics_client: MetricsClient::new(),
        }
    }
    
    pub async fn check_alerts(&amp;self) {
        for rule in &amp;self.rules {
            match self.evaluate_rule(rule).await {
                Ok(Some(alert)) =&gt; {
                    info!("Alert triggered: {}", alert.name);
                    self.send_alert(&amp;alert).await;
                }
                Ok(None) =&gt; {
                    debug!("Alert rule {} is not triggered", rule.name);
                }
                Err(e) =&gt; {
                    error!("Failed to evaluate alert rule {}: {}", rule.name, e);
                }
            }
        }
    }
    
    async fn send_alert(&amp;self, alert: &amp;Alert) {
        for channel in &amp;self.channels {
            match channel {
                AlertChannel::Slack { webhook_url, .. } =&gt; {
                    self.send_slack_alert(webhook_url, alert).await;
                }
                AlertChannel::PagerDuty { integration_key } =&gt; {
                    if alert.severity == AlertSeverity::Critical {
                        self.send_pagerduty_alert(integration_key, alert).await;
                    }
                }
                AlertChannel::Email { recipients, .. } =&gt; {
                    self.send_email_alert(recipients, alert).await;
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dashboards"><a class="header" href="#dashboards">Dashboards</a></h2>
<h3 id="grafana-dashboard-configuration"><a class="header" href="#grafana-dashboard-configuration">Grafana Dashboard Configuration</a></h3>
<pre><code class="language-json">{
  "dashboard": {
    "title": "SCIM Server Monitoring",
    "tags": ["scim", "identity", "monitoring"],
    "timezone": "UTC",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(scim_http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(scim_http_requests_total{status_code=~'4..|5..'}[5m]) / rate(scim_http_requests_total[5m])",
            "legendFormat": "Error Rate"
          }
        ],
        "yAxes": [
          {
            "label": "Error Rate (%)",
            "max": 1,
            "min": 0
          }
        ],
        "alert": {
          "conditions": [
            {
              "query": {
                "queryType": "",
                "refId": "A"
              },
              "reducer": {
                "type": "last",
                "params": []
              },
              "evaluator": {
                "params": [0.05],
                "type": "gt"
              }
            }
          ],
          "executionErrorState": "alerting",
          "for": "5m",
          "frequency": "10s",
          "handler": 1,
          "name": "High Error Rate",
          "noDataState": "no_data",
          "notifications": []
        }
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile"
          },
          {
            "expr": "histogram_quantile(0.95, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.99, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "99th percentile"
          }
        ]
      },
      {
        "title": "Active Users by Tenant",
        "type": "piechart",
        "targets": [
          {
            "expr": "scim_users_total{active='true'}",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "scim_database_connections_active",
            "legendFormat": "Active"
          },
          {
            "expr": "scim_database_connections_idle",
            "legendFormat": "Idle"
          }
        ]
      },
      {
        "title": "Authentication Methods",
        "type": "piechart",
        "targets": [
          {
            "expr": "increase(scim_authentication_attempts_total{result='success'}[1h])",
            "legendFormat": "{{method}}"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(scim_cache_hits_total[5m]) / (rate(scim_cache_hits_total[5m]) + rate(scim_cache_misses_total[5m]))",
            "legendFormat": "Hit Rate"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "percentunit",
            "min": 0,
            "max": 1
          }
        }
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
</code></pre>
<h3 id="business-intelligence-dashboard"><a class="header" href="#business-intelligence-dashboard">Business Intelligence Dashboard</a></h3>
<pre><code class="language-json">{
  "dashboard": {
    "title": "SCIM Business Metrics",
    "panels": [
      {
        "title": "User Growth by Tenant",
        "type": "graph",
        "targets": [
          {
            "expr": "increase(scim_users_total[24h])",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      },
      {
        "title": "Most Active Operations",
        "type": "table",
        "targets": [
          {
            "expr": "topk(10, increase(scim_operations_total[1h]))",
            "legendFormat": "{{operation}} - {{resource_type}}"
          }
        ]
      },
      {
        "title": "Tenant Resource Usage",
        "type": "heatmap",
        "targets": [
          {
            "expr": "scim_users_total + scim_groups_total",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="log-aggregation-and-analysis"><a class="header" href="#log-aggregation-and-analysis">Log Aggregation and Analysis</a></h2>
<h3 id="elk-stack-integration"><a class="header" href="#elk-stack-integration">ELK Stack Integration</a></h3>
<pre><code class="language-yaml"># Filebeat configuration
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/scim-server/*.log
  fields:
    service: scim-server
    environment: production
  fields_under_root: true
  multiline.pattern: '^\d{4}-\d{2}-\d{2}'
  multiline.negate: true
  multiline.match: after

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  template.settings:
    index.number_of_shards: 1
    index.number_of_replicas: 1

processors:
- add_host_metadata:
    when.not.contains.tags: forwarded
- decode_json_fields:
    fields: ["message"]
    target: "json"
    overwrite_keys: true
</code></pre>
<h3 id="logstash-processing"><a class="header" href="#logstash-processing">Logstash Processing</a></h3>
<pre><code class="language-ruby"># Logstash pipeline configuration
input {
  beats {
    port =&gt; 5044
  }
}

filter {
  if [service] == "scim-server" {
    json {
      source =&gt; "message"
    }
    
    # Parse timestamp
    date {
      match =&gt; [ "timestamp", "ISO8601" ]
    }
    
    # Extract tenant information
    if [tenant_id] {
      mutate {
        add_field =&gt; { "[@metadata][tenant]" =&gt; "%{tenant_id}" }
      }
    }
    
    # Classify log types
    if [target] == "audit" {
      mutate {
        add_tag =&gt; [ "audit" ]
        add_field =&gt; { "log_type" =&gt; "audit" }
      }
    } else if [level] == "ERROR" {
      mutate {
        add_tag =&gt; [ "error" ]
        add_field =&gt; { "log_type" =&gt; "error" }
      }
    }
    
    # Sanitize sensitive data
    mutate {
      remove_field =&gt; [ "password", "token", "authorization" ]
    }
  }
}

output {
  elasticsearch {
    hosts =&gt; ["elasticsearch:9200"]
    index =&gt; "scim-server-%{+YYYY.MM.dd}"
    template_overwrite =&gt; true
    template_pattern =&gt; "scim-server-*"
    template =&gt; "/etc/logstash/templates/scim-server.json"
  }
}
</code></pre>
<h3 id="kibana-visualizations"><a class="header" href="#kibana-visualizations">Kibana Visualizations</a></h3>
<pre><code class="language-json">{
  "objects": [
    {
      "id": "scim-error-analysis",
      "type": "visualization",
      "attributes": {
        "title": "Error Analysis",
        "visState": {
          "type": "histogram",
          "params": {
            "grid": { "categoryLines": false, "style": { "color": "#eee" } },
            "categoryAxes": [{ "id": "CategoryAxis-1", "type": "category", "position": "bottom", "show": true, "style": {}, "scale": { "type": "linear" }, "labels": { "show": true, "truncate": 100 }, "title": {} }],
            "valueAxes": [{ "id": "ValueAxis-1", "name": "LeftAxis-1", "type": "value", "position": "left", "show": true, "style": {}, "scale": { "type": "linear", "mode": "normal" }, "labels": { "show": true, "rotate": 0, "filter": false, "truncate": 100 }, "title": { "text": "Count" } }]
          },
          "aggs": [
            { "id": "1", "enabled": true, "type": "count", "schema": "metric", "params": {} },
            { "id": "2", "enabled": true, "type": "terms", "schema": "segment", "params": { "field": "error_type.keyword", "size": 10, "order": "desc", "orderBy": "1" } }
          ]
        },
        "uiStateJSON": "{}",
        "description": "",
        "version": 1,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": {
            "index": "scim-server-*",
            "query": {
              "match": { "level": "ERROR" }
            }
          }
        }
      }
    }
  ]
}
</code></pre>
<h2 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h2>
<h3 id="application-performance-monitoring-apm"><a class="header" href="#application-performance-monitoring-apm">Application Performance Monitoring (APM)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::apm::{ApmAgent, TransactionType, SpanType};

pub struct ApmAgent {
    elastic_apm: elastic_apm::Agent,
    config: ApmConfig,
}

impl ApmAgent {
    pub async fn trace_operation&lt;F, T&gt;(
        &amp;self,
        operation_name: &amp;str,
        transaction_type: TransactionType,
        operation: F,
    ) -&gt; Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;
    where
        F: Future&lt;Output = Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;&gt;,
    {
        let transaction = self.elastic_apm.begin_transaction(
            operation_name,
            transaction_type.as_str(),
        );
        
        let start_time = Instant::now();
        let result = operation.await;
        let duration = start_time.elapsed();
        
        match &amp;result {
            Ok(_) =&gt; {
                transaction.set_result("success");
                transaction.set_outcome(elastic_apm::Outcome::Success);
            }
            Err(e) =&gt; {
                transaction.set_result("error");
                transaction.set_outcome(elastic_apm::Outcome::Failure);
                transaction.capture_error(e);
            }
        }
        
        transaction.set_custom_context("performance", json!({
            "duration_ms": duration.as_millis(),
            "operation": operation_name,
        }));
        
        transaction.end();
        result
    }
    
    pub fn create_span&lt;F, T&gt;(
        &amp;self,
        span_name: &amp;str,
        span_type: SpanType,
        operation: F,
    ) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let span = self.elastic_apm.begin_span(span_name, span_type.as_str());
        let result = operation();
        span.end();
        result
    }
}

// Usage in request handlers
#[axum::debug_handler]
async fn create_user_handler(
    State(app_state): State&lt;AppState&gt;,
    Json(user_data): Json&lt;CreateUserRequest&gt;,
) -&gt; Result&lt;Json&lt;User&gt;, ScimError&gt; {
    app_state.apm.trace_operation(
        "create_user",
        TransactionType::Request,
        async {
            let user = app_state.scim_server
                .create_user(&amp;user_data.tenant_id, user_data)
                .await?;
            Ok(Json(user))
        }
    ).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-performance-monitoring"><a class="header" href="#database-performance-monitoring">Database Performance Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{query, Pool, Postgres};
use tracing::{instrument, Span};

pub struct DatabaseMonitor {
    pool: Pool&lt;Postgres&gt;,
    metrics: DatabaseMetrics,
}

impl DatabaseMonitor {
    #[instrument(skip(self, query_str, params))]
    pub async fn execute_monitored_query&lt;T&gt;(
        &amp;self,
        query_str: &amp;str,
        params: &amp;[&amp;dyn sqlx::Type&lt;Postgres&gt;],
    ) -&gt; Result&lt;T, sqlx::Error&gt;
    where
        T: for&lt;'r&gt; sqlx::FromRow&lt;'r, sqlx::postgres::PgRow&gt; + Send + Unpin,
    {
        let span = Span::current();
        let start_time = Instant::now();
        
        // Record query details (sanitized)
        span.record("db.statement", &amp;sanitize_query(query_str));
        span.record("db.operation", &amp;extract_operation(query_str));
        
        // Execute query
        let result = sqlx::query_as::&lt;_, T&gt;(query_str)
            .fetch_all(&amp;self.pool)
            .await;
        
        let duration = start_time.elapsed();
        
        // Record metrics
        match &amp;result {
            Ok(rows) =&gt; {
                span.record("db.rows_affected", &amp;rows.len());
                span.record("db.duration_ms", &amp;duration.as_millis());
                self.metrics.query_duration.observe(duration.as_secs_f64());
                self.metrics.query_success.inc();
            }
            Err(e) =&gt; {
                span.record("db.error", &amp;e.to_string());
                span.record("db.duration_ms", &amp;duration.as_millis());
                self.metrics.query_errors.inc();
                warn!("Database query failed: {}", e);
            }
        }
        
        // Alert on slow queries
        if duration &gt; Duration::from_millis(1000) {
            warn!(
                duration_ms = duration.as_millis(),
                query = sanitize_query(query_str),
                "Slow database query detected"
            );
        }
        
        result
    }
}

fn sanitize_query(query: &amp;str) -&gt; String {
    // Remove sensitive data from query for logging
    query
        .replace(|c: char| c.is_numeric(), "?")
        .replace("'.*?'", "'?'")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="observability-best-practices"><a class="header" href="#observability-best-practices">Observability Best Practices</a></h2>
<h3 id="correlation-and-context"><a class="header" href="#correlation-and-context">Correlation and Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use uuid::Uuid;
use tracing_subscriber::layer::SubscriberExt;

// Request correlation
#[derive(Clone)]
pub struct RequestContext {
    pub request_id: Uuid,
    pub tenant_id: Option&lt;String&gt;,
    pub user_id: Option&lt;String&gt;,
    pub session_id: Option&lt;String&gt;,
    pub ip_address: IpAddr,
    pub user_agent: Option&lt;String&gt;,
}

impl RequestContext {
    pub fn new(headers: &amp;HeaderMap, remote_addr: SocketAddr) -&gt; Self {
        let request_id = headers
            .get("x-request-id")
            .and_then(|h| h.to_str().ok())
            .and_then(|s| Uuid::parse_str(s).ok())
            .unwrap_or_else(Uuid::new_v4);
        
        Self {
            request_id,
            tenant_id: headers.get("x-tenant-id")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
            user_id: None, // Set after authentication
            session_id: None, // Set after authentication
            ip_address: remote_addr.ip(),
            user_agent: headers.get("user-agent")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
        }
    }
    
    pub fn create_span(&amp;self, operation: &amp;str) -&gt; tracing::Span {
        tracing::info_span!(
            "scim_operation",
            operation = operation,
            request_id = %self.request_id,
            tenant_id = %self.tenant_id.as_deref().unwrap_or("unknown"),
            user_id = %self.user_id.as_deref().unwrap_or("anonymous"),
            ip_address = %self.ip_address,
        )
    }
}

// Middleware for request correlation
pub async fn correlation_middleware(
    ConnectInfo(addr): ConnectInfo&lt;SocketAddr&gt;,
    mut req: Request&lt;Body&gt;,
    next: Next&lt;Body&gt;,
) -&gt; Response&lt;Body&gt; {
    let context = RequestContext::new(req.headers(), addr);
    
    // Add context to request extensions
    req.extensions_mut().insert(context.clone());
    
    // Create request span
    let span = context.create_span("http_request");
    let _guard = span.enter();
    
    // Add request ID to response headers
    let mut response = next.run(req).await;
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&amp;context.request_id.to_string()).unwrap(),
    );
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-tracking-integration"><a class="header" href="#error-tracking-integration">Error Tracking Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sentry::{ClientOptions, integrations::tracing::EventFilter};

pub fn setup_error_tracking() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let _guard = sentry::init((
        std::env::var("SENTRY_DSN")?,
        ClientOptions {
            release: Some(env!("CARGO_PKG_VERSION").into()),
            environment: Some(std::env::var("ENVIRONMENT").unwrap_or("unknown".into()).into()),
            sample_rate: 1.0,
            traces_sample_rate: 0.1,
            ..Default::default()
        },
    ));
    
    // Configure tracing integration
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new("scim_server=info"))
        .with(tracing_subscriber::fmt::layer())
        .with(sentry_tracing::layer().event_filter(|md| {
            match md.level() {
                &amp;tracing::Level::ERROR =&gt; EventFilter::Event,
                &amp;tracing::Level::WARN =&gt; EventFilter::Breadcrumb,
                _ =&gt; EventFilter::Ignore,
            }
        }))
        .init();
    
    Ok(())
}

// Custom error reporting
pub async fn report_error(
    error: &amp;dyn std::error::Error,
    context: &amp;RequestContext,
    additional_data: Option&lt;serde_json::Value&gt;,
) {
    sentry::with_scope(|scope| {
        scope.set_tag("request_id", &amp;context.request_id.to_string());
        scope.set_tag("tenant_id", context.tenant_id.as_deref().unwrap_or("unknown"));
        scope.set_user(Some(sentry::User {
            id: context.user_id.clone(),
            ip_address: Some(context.ip_address.to_string()),
            ..Default::default()
        }));
        
        if let Some(data) = additional_data {
            scope.set_context("additional_data", sentry::protocol::Context::Other(data.into()));
        }
        
        sentry::capture_error(error);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive monitoring and observability guide provides the foundation for operating SCIM servers with full visibility into performance, errors, and business metrics. Regular review and tuning of monitoring configurations ensure optimal system health and rapid incident response.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../advanced/security.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/api-endpoints.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../advanced/security.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/api-endpoints.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
