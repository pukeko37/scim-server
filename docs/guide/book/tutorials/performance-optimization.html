<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Performance Optimization - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<p>This tutorial covers techniques for optimizing SCIM Server performance, including database optimization, caching strategies, connection pooling, and monitoring performance bottlenecks.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Performance optimization in SCIM Server involves several layers:</p>
<ul>
<li><strong>Database Performance</strong>: Query optimization, indexing, and connection pooling</li>
<li><strong>Application Performance</strong>: Efficient data structures and algorithms</li>
<li><strong>Caching</strong>: Strategic caching of frequently accessed data</li>
<li><strong>Network Performance</strong>: Connection reuse and payload optimization</li>
<li><strong>Monitoring</strong>: Identifying and resolving bottlenecks</li>
</ul>
<h2 id="database-optimization"><a class="header" href="#database-optimization">Database Optimization</a></h2>
<h3 id="query-performance"><a class="header" href="#query-performance">Query Performance</a></h3>
<p><strong>Efficient data loading patterns:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ListOptions};

// Inefficient: Load all users then filter in memory
async fn get_active_users_slow(provider: &amp;impl Provider, tenant_id: &amp;str) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Error&gt; {
    let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
    let active_users: Vec&lt;_&gt; = all_users.resources.into_iter()
        .filter(|user| user.active())
        .collect();
    Ok(active_users)
}

// Better: Use pagination to limit memory usage
async fn get_users_paginated(provider: &amp;impl Provider, tenant_id: &amp;str) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Error&gt; {
    let options = ListOptions::builder()
        .count(Some(100))        // Limit to 100 users per request
        .start_index(Some(1))    // Start from first user
        .build();
    
    let response = provider.list_users(tenant_id, &amp;options).await?;
    
    // Filter in memory for now (database filtering not yet implemented)
    let active_users: Vec&lt;_&gt; = response.resources.into_iter()
        .filter(|user| user.active())
        .collect();
    
    Ok(active_users)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize complex queries:</strong></p>
<pre><code class="language-sql">-- Add indexes for common filter patterns
CREATE INDEX CONCURRENTLY idx_users_active_dept ON users(tenant_id, active, department) 
WHERE active = true;

CREATE INDEX CONCURRENTLY idx_users_email_lookup ON users(tenant_id, (data-&gt;&gt;'primaryEmail'));

CREATE INDEX CONCURRENTLY idx_users_last_modified ON users(tenant_id, updated_at) 
WHERE updated_at &gt; NOW() - INTERVAL '30 days';

-- Use partial indexes for common conditions
CREATE INDEX CONCURRENTLY idx_groups_with_members ON groups(tenant_id, display_name) 
WHERE jsonb_array_length(data-&gt;'members') &gt; 0;
</code></pre>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<p><strong>Optimize database connections:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_optimized_pool(database_url: &amp;str) -&gt; Result&lt;sqlx::PgPool, sqlx::Error&gt; {
    PgPoolOptions::new()
        .max_connections(20)                    // Adjust based on your load
        .min_connections(5)                     // Keep minimum connections warm
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Some(Duration::from_secs(600)))
        .max_lifetime(Some(Duration::from_secs(1800)))
        .test_before_acquire(true)              // Test connections before use
        .after_connect(|conn, _meta| {
            Box::pin(async move {
                // Optimize connection settings
                sqlx::query("SET statement_timeout = '30s'")
                    .execute(conn)
                    .await?;
                sqlx::query("SET lock_timeout = '10s'")
                    .execute(conn)
                    .await?;
                Ok(())
            })
        })
        .connect(database_url)
        .await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p><strong>Use transactions for related operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{Transaction, Postgres};

async fn create_user_with_groups_optimized(
    provider: &amp;DatabaseProvider,
    tenant_id: &amp;str,
    user: ScimUser,
    group_ids: Vec&lt;String&gt;,
) -&gt; Result&lt;ScimUser, ProviderError&gt; {
    let mut tx = provider.begin_transaction().await?;
    
    // Create user
    let created_user = tx.create_user(tenant_id, user).await?;
    
    // Add to groups in batch
    if !group_ids.is_empty() {
        let query = format!(
            "INSERT INTO group_memberships (group_id, user_id) VALUES {}",
            group_ids.iter()
                .map(|_| "($1, $2)")
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .join(", ")
        );
        
        let mut query_builder = sqlx::query(&amp;query);
        for group_id in &amp;group_ids {
            query_builder = query_builder.bind(group_id).bind(created_user.id());
        }
        
        query_builder.execute(&amp;mut *tx).await?;
    }
    
    tx.commit().await?;
    Ok(created_user)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h2>
<h3 id="redis-caching"><a class="header" href="#redis-caching">Redis Caching</a></h3>
<p><strong>Implement multi-layer caching:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use redis::{AsyncCommands, Client};
use serde::{Serialize, Deserialize};
use std::time::Duration;

#[derive(Clone)]
pub struct CachedProvider {
    inner: DatabaseProvider,
    redis: Client,
    cache_ttl: Duration,
}

impl CachedProvider {
    pub fn new(inner: DatabaseProvider, redis_url: &amp;str, cache_ttl: Duration) -&gt; Result&lt;Self, redis::RedisError&gt; {
        let redis = Client::open(redis_url)?;
        Ok(Self { inner, redis, cache_ttl })
    }
    
    async fn get_user_cached(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        let cache_key = format!("user:{}:{}", tenant_id, user_id);
        
        // Try L1 cache (Redis)
        if let Ok(mut conn) = self.redis.get_async_connection().await {
            if let Ok(cached_data) = conn.get::&lt;_, String&gt;(&amp;cache_key).await {
                if let Ok(user) = serde_json::from_str::&lt;ScimUser&gt;(&amp;cached_data) {
                    return Ok(Some(user));
                }
            }
        }
        
        // L2 cache miss - fetch from database
        let user = self.inner.get_user(tenant_id, user_id).await?;
        
        // Cache the result
        if let (Some(ref user), Ok(mut conn)) = (&amp;user, self.redis.get_async_connection().await) {
            if let Ok(serialized) = serde_json::to_string(user) {
                let _: Result&lt;(), _&gt; = conn.setex(&amp;cache_key, self.cache_ttl.as_secs(), serialized).await;
            }
        }
        
        Ok(user)
    }
    
    async fn invalidate_user_cache(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;(), redis::RedisError&gt; {
        let cache_key = format!("user:{}:{}", tenant_id, user_id);
        let mut conn = self.redis.get_async_connection().await?;
        conn.del(&amp;cache_key).await?;
        
        // Also invalidate related caches
        let pattern = format!("users:{}:*", tenant_id);
        self.invalidate_pattern(&amp;pattern).await?;
        
        Ok(())
    }
    
    async fn invalidate_pattern(&amp;self, pattern: &amp;str) -&gt; Result&lt;(), redis::RedisError&gt; {
        let mut conn = self.redis.get_async_connection().await?;
        let keys: Vec&lt;String&gt; = conn.keys(pattern).await?;
        
        if !keys.is_empty() {
            conn.del(&amp;keys).await?;
        }
        
        Ok(())
    }
}

// Implement cache-aware operations
#[async_trait]
impl Provider for CachedProvider {
    async fn get_user(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        self.get_user_cached(tenant_id, user_id).await
    }
    
    async fn update_user(&amp;self, tenant_id: &amp;str, user: ScimUser) -&gt; Result&lt;ScimUser, ProviderError&gt; {
        let updated_user = self.inner.update_user(tenant_id, user).await?;
        
        // Invalidate cache
        if let Err(e) = self.invalidate_user_cache(tenant_id, updated_user.id()).await {
            tracing::warn!("Failed to invalidate user cache: {}", e);
        }
        
        Ok(updated_user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="in-memory-caching"><a class="header" href="#in-memory-caching">In-Memory Caching</a></h3>
<p><strong>Application-level caching for frequently accessed data:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Clone)]
struct CacheEntry&lt;T&gt; {
    value: T,
    expires_at: Instant,
}

#[derive(Clone)]
pub struct MemoryCache&lt;T&gt; {
    data: Arc&lt;RwLock&lt;HashMap&lt;String, CacheEntry&lt;T&gt;&gt;&gt;&gt;,
    ttl: Duration,
}

impl&lt;T: Clone&gt; MemoryCache&lt;T&gt; {
    pub fn new(ttl: Duration) -&gt; Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            ttl,
        }
    }
    
    pub async fn get(&amp;self, key: &amp;str) -&gt; Option&lt;T&gt; {
        let data = self.data.read().await;
        
        if let Some(entry) = data.get(key) {
            if entry.expires_at &gt; Instant::now() {
                return Some(entry.value.clone());
            }
        }
        
        None
    }
    
    pub async fn set(&amp;self, key: String, value: T) {
        let mut data = self.data.write().await;
        data.insert(key, CacheEntry {
            value,
            expires_at: Instant::now() + self.ttl,
        });
    }
    
    pub async fn invalidate(&amp;self, key: &amp;str) {
        let mut data = self.data.write().await;
        data.remove(key);
    }
    
    // Background cleanup task
    pub async fn cleanup_expired(&amp;self) {
        let mut data = self.data.write().await;
        let now = Instant::now();
        data.retain(|_, entry| entry.expires_at &gt; now);
    }
}

// Usage in provider
#[derive(Clone)]
pub struct MemoryCachedProvider {
    inner: DatabaseProvider,
    user_cache: MemoryCache&lt;ScimUser&gt;,
    schema_cache: MemoryCache&lt;Schema&gt;,
}

impl MemoryCachedProvider {
    pub fn new(inner: DatabaseProvider) -&gt; Self {
        let provider = Self {
            inner,
            user_cache: MemoryCache::new(Duration::from_secs(300)), // 5 minutes
            schema_cache: MemoryCache::new(Duration::from_secs(3600)), // 1 hour
        };
        
        // Start cleanup task
        let cache = provider.user_cache.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));
            loop {
                interval.tick().await;
                cache.cleanup_expired().await;
            }
        });
        
        provider
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-and-resource-management"><a class="header" href="#connection-and-resource-management">Connection and Resource Management</a></h2>
<h3 id="http-client-optimization"><a class="header" href="#http-client-optimization">HTTP Client Optimization</a></h3>
<p><strong>Reuse HTTP connections:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;
use std::time::Duration;

lazy_static! {
    static ref HTTP_CLIENT: Client = Client::builder()
        .timeout(Duration::from_secs(30))
        .connect_timeout(Duration::from_secs(10))
        .pool_max_idle_per_host(10)
        .pool_idle_timeout(Duration::from_secs(90))
        .build()
        .expect("Failed to create HTTP client");
}

// Use the shared client for external API calls
async fn validate_oauth_token(token: &amp;str) -&gt; Result&lt;Claims, Error&gt; {
    let response = HTTP_CLIENT
        .post("https://oauth.provider.com/introspect")
        .form(&amp;[("token", token)])
        .send()
        .await?;
    
    let claims: Claims = response.json().await?;
    Ok(claims)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-pooling"><a class="header" href="#resource-pooling">Resource Pooling</a></h3>
<p><strong>Implement object pooling for expensive operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deadpool::managed::{Manager, Object, Pool, PoolError};
use async_trait::async_trait;

#[derive(Clone)]
pub struct ExpensiveResource {
    // Some expensive-to-create resource
    id: uuid::Uuid,
    data: Vec&lt;u8&gt;,
}

pub struct ResourceManager;

#[async_trait]
impl Manager for ResourceManager {
    type Type = ExpensiveResource;
    type Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;
    
    async fn create(&amp;self) -&gt; Result&lt;Self::Type, Self::Error&gt; {
        // Expensive resource creation
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        Ok(ExpensiveResource {
            id: uuid::Uuid::new_v4(),
            data: vec![0u8; 1024 * 1024], // 1MB
        })
    }
    
    async fn recycle(&amp;self, _obj: &amp;mut Self::Type) -&gt; Result&lt;(), Self::Error&gt; {
        // Reset/cleanup resource for reuse
        Ok(())
    }
}

// Usage
pub async fn create_resource_pool() -&gt; Pool&lt;ResourceManager&gt; {
    Pool::builder(ResourceManager)
        .max_size(10)
        .build()
        .expect("Failed to create resource pool")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithm-and-data-structure-optimization"><a class="header" href="#algorithm-and-data-structure-optimization">Algorithm and Data Structure Optimization</a></h2>
<h3 id="efficient-data-structures"><a class="header" href="#efficient-data-structures">Efficient Data Structures</a></h3>
<p><strong>Use appropriate data structures for different access patterns:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap, BTreeMap, HashSet};
use indexmap::IndexMap;

#[derive(Clone)]
pub struct OptimizedUserStore {
    // Fast lookup by ID
    users_by_id: HashMap&lt;String, ScimUser&gt;,
    
    // Fast lookup by username (unique)
    users_by_username: HashMap&lt;String, String&gt;, // username -&gt; id
    
    // Fast lookup by email
    users_by_email: HashMap&lt;String, String&gt;, // email -&gt; id
    
    // Ordered access for pagination
    users_ordered: IndexMap&lt;String, ScimUser&gt;, // maintains insertion order
    
    // Fast membership testing
    active_user_ids: HashSet&lt;String&gt;,
}

impl OptimizedUserStore {
    pub fn new() -&gt; Self {
        Self {
            users_by_id: HashMap::new(),
            users_by_username: HashMap::new(),
            users_by_email: HashMap::new(),
            users_ordered: IndexMap::new(),
            active_user_ids: HashSet::new(),
        }
    }
    
    pub fn add_user(&amp;mut self, user: ScimUser) {
        let id = user.id().to_string();
        let username = user.username().to_string();
        
        // Update all indexes
        self.users_by_username.insert(username, id.clone());
        
        if let Some(email) = user.primary_email() {
            self.users_by_email.insert(email.to_string(), id.clone());
        }
        
        if user.active() {
            self.active_user_ids.insert(id.clone());
        }
        
        self.users_by_id.insert(id.clone(), user.clone());
        self.users_ordered.insert(id, user);
    }
    
    pub fn get_by_username(&amp;self, username: &amp;str) -&gt; Option&lt;&amp;ScimUser&gt; {
        self.users_by_username
            .get(username)
            .and_then(|id| self.users_by_id.get(id))
    }
    
    pub fn get_active_users(&amp;self) -&gt; impl Iterator&lt;Item = &amp;ScimUser&gt; {
        self.active_user_ids
            .iter()
            .filter_map(|id| self.users_by_id.get(id))
    }
    
    pub fn paginate(&amp;self, start: usize, count: usize) -&gt; impl Iterator&lt;Item = &amp;ScimUser&gt; {
        self.users_ordered
            .values()
            .skip(start)
            .take(count)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bulk-processing"><a class="header" href="#bulk-processing">Bulk Processing</a></h3>
<p><strong>Optimize bulk operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::stream::{self, StreamExt};
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct BulkProcessor {
    concurrency_limit: usize,
    batch_size: usize,
}

impl BulkProcessor {
    pub fn new(concurrency_limit: usize, batch_size: usize) -&gt; Self {
        Self {
            concurrency_limit,
            batch_size,
        }
    }
    
    pub async fn process_users_bulk&lt;F, Fut&gt;(
        &amp;self,
        users: Vec&lt;ScimUser&gt;,
        processor: F,
    ) -&gt; Result&lt;Vec&lt;ProcessResult&gt;, Error&gt;
    where
        F: Fn(ScimUser) -&gt; Fut + Clone + Send + 'static,
        Fut: Future&lt;Output = Result&lt;ScimUser, Error&gt;&gt; + Send,
    {
        let processed_count = AtomicUsize::new(0);
        let total_count = users.len();
        
        let results = stream::iter(users)
            .map(move |user| {
                let processor = processor.clone();
                let processed_count = &amp;processed_count;
                
                async move {
                    let result = processor(user).await;
                    let count = processed_count.fetch_add(1, Ordering::Relaxed) + 1;
                    
                    if count % 100 == 0 {
                        tracing::info!("Processed {}/{} users", count, total_count);
                    }
                    
                    result
                }
            })
            .buffer_unordered(self.concurrency_limit)
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .await;
        
        Ok(results.into_iter().collect())
    }
    
    pub async fn process_in_batches&lt;T, F, Fut&gt;(
        &amp;self,
        items: Vec&lt;T&gt;,
        processor: F,
    ) -&gt; Result&lt;Vec&lt;T&gt;, Error&gt;
    where
        T: Send + 'static,
        F: Fn(Vec&lt;T&gt;) -&gt; Fut + Send + 'static,
        Fut: Future&lt;Output = Result&lt;Vec&lt;T&gt;, Error&gt;&gt; + Send,
    {
        let mut results = Vec::new();
        
        for batch in items.chunks(self.batch_size) {
            let batch_result = processor(batch.to_vec()).await?;
            results.extend(batch_result);
        }
        
        Ok(results)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h2>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<p><strong>Track key performance indicators:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Gauge, register_counter, register_histogram, register_gauge};
use std::time::Instant;

lazy_static! {
    static ref OPERATION_DURATION: Histogram = register_histogram!(
        "scim_operation_duration_seconds",
        "Duration of SCIM operations",
        vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
    ).unwrap();
    
    static ref CACHE_HITS: Counter = register_counter!(
        "scim_cache_hits_total",
        "Total cache hits"
    ).unwrap();
    
    static ref CACHE_MISSES: Counter = register_counter!(
        "scim_cache_misses_total",
        "Total cache misses"
    ).unwrap();
    
    static ref ACTIVE_CONNECTIONS: Gauge = register_gauge!(
        "scim_active_db_connections",
        "Number of active database connections"
    ).unwrap();
}

pub struct PerformanceTracker;

impl PerformanceTracker {
    pub fn time_operation&lt;F, T&gt;(operation_name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let _timer = OPERATION_DURATION
            .with_label_values(&amp;[operation_name])
            .start_timer();
        
        f()
    }
    
    pub async fn time_async_operation&lt;F, Fut, T&gt;(operation_name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; Fut,
        Fut: Future&lt;Output = T&gt;,
    {
        let _timer = OPERATION_DURATION
            .with_label_values(&amp;[operation_name])
            .start_timer();
        
        f().await
    }
    
    pub fn record_cache_hit() {
        CACHE_HITS.inc();
    }
    
    pub fn record_cache_miss() {
        CACHE_MISSES.inc();
    }
    
    pub fn set_active_connections(count: i64) {
        ACTIVE_CONNECTIONS.set(count as f64);
    }
}

// Usage in provider
impl CachedProvider {
    async fn get_user(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        PerformanceTracker::time_async_operation("get_user", async {
            if let Some(user) = self.get_from_cache(tenant_id, user_id).await {
                PerformanceTracker::record_cache_hit();
                return Ok(Some(user));
            }
            
            PerformanceTracker::record_cache_miss();
            let user = self.inner.get_user(tenant_id, user_id).await?;
            
            if let Some(ref user) = user {
                self.cache_user(tenant_id, user).await;
            }
            
            Ok(user)
        }).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h3>
<p><strong>Add profiling capabilities:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use std::collections::HashMap;
use tokio::sync::RwLock;

#[derive(Clone)]
pub struct ProfileData {
    pub calls: u64,
    pub total_duration: Duration,
    pub min_duration: Duration,
    pub max_duration: Duration,
    pub avg_duration: Duration,
}

#[derive(Clone)]
pub struct Profiler {
    data: Arc&lt;RwLock&lt;HashMap&lt;String, ProfileData&gt;&gt;&gt;,
}

impl Profiler {
    pub fn new() -&gt; Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn profile&lt;F, T&gt;(&amp;self, name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let start = Instant::now();
        let result = f();
        let duration = start.elapsed();
        
        self.record(name, duration).await;
        result
    }
    
    pub async fn profile_async&lt;F, Fut, T&gt;(&amp;self, name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; Fut,
        Fut: Future&lt;Output = T&gt;,
    {
        let start = Instant::now();
        let result = f().await;
        let duration = start.elapsed();
        
        self.record(name, duration).await;
        result
    }
    
    async fn record(&amp;self, name: &amp;str, duration: Duration) {
        let mut data = self.data.write().await;
        
        let entry = data.entry(name.to_string()).or_insert(ProfileData {
            calls: 0,
            total_duration: Duration::ZERO,
            min_duration: Duration::MAX,
            max_duration: Duration::ZERO,
            avg_duration: Duration::ZERO,
        });
        
        entry.calls += 1;
        entry.total_duration += duration;
        entry.min_duration = entry.min_duration.min(duration);
        entry.max_duration = entry.max_duration.max(duration);
        entry.avg_duration = entry.total_duration / entry.calls as u32;
    }
    
    pub async fn get_report(&amp;self) -&gt; HashMap&lt;String, ProfileData&gt; {
        self.data.read().await.clone()
    }
    
    pub async fn reset(&amp;self) {
        self.data.write().await.clear();
    }
}

// Usage
lazy_static! {
    static ref GLOBAL_PROFILER: Profiler = Profiler::new();
}

// Endpoint to get profiling data
async fn profiling_report() -&gt; Json&lt;serde_json::Value&gt; {
    let report = GLOBAL_PROFILER.get_report().await;
    
    let formatted_report: HashMap&lt;String, serde_json::Value&gt; = report
        .into_iter()
        .map(|(name, data)| {
            (name, json!({
                "calls": data.calls,
                "total_duration_ms": data.total_duration.as_millis(),
                "avg_duration_ms": data.avg_duration.as_millis(),
                "min_duration_ms": data.min_duration.as_millis(),
                "max_duration_ms": data.max_duration.as_millis(),
            }))
        })
        .collect();
    
    Json(json!(formatted_report))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="load-testing-and-benchmarking"><a class="header" href="#load-testing-and-benchmarking">Load Testing and Benchmarking</a></h2>
<h3 id="load-testing-setup"><a class="header" href="#load-testing-setup">Load Testing Setup</a></h3>
<p><strong>Create load tests to identify bottlenecks:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod load_tests {
    use super::*;
    use tokio::task::JoinSet;
    use std::sync::Arc;
    use std::time::{Duration, Instant};
    
    #[tokio::test]
    #[ignore] // Run with --ignored flag
    async fn load_test_user_operations() {
        let provider = create_test_provider().await;
        let tenant_id = "load-test-tenant";
        
        let concurrent_operations = 100;
        let operations_per_task = 10;
        
        let start_time = Instant::now();
        let mut tasks = JoinSet::new();
        
        for task_id in 0..concurrent_operations {
            let provider = provider.clone();
            let tenant_id = tenant_id.to_string();
            
            tasks.spawn(async move {
                for i in 0..operations_per_task {
                    let user = ScimUser::builder()
                        .username(&amp;format!("user-{}-{}", task_id, i))
                        .given_name("Load")
                        .family_name("Test")
                        .email(&amp;format!("user-{}-{}@test.com", task_id, i))
                        .build()
                        .unwrap();
                    
                    // Create user
                    let created = provider.create_user(&amp;tenant_id, user).await.unwrap();
                    
                    // Read user
                    let _read = provider.get_user(&amp;tenant_id, created.id()).await.unwrap();
                    
                    // Update user
                    let mut updated = created;
                    updated.set_given_name("Updated");
                    let _updated = provider.update_user(&amp;tenant_id, updated).await.unwrap();
                }
            });
        }
        
        // Wait for all tasks to complete
        while let Some(result) = tasks.join_next().await {
            result.unwrap();
        }
        
        let total_duration = start_time.elapsed();
        let total_operations = concurrent_operations * operations_per_task * 3; // create, read, update
        let ops_per_second = total_operations as f64 / total_duration.as_secs_f64();
        
        println!("Load test completed:");
        println!("  Total operations: {}", total_operations);
        println!("  Total duration: {:?}", total_duration);
        println!("  Operations per second: {:.2}", ops_per_second);
        
        // Assert minimum performance requirements
        assert!(ops_per_second &gt; 100.0, "Performance below threshold: {} ops/sec", ops_per_second);
    }
    
    #[tokio::test]
    #[ignore]
    async fn benchmark_filtering_performance() {
        let provider = create_test_provider().await;
        let tenant_id = "benchmark-tenant";
        
        // Create test data
        for i in 0..1000 {
            let user = ScimUser::builder()
                .username(&amp;format!("user-{}", i))
                .given_name("Benchmark")
                .family_name("User")
                .department(if i % 3 == 0 { "Engineering" } else { "Sales" })
                .active(i % 2 == 0)
                .build()
                .unwrap();
            
            provider.create_user(tenant_id, user).await.unwrap();
        }
        
        // Benchmark different page sizes for pagination performance
        let page_sizes = [10, 50, 100, 500, 1000];
        
        for page_size in page_sizes {
            let start = Instant::now();
            let iterations = 50;
            
            for _ in 0..iterations {
                let options = ListOptions::builder()
                    .count(Some(page_size))
                    .start_index(Some(1))
                    .build();
                
                let results = provider.list_users(tenant_id, &amp;options).await.unwrap();
                
                // Simulate in-memory filtering work
                let _active_users: Vec&lt;_&gt; = results.resources.into_iter()
                    .filter(|user| user.active())
                    .collect();
            }
            
            let duration = start.elapsed();
            let avg_duration = duration / iterations;
            
            println!("Page size {}: avg {}ms", page_size, avg_duration.as_millis());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive performance optimization guide covers all major aspects of making SCIM Server performant at scale, from database optimization to application-level caching and monitoring.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorials/mcp-integration.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../validation/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorials/mcp-integration.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../validation/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
