<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SCIM Server Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scim-server-guide"><a class="header" href="#scim-server-guide">SCIM Server Guide</a></h1>
<p>Welcome to the comprehensive guide for the SCIM Server library! This guide will help you understand and use the Rust components for building enterprise-ready identity provisioning systems.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Your application needs to support enterprise customers, but they require SCIM provisioning—the ability to automatically create, update, and delete user accounts from their identity systems (Okta, Azure Entra, Google Workspace, etc.).</p>
<p>Research shows that <strong>authentication requirements become critical blockers in 75-80% of enterprise deals</strong>, with companies losing an average of <strong>3-5 enterprise deals annually</strong> due to insufficient identity capabilities. Building SCIM compliance seems straightforward at first: it's just REST APIs with JSON. But enterprise identity management has many hidden complexities that create months of unexpected work:</p>
<ul>
<li><strong>Provider Fragmentation</strong>: Identity providers interpret SCIM differently—email handling, user deactivation, and custom attributes work differently across Okta, Azure, and Google</li>
<li><strong>Protocol Compliance</strong>: SCIM 2.0 has strict requirements with <strong>10 common implementation pitfalls</strong> that cause enterprise integration failures</li>
<li><strong>Hidden Development Costs</strong>: Industry data shows <strong>3-6 months and $3.5M+</strong> in development costs for homegrown SSO/SCIM solutions over 3 years</li>
<li><strong>Ongoing Maintenance</strong>: Security incidents, provider-specific bugs, and manual customer onboarding create continuous overhead</li>
<li><strong>Schema Complexity</strong>: Extensible schemas with custom attributes while maintaining interoperability across different enterprise environments</li>
</ul>
<p>Many developers underestimate this complexity and spend months debugging provider-specific edge cases, dealing with "more deviation than standard" implementations, and handling enterprise customers who discover integration issues in production.</p>
<h2 id="what-is-scim-server"><a class="header" href="#what-is-scim-server">What is SCIM Server?</a></h2>
<p>SCIM Server is a Rust library that provides all the essential components for building SCIM 2.0-compliant systems. Instead of implementing SCIM from scratch, you get proven building blocks that handle the complex parts while letting you focus on your application logic.</p>
<p>The library uses the SCIM 2.0 protocol as a framework to standardize identity data validation and processing. You compose the components you need—from simple single-tenant systems to complex multi-tenant platforms with custom schemas and AI integration.</p>
<h2 id="what-you-get"><a class="header" href="#what-you-get">What You Get</a></h2>
<h3 id="ready-to-use-components"><a class="header" href="#ready-to-use-components">Ready-to-Use Components</a></h3>
<ul>
<li><strong><code>StandardResourceProvider</code></strong>: Complete SCIM resource operations for typical use cases</li>
<li><strong><code>InMemoryStorage</code></strong>: Development and testing storage backend</li>
<li><strong>Schema Registry</strong>: Pre-loaded with RFC 7643 User and Group schemas</li>
<li><strong>ETag Versioning</strong>: Automatic concurrency control for production deployments</li>
</ul>
<h3 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h3>
<ul>
<li><strong><code>ResourceProvider</code> trait</strong>: Implement for custom business logic and data models</li>
<li><strong><code>StorageProvider</code> trait</strong>: Connect to any database or storage system</li>
<li><strong>Custom Value Objects</strong>: Type-safe handling of domain-specific attributes</li>
<li><strong>Multi-Tenant Context</strong>: Built-in tenant isolation and context management</li>
</ul>
<h3 id="enterprise-features"><a class="header" href="#enterprise-features">Enterprise Features</a></h3>
<ul>
<li><strong>Protocol Compliance</strong>: All the RFC 7643/7644 complexity handled correctly</li>
<li><strong>Schema Extensions</strong>: Add custom attributes while maintaining SCIM compatibility</li>
<li><strong>AI Integration</strong>: Model Context Protocol support for AI agent interactions</li>
<li><strong>Production Ready</strong>: Structured logging, error handling, and performance optimizations</li>
</ul>
<h2 id="time--cost-savings"><a class="header" href="#time--cost-savings">Time &amp; Cost Savings</a></h2>
<p>Instead of facing the typical <strong>3-6 month development timeline and $3.5M+ costs</strong> that industry data shows for homegrown solutions, focus on your application:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Building From Scratch</strong></th><th><strong>Using SCIM Server</strong></th></tr></thead><tbody>
<tr><td>❌ 3-6 months learning SCIM protocol complexities</td><td>✅ Start building immediately with working components</td></tr>
<tr><td>❌ $3.5M+ development and maintenance costs over 3 years</td><td>✅ Fraction of the cost with proven components</td></tr>
<tr><td>❌ Debugging provider-specific implementation differences</td><td>✅ Handle Okta, Azure, Google variations automatically</td></tr>
<tr><td>❌ Building multi-tenant isolation from scratch</td><td>✅ Multi-tenant context and isolation built-in</td></tr>
<tr><td>❌ Lost enterprise deals due to auth requirements</td><td>✅ Enterprise-ready identity provisioning components</td></tr>
</tbody></table>
</div>
<p><strong>Result</strong>: Avoid the <strong>75-80% of enterprise deals that stall on authentication</strong> by having production-ready SCIM components instead of months of custom development.</p>
<h2 id="who-should-use-this"><a class="header" href="#who-should-use-this">Who Should Use This?</a></h2>
<p>This library is designed for Rust developers who need to:</p>
<ul>
<li><strong>Add enterprise customer support</strong> to SaaS applications requiring SCIM provisioning</li>
<li><strong>Build identity management tools</strong> that integrate with multiple identity providers</li>
<li><strong>Create AI agents</strong> that need to manage user accounts and permissions</li>
<li><strong>Develop custom identity solutions</strong> with specific business requirements</li>
<li><strong>Integrate existing systems</strong> with enterprise identity infrastructure</li>
</ul>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to Use This Guide</a></h2>
<p>The guide is organized into progressive sections:</p>
<ol>
<li><strong>Getting Started</strong>: Quick setup and basic usage</li>
<li><strong>Core Concepts</strong>: Understanding the fundamental ideas</li>
<li><strong>Tutorials</strong>: Step-by-step guides for common scenarios</li>
<li><strong>How-To Guides</strong>: Solutions for specific problems</li>
<li><strong>Advanced Topics</strong>: Deep dives into complex scenarios</li>
<li><strong>Reference</strong>: Technical specifications and details</li>
</ol>
<h3 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h3>
<p><strong>New to SCIM?</strong> Start with <a href="./concepts/scim-protocol.html">SCIM Protocol Overview</a> to understand the standard.</p>
<p><strong>Ready to code?</strong> Jump to <a href="./getting-started/first-server.html">Your First SCIM Server</a> for hands-on experience.</p>
<p><strong>Building production systems?</strong> Read through <a href="./concepts/architecture.html">Core Concepts</a> and <a href="./advanced/production-deployment.html">Advanced Topics</a>.</p>
<p><strong>Solving specific problems?</strong> Use the <a href="./how-to/troubleshooting.html">How-To Guides</a> section.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>By the end of this guide, you'll understand how to:</p>
<ul>
<li>Compose SCIM Server components for your specific requirements</li>
<li>Implement the ResourceProvider trait for your application's data model</li>
<li>Create custom schema extensions and value objects</li>
<li>Build multi-tenant systems using the provided context components</li>
<li>Integrate SCIM components with web frameworks and AI tools</li>
<li>Deploy production systems using the concurrency and observability components</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>Examples</strong>: Check the <a href="https://github.com/pukeko37/scim-server/tree/main/examples">examples directory</a> for working code</li>
<li><strong>API Documentation</strong>: See <a href="https://docs.rs/scim-server">docs.rs</a> for detailed API reference</li>
<li><strong>Issues</strong>: Report bugs or ask questions on <a href="https://github.com/pukeko37/scim-server/issues">GitHub Issues</a></li>
</ul>
<p>Let's get started! 🚀</p>
<hr />
<h3 id="references"><a class="header" href="#references">References</a></h3>
<p><em>Enterprise authentication challenges and statistics sourced from:</em> <a href="https://guptadeepak.com/the-enterprise-ready-dilemma-navigating-authentication-challenges-in-b2b-saas/">Gupta, "Enterprise Authentication: The Hidden SaaS Growth Blocker"</a>, 2024; <a href="https://workos.com/blog/build-vs-buy-part-i-complexities-of-building-sso-and-scim-in-house">WorkOS "Build vs Buy" analysis</a>, 2024; <a href="https://workos.com/blog/build-vs-buy-part-ii-roi-comparison-between-homegrown-and-pre-built-solutions">WorkOS ROI comparison</a>, 2024.</p>
<p><em>SCIM implementation pitfalls from:</em> <a href="https://www.traxion.com/blog/the-10-most-common-pitfalls-for-scim-2-0-compliant-api-implementations">Traxion "10 Most Common Pitfalls for SCIM 2.0 Compliant API Implementations"</a> based on testing 40-50 SCIM implementations.</p>
<p><em>Provider-specific differences documented in:</em> <a href="https://workos.com/blog/scim-challenges">WorkOS "SCIM Challenges"</a>, 2024.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide will get you up and running with the SCIM server library in under 5 minutes.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust 1.75 or later</strong> - <a href="https://rustup.rs/">Install Rust</a></li>
</ul>
<p>To verify your installation:</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<h2 id="adding-the-dependency"><a class="header" href="#adding-the-dependency">Adding the Dependency</a></h2>
<p>Add to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.7"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
</code></pre>
<blockquote>
<p><strong>Note</strong>: The library is under active development. Pin to exact versions for stability. Breaking changes are signaled by minor version increments until v1.0.</p>
</blockquote>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Create a simple test to verify the installation works:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    ScimServer, providers::StandardResourceProvider, storage::InMemoryStorage,
    RequestContext
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let server = ScimServer::new(provider)?;
    let context = RequestContext::new("test".to_string());

    let user_data = json!({
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "john.doe",
        "active": true
    });

    let user = server.create_resource("User", user_data, &amp;context).await?;
    let retrieved = server.get_resource("User", user.get_id().unwrap(), &amp;context).await?;

    assert_eq!(retrieved.get_attribute("active").unwrap(), &amp;json!(true));

    Ok(())
}</code></pre></pre>
<p>Run with:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>If this runs without errors, your installation is working correctly!</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Once installation is complete, proceed to:</p>
<ul>
<li><a href="getting-started/./first-server.html">Your First SCIM Server</a> - Build a complete working implementation</li>
<li><a href="getting-started/../configuration/basic-config.html">Configuration Guide</a> - Learn about storage backends and advanced setup</li>
<li><a href="getting-started/../api/overview.html">API Reference</a> - Explore all available operations</li>
</ul>
<p>For production deployments, see the <a href="getting-started/../deployment/production.html">Production Setup Guide</a> for information about system requirements, databases, and scaling considerations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-scim-server"><a class="header" href="#your-first-scim-server">Your First SCIM Server</a></h1>
<p>Learn to build a working SCIM server in 10 minutes using this library.</p>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<h3 id="1-create-a-new-project"><a class="header" href="#1-create-a-new-project">1. Create a New Project</a></h3>
<pre><code class="language-bash">cargo new my-scim-server
cd my-scim-server
</code></pre>
<h3 id="2-add-dependencies"><a class="header" href="#2-add-dependencies">2. Add Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "0.3.7"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
</code></pre>
<h3 id="3-basic-server-15-lines"><a class="header" href="#3-basic-server-15-lines">3. Basic Server (15 lines)</a></h3>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create storage and provider - the foundation of your SCIM server
    let storage = InMemoryStorage::new();  // Simple storage for development
    let provider = StandardResourceProvider::new(storage);  // Main SCIM interface

    // Create a single-tenant request context - tracks this operation for logging
    let context = RequestContext::new("demo".to_string());
    let user_data = json!({
        "userName": "john.doe",
        "emails": [{"value": "john@example.com", "primary": true}],
        "active": true
    });

    let user = provider.create_resource("User", user_data, &amp;context).await?;
    println!("Created user: {}", user.get_username().unwrap());

    Ok(())
}</code></pre></pre>
<h3 id="4-run-it"><a class="header" href="#4-run-it">4. Run It</a></h3>
<pre><code class="language-bash">cargo run
# Output: Created user: john.doe
</code></pre>
<h2 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h2>
<h3 id="setup"><a class="header" href="#setup">Setup</a></h3>
<p>For the following examples, we'll use this provider and context setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::json;

// Create storage and provider - the foundation of your SCIM server
let storage = InMemoryStorage::new();  // Simple storage for development
let provider = StandardResourceProvider::new(storage);  // Main SCIM interface

// Single-tenant RequestContext tracks each operation for logging
let context = RequestContext::new("demo".to_string());
<span class="boring">}</span></code></pre></pre>
<p>All the following examples will use these <code>provider</code> and <code>context</code> variables.</p>
<h3 id="creating-resources"><a class="header" href="#creating-resources">Creating Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use JSON to define user attributes following SCIM 2.0 schema
let user_data = json!({
    "userName": "alice.smith",
    "name": {
        "givenName": "Alice",
        "familyName": "Smith"
    },
    "emails": [{"value": "alice@company.com", "primary": true}],
    "active": true
});

// Create the user - provider handles validation and storage
let user = provider.create_resource("User", user_data, &amp;context).await?;
let user_id = user.get_id().unwrap();  // Get the auto-generated unique ID
<span class="boring">}</span></code></pre></pre>
<h3 id="reading-resources"><a class="header" href="#reading-resources">Reading Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get user by ID - returns Option&lt;Resource&gt; (None if not found)
let retrieved_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;

if let Some(user) = retrieved_user {
    println!("Found: {}", user.get_username().unwrap());
}

// Search by specific attribute value - useful for username lookups
let found_user = provider
    .find_resource_by_attribute("User", "userName", &amp;json!("alice.smith"), &amp;context)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-resources"><a class="header" href="#updating-resources">Updating Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Updates require the full resource data, including the ID
let update_data = json!({
    "id": user_id,
    "userName": "alice.smith",
    "name": {
        "givenName": "Alice",
        "familyName": "Johnson"  // Changed surname
    },
    "emails": [{"value": "alice@company.com", "primary": true}],
    "active": false  // Deactivated
});

// Update replaces the entire resource with new data
let updated_user = provider
    .update_resource("User", &amp;user_id, update_data, &amp;context)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="listing-and-searching"><a class="header" href="#listing-and-searching">Listing and Searching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List all users - None means no pagination/filtering
let all_users = provider.list_resources("User", None, &amp;context).await?;
println!("Total users: {}", all_users.len());

// Efficiently check existence without retrieving full data
let exists = provider.resource_exists("User", &amp;user_id, &amp;context).await?;
println!("User exists: {}", exists);
<span class="boring">}</span></code></pre></pre>
<h3 id="validation-and-error-handling"><a class="header" href="#validation-and-error-handling">Validation and Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The provider automatically validates data against SCIM schemas
let invalid_user = json!({
    "userName": "",  // Empty username - violates SCIM requirements
    "emails": [{"value": "not-an-email"}],  // Invalid email format
});

// Always handle validation errors gracefully
match provider.create_resource("User", invalid_user, &amp;context).await {
    Ok(user) =&gt; println!("User created: {}", user.get_id().unwrap()),
    Err(e) =&gt; println!("Validation failed: {}", e),  // Detailed error message
}
<span class="boring">}</span></code></pre></pre>
<h3 id="deleting-resources"><a class="header" href="#deleting-resources">Deleting Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Delete a resource by ID
provider.delete_resource("User", &amp;user_id, &amp;context).await?;

// Verify deletion
let exists = provider.resource_exists("User", &amp;user_id, &amp;context).await?;
println!("User still exists: {}", exists); // Should be false
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-groups"><a class="header" href="#working-with-groups">Working with Groups</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Groups can contain users as members - useful for access control
// Create a group (assuming you have a user_id from previous examples)
let group_data = json!({
    "displayName": "Engineering Team",  // Required: human-readable name
    "members": [  // Optional: list of member references
        {
            "value": user_id,  // Reference to the user's ID
            "$ref": format!("https://example.com/v2/Users/{}", user_id),  // Full URI
            "type": "User"  // Type of the referenced resource
        }
    ]
});

// Using the context and user_id from previous examples
// Create group just like users - same provider interface
let group = provider.create_resource("Group", group_data, &amp;context).await?;
println!("Created group: {}", group.get_attribute("displayName").unwrap());
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenant-support"><a class="header" href="#multi-tenant-support">Multi-Tenant Support</a></h2>
<p>For multi-tenant scenarios, you create explicit tenant contexts instead of using the default single-tenant setup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Import TenantContext for multi-tenant operations
use scim_server::resource::TenantContext;

// Create the same provider as before
let storage = InMemoryStorage::new();
let provider = StandardResourceProvider::new(storage);

// Multi-tenant contexts - each gets isolated data space
let tenant_a = TenantContext::new("company-a".to_string(), "client-123".to_string());
let tenant_a_context = RequestContext::with_tenant("req-a".to_string(), tenant_a);

let tenant_b = TenantContext::new("company-b".to_string(), "client-456".to_string());
let tenant_b_context = RequestContext::with_tenant("req-b".to_string(), tenant_b);

// Same provider, different tenants - data is completely isolated
provider.create_resource("User", user_data.clone(), &amp;tenant_a_context).await?;
provider.create_resource("User", user_data, &amp;tenant_b_context).await?;

// Each tenant sees only their own data
let tenant_a_users = provider.list_resources("User", None, &amp;tenant_a_context).await?;
let tenant_b_users = provider.list_resources("User", None, &amp;tenant_b_context).await?;

println!("Company A users: {}", tenant_a_users.len());
println!("Company B users: {}", tenant_b_users.len());
<span class="boring">}</span></code></pre></pre>
<h2 id="provider-statistics"><a class="header" href="#provider-statistics">Provider Statistics</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Useful for monitoring and debugging your SCIM server
let stats = provider.get_stats().await;
println!("Total tenants: {}", stats.tenant_count);  // Number of active tenants
println!("Total resources: {}", stats.total_resources);  // Users + Groups + etc.
println!("Resource types: {:?}", stats.resource_types);  // ["User", "Group", ...]
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<ul>
<li><strong><a href="getting-started/../http/overview.html">HTTP Server Integration</a></strong> - Add REST endpoints with Axum or Actix</li>
<li><strong><a href="getting-started/../multi-tenant/basics.html">Multi-tenant Setup</a></strong> - Advanced tenant isolation and management</li>
<li><strong><a href="getting-started/../advanced/overview.html">Advanced Features</a></strong> - Groups, custom schemas, bulk operations</li>
<li><strong><a href="getting-started/../storage/overview.html">Storage Backends</a></strong> - PostgreSQL, SQLite, and custom storage</li>
</ul>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<p>See the <a href="getting-started/../../../../examples/">examples directory</a> for full working implementations:</p>
<ul>
<li><strong><a href="getting-started/../../../../examples/basic_usage.rs">basic_usage.rs</a></strong> - Complete CRUD operations</li>
<li><strong><a href="getting-started/../../../../examples/group_example.rs">group_example.rs</a></strong> - Group management with members</li>
<li><strong><a href="getting-started/../../../../examples/multi_tenant_example.rs">multi_tenant_example.rs</a></strong> - Tenant isolation patterns</li>
</ul>
<h2 id="running-examples"><a class="header" href="#running-examples">Running Examples</a></h2>
<pre><code class="language-bash"># Run any example to see it in action
cargo run --example basic_usage
cargo run --example group_example
</code></pre>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<ul>
<li><strong><code>StandardResourceProvider</code></strong> - Main interface for SCIM operations</li>
<li><strong><code>InMemoryStorage</code></strong> - Simple storage backend for development</li>
<li><strong><code>RequestContext</code></strong> - Request tracking and tenant isolation</li>
<li><strong>Resource Types</strong> - "User", "Group", or custom types</li>
<li><strong>JSON Data</strong> - All resource data uses <code>serde_json::Value</code></li>
</ul>
<p>You now have a working SCIM server! The examples above demonstrate all core functionality needed for most SCIM implementations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The SCIM Server follows a clean trait-based architecture with clear separation of concerns designed for maximum composability and extensibility.</p>
<h2 id="component-architecture"><a class="header" href="#component-architecture">Component Architecture</a></h2>
<p>The library is built around composable traits that you implement for your specific needs:</p>
<pre><code class="language-text">┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Client Layer   │    │   SCIM Server    │    │ Resource Layer  │
│                 │    │                  │    │                 │
│  • MCP AI       │───▶│  • Operations    │───▶│ ResourceProvider│
│  • Web Framework│    │  • Multi-tenant  │    │      trait      │
│  • Custom       │    │  • Type Safety   │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              │                          │
                              ▼                          ▼
                       ┌──────────────────┐    ┌─────────────────┐
                       │ Schema System    │    │ Storage Layer   │
                       │                  │    │                 │
                       │ • SchemaRegistry │    │ StorageProvider │
                       │ • Validation     │    │      trait      │
                       │ • Value Objects  │    │  • In-Memory    │
                       │ • Extensions     │    │  • Database     │
                       └──────────────────┘    │  • Custom       │
                                               └─────────────────┘
</code></pre>
<h2 id="layer-responsibilities"><a class="header" href="#layer-responsibilities">Layer Responsibilities</a></h2>
<p><strong>Client Layer</strong>: Your integration points - compose these components into web endpoints, AI tools, or custom applications.</p>
<p><strong>SCIM Server</strong>: Orchestration component that coordinates resource operations using your provider implementations.</p>
<p><strong>Resource Layer</strong>: <code>ResourceProvider</code> trait - implement this interface for your data model, or use the provided <code>StandardResourceProvider</code> for common scenarios.</p>
<p><strong>Schema System</strong>: Schema registry and validation components - extend with custom schemas and value objects.</p>
<p><strong>Storage Layer</strong>: <code>StorageProvider</code> trait - use the provided <code>InMemoryStorage</code> for development, or connect to any database or custom backend.</p>
<h2 id="core-traits"><a class="header" href="#core-traits">Core Traits</a></h2>
<h3 id="resourceprovider"><a class="header" href="#resourceprovider">ResourceProvider</a></h3>
<p>Your main integration point for SCIM resource operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ResourceProvider {
    type Error: std::error::Error + Send + Sync + 'static;

    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt;;

    async fn get_resource(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Option&lt;Resource&gt;, Self::Error&gt;;

    // ... other CRUD operations
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Implementation Options:</strong></p>
<ul>
<li>Use <code>StandardResourceProvider&lt;S&gt;</code> with any <code>StorageProvider</code> for typical use cases</li>
<li>Implement directly for custom business logic and data models</li>
<li>Wrap existing services or databases</li>
</ul>
<h3 id="storageprovider"><a class="header" href="#storageprovider">StorageProvider</a></h3>
<p>Pure data persistence abstraction:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageProvider: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;

    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt;;
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt;;
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt;;
    async fn list(&amp;self, prefix: StoragePrefix) -&gt; Result&lt;Vec&lt;Value&gt;, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Implementation Options:</strong></p>
<ul>
<li>Use <code>InMemoryStorage</code> for development and testing</li>
<li>Implement for your database (PostgreSQL, MongoDB, etc.)</li>
<li>Connect to cloud storage or external APIs</li>
</ul>
<h3 id="value-objects"><a class="header" href="#value-objects">Value Objects</a></h3>
<p>Type-safe SCIM attribute handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ValueObject: Debug + Send + Sync {
    fn attribute_type(&amp;self) -&gt; AttributeType;
    fn to_json(&amp;self) -&gt; ValidationResult&lt;Value&gt;;
    fn validate_against_schema(&amp;self, definition: &amp;AttributeDefinition) -&gt; ValidationResult&lt;()&gt;;
    // ...
}

pub trait SchemaConstructible: ValueObject + Sized {
    fn from_schema_and_value(
        definition: &amp;AttributeDefinition,
        value: &amp;Value,
    ) -&gt; ValidationResult&lt;Self&gt;;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Extension Points:</strong></p>
<ul>
<li>Create custom value objects for domain-specific attributes</li>
<li>Implement validation logic for business rules</li>
<li>Support for complex multi-valued attributes</li>
</ul>
<h2 id="multi-tenant-architecture"><a class="header" href="#multi-tenant-architecture">Multi-Tenant Architecture</a></h2>
<p>The library provides several components for multi-tenant systems:</p>
<h3 id="tenantresolver"><a class="header" href="#tenantresolver">TenantResolver</a></h3>
<p>Maps authentication credentials to tenant context:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait TenantResolver: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;

    async fn resolve_tenant(&amp;self, credential: &amp;str) -&gt; Result&lt;TenantContext, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="requestcontext"><a class="header" href="#requestcontext">RequestContext</a></h3>
<p>Carries tenant and request information through all operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RequestContext {
    pub request_id: String,
    tenant_context: Option&lt;TenantContext&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation"><a class="header" href="#tenant-isolation">Tenant Isolation</a></h3>
<ul>
<li>All <code>ResourceProvider</code> operations include <code>RequestContext</code></li>
<li>Storage keys automatically include tenant ID</li>
<li>Schema validation respects tenant-specific extensions</li>
</ul>
<h2 id="schema-system-architecture"><a class="header" href="#schema-system-architecture">Schema System Architecture</a></h2>
<h3 id="schemaregistry"><a class="header" href="#schemaregistry">SchemaRegistry</a></h3>
<p>Central registry for SCIM schemas:</p>
<ul>
<li>Loads and validates RFC 7643 core schemas</li>
<li>Supports custom schema extensions</li>
<li>Provides validation services for all operations</li>
</ul>
<h3 id="dynamic-value-objects"><a class="header" href="#dynamic-value-objects">Dynamic Value Objects</a></h3>
<ul>
<li>Runtime creation from schema definitions</li>
<li>Type-safe attribute handling</li>
<li>Extensible factory pattern for custom types</li>
</ul>
<h3 id="extension-model"><a class="header" href="#extension-model">Extension Model</a></h3>
<ul>
<li>Custom resource types beyond User/Group</li>
<li>Organization-specific attributes</li>
<li>Maintains SCIM compliance and interoperability</li>
</ul>
<h2 id="concurrency-control"><a class="header" href="#concurrency-control">Concurrency Control</a></h2>
<h3 id="etag-based-versioning"><a class="header" href="#etag-based-versioning">ETag-Based Versioning</a></h3>
<p>Built into the core architecture:</p>
<ul>
<li>Automatic version generation from resource content</li>
<li>Conditional operations (If-Match, If-None-Match)</li>
<li>Conflict detection and resolution</li>
<li>Production-ready optimistic locking</li>
</ul>
<h3 id="version-aware-operations"><a class="header" href="#version-aware-operations">Version-Aware Operations</a></h3>
<p>All resource operations support conditional execution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Conditional update with version check
let result = provider.conditional_update(
    "User", 
    &amp;user_id, 
    updated_data, 
    &amp;expected_version, 
    &amp;context
).await?;

match result {
    ConditionalResult::Success(resource) =&gt; // Update succeeded
    ConditionalResult::PreconditionFailed =&gt; // Version conflict
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="web-framework-integration"><a class="header" href="#web-framework-integration">Web Framework Integration</a></h3>
<p>Components work with any HTTP framework:</p>
<ol>
<li>Extract SCIM request details</li>
<li>Create <code>RequestContext</code> with tenant info</li>
<li>Call appropriate <code>ScimServer</code> operations</li>
<li>Format responses per SCIM specification</li>
</ol>
<h3 id="ai-agent-integration"><a class="header" href="#ai-agent-integration">AI Agent Integration</a></h3>
<p>Model Context Protocol (MCP) components:</p>
<ol>
<li>Expose SCIM operations as discoverable tools</li>
<li>Structured schemas for AI understanding</li>
<li>Error handling designed for AI decision making</li>
<li>Multi-tenant aware tool descriptions</li>
</ol>
<h3 id="custom-client-integration"><a class="header" href="#custom-client-integration">Custom Client Integration</a></h3>
<p>Direct component usage:</p>
<ol>
<li>Implement <code>ResourceProvider</code> for your data model</li>
<li>Choose appropriate <code>StorageProvider</code></li>
<li>Configure schema extensions as needed</li>
<li>Build custom API layer or integration logic</li>
</ol>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="async-first-design"><a class="header" href="#async-first-design">Async-First Design</a></h3>
<ul>
<li>All I/O operations are async</li>
<li>Non-blocking concurrent operations</li>
<li>Efficient resource utilization</li>
</ul>
<h3 id="minimal-allocations"><a class="header" href="#minimal-allocations">Minimal Allocations</a></h3>
<ul>
<li>Zero-copy JSON processing where possible</li>
<li>Efficient value object system</li>
<li>Smart caching in schema registry</li>
</ul>
<h3 id="scalability-features"><a class="header" href="#scalability-features">Scalability Features</a></h3>
<ul>
<li>Pluggable storage for horizontal scaling</li>
<li>Multi-tenant isolation for SaaS platforms</li>
<li>Connection pooling support through storage traits</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
