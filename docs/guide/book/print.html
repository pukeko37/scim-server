<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SCIM Server Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="scim-server-guide"><a class="header" href="#scim-server-guide">SCIM Server Guide</a></h1>
<p>Welcome to the comprehensive guide for the SCIM Server library! This guide will take you from initial setup to advanced usage patterns, helping you build robust identity provisioning systems with Rust.</p>
<h2 id="what-is-scim-server"><a class="header" href="#what-is-scim-server">What is SCIM Server?</a></h2>
<p>SCIM Server is a comprehensive Rust library that implements the SCIM 2.0 (System for Cross-domain Identity Management) protocol. It provides a type-safe, high-performance foundation for building identity provisioning and management systems.</p>
<h3 id="why-scim"><a class="header" href="#why-scim">Why SCIM?</a></h3>
<p>SCIM is the industry standard for automating user provisioning between identity providers and applications. Instead of building custom APIs for user management, SCIM provides:</p>
<ul>
<li><strong>Standardized Operations</strong>: Consistent CRUD operations across all systems</li>
<li><strong>Rich Filtering</strong>: Powerful query capabilities for finding users and groups</li>
<li><strong>Bulk Operations</strong>: Efficient handling of large-scale provisioning tasks</li>
<li><strong>Schema Validation</strong>: Automatic validation against well-defined schemas</li>
<li><strong>Interoperability</strong>: Works with existing identity providers and applications</li>
</ul>
<h3 id="why-this-library"><a class="header" href="#why-this-library">Why This Library?</a></h3>
<p>The SCIM Server library takes SCIM implementation to the next level with:</p>
<ul>
<li><strong>🛡️ Type Safety</strong>: Leverage Rust's type system to prevent runtime errors</li>
<li><strong>🏢 Multi-Tenancy</strong>: Built-in support for multiple organizations</li>
<li><strong>⚡ Performance</strong>: Async-first design with minimal overhead</li>
<li><strong>🔌 Flexibility</strong>: Framework-agnostic with pluggable storage</li>
<li><strong>🤖 AI Integration</strong>: Built-in Model Context Protocol support</li>
<li><strong>🔄 Concurrency Control</strong>: ETag-based optimistic locking</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<p>The SCIM Server follows a clean three-layer architecture:</p>
<pre><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   HTTP Layer    │    │   SCIM Server    │    │   Storage       │
│                 │    │                  │    │                 │
│  • Axum         │───▶│  • Validation    │───▶│  • In-Memory    │
│  • Warp         │    │  • Operations    │    │  • Database     │
│  • Actix        │    │  • Multi-tenant  │    │  • Custom       │
│  • Custom       │    │  • Type Safety   │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
</code></pre>
<p><strong>HTTP Layer</strong>: Your choice of web framework handles HTTP requests and responses.</p>
<p><strong>SCIM Server</strong>: The core library handles SCIM protocol logic, validation, multi-tenancy, and type safety.</p>
<p><strong>Storage</strong>: Pluggable storage providers handle data persistence, from simple in-memory stores to enterprise databases.</p>
<h2 id="value-proposition"><a class="header" href="#value-proposition">Value Proposition</a></h2>
<p>Instead of building provisioning logic into every application, the SCIM Server centralizes complexity:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Without SCIM Server</strong></th><th><strong>With SCIM Server</strong></th></tr></thead><tbody>
<tr><td>❌ Custom validation in each app</td><td>✅ Centralized validation engine</td></tr>
<tr><td>❌ Manual concurrency control</td><td>✅ Automatic ETag versioning</td></tr>
<tr><td>❌ Manual schema management</td><td>✅ Dynamic schema registry</td></tr>
<tr><td>❌ Ad-hoc API endpoints</td><td>✅ Standardized SCIM protocol</td></tr>
<tr><td>❌ Build multi-tenancy from scratch</td><td>✅ Built-in tenant isolation</td></tr>
</tbody></table>
</div>
<p><strong>Result</strong>: Your applications focus on business logic while SCIM Server handles all provisioning complexity.</p>
<h2 id="who-should-use-this-guide"><a class="header" href="#who-should-use-this-guide">Who Should Use This Guide?</a></h2>
<p>This guide is designed for:</p>
<ul>
<li><strong>Rust Developers</strong> building identity-aware applications</li>
<li><strong>System Architects</strong> designing multi-tenant SaaS platforms</li>
<li><strong>DevOps Engineers</strong> automating user provisioning workflows</li>
<li><strong>AI Engineers</strong> integrating identity management with AI tools</li>
<li><strong>Security Engineers</strong> implementing enterprise identity solutions</li>
</ul>
<h2 id="how-to-use-this-guide"><a class="header" href="#how-to-use-this-guide">How to Use This Guide</a></h2>
<p>The guide is organized into progressive sections:</p>
<ol>
<li><strong>Getting Started</strong>: Quick setup and basic usage</li>
<li><strong>Core Concepts</strong>: Understanding the fundamental ideas</li>
<li><strong>Tutorials</strong>: Step-by-step guides for common scenarios</li>
<li><strong>How-To Guides</strong>: Solutions for specific problems</li>
<li><strong>Advanced Topics</strong>: Deep dives into complex scenarios</li>
<li><strong>Reference</strong>: Technical specifications and details</li>
</ol>
<h3 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h3>
<p><strong>New to SCIM?</strong> Start with <a href="./concepts/scim-protocol.html">SCIM Protocol Overview</a> to understand the standard.</p>
<p><strong>Ready to code?</strong> Jump to <a href="./getting-started/first-server.html">Your First SCIM Server</a> for hands-on experience.</p>
<p><strong>Building production systems?</strong> Read through <a href="./concepts/architecture.html">Core Concepts</a> and <a href="./advanced/production-deployment.html">Advanced Topics</a>.</p>
<p><strong>Solving specific problems?</strong> Use the <a href="./how-to/troubleshooting.html">How-To Guides</a> section.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You'll Learn</a></h2>
<p>By the end of this guide, you'll be able to:</p>
<ul>
<li>Set up and configure SCIM Server for your use case</li>
<li>Implement multi-tenant identity provisioning systems</li>
<li>Handle complex scenarios like custom resources and authentication</li>
<li>Integrate with web frameworks and AI tools</li>
<li>Deploy production-ready SCIM services</li>
<li>Troubleshoot common issues and optimize performance</li>
</ul>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>Examples</strong>: Check the <a href="https://github.com/pukeko37/scim-server/tree/main/examples">examples directory</a> for working code</li>
<li><strong>API Documentation</strong>: See <a href="https://docs.rs/scim-server">docs.rs</a> for detailed API reference</li>
<li><strong>Issues</strong>: Report bugs or ask questions on <a href="https://github.com/pukeko37/scim-server/issues">GitHub Issues</a></li>
</ul>
<p>Let's get started! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers installing and setting up the SCIM Server library in your Rust project.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you begin, ensure you have:</p>
<ul>
<li><strong>Rust 1.75 or later</strong> - <a href="https://rustup.rs/">Install Rust</a></li>
<li><strong>Cargo</strong> - Comes with Rust installation</li>
<li>Basic familiarity with Rust and async programming</li>
</ul>
<p>You can verify your Rust installation:</p>
<pre><code class="language-bash">rustc --version
cargo --version
</code></pre>
<h2 id="adding-scim-server-to-your-project"><a class="header" href="#adding-scim-server-to-your-project">Adding SCIM Server to Your Project</a></h2>
<h3 id="option-1-using-cargo-recommended"><a class="header" href="#option-1-using-cargo-recommended">Option 1: Using Cargo (Recommended)</a></h3>
<p>Add SCIM Server to your <code>Cargo.toml</code> dependencies:</p>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
</code></pre>
<blockquote>
<p><strong>⚠️ Version Pinning</strong>: Use exact version pinning (<code>=0.3.2</code>) during active development to avoid breaking changes. See <a href="getting-started/../reference/versioning.html">Version Strategy</a> for details.</p>
</blockquote>
<h3 id="option-2-using-cargo-add-command"><a class="header" href="#option-2-using-cargo-add-command">Option 2: Using Cargo Add Command</a></h3>
<pre><code class="language-bash">cargo add scim-server@=0.3.2
cargo add tokio --features full
cargo add serde_json
</code></pre>
<h2 id="feature-flags"><a class="header" href="#feature-flags">Feature Flags</a></h2>
<p>SCIM Server provides several optional features to reduce compile time and binary size:</p>
<pre><code class="language-toml">[dependencies]
scim-server = { version = "=0.3.2", features = ["mcp", "auth", "logging"] }
</code></pre>
<p>Available features:</p>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Description</th><th>Default</th></tr></thead><tbody>
<tr><td><code>mcp</code></td><td>Model Context Protocol for AI integration</td><td>❌</td></tr>
<tr><td><code>auth</code></td><td>Compile-time authentication system</td><td>❌</td></tr>
<tr><td><code>logging</code></td><td>Enhanced logging capabilities</td><td>❌</td></tr>
<tr><td><code>serde</code></td><td>JSON serialization support</td><td>✅</td></tr>
<tr><td><code>async</code></td><td>Async runtime support</td><td>✅</td></tr>
</tbody></table>
</div>
<h2 id="development-dependencies"><a class="header" href="#development-dependencies">Development Dependencies</a></h2>
<p>For development and testing, you may want additional dependencies:</p>
<pre><code class="language-toml">[dev-dependencies]
tokio-test = "0.4"
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
</code></pre>
<h2 id="verification"><a class="header" href="#verification">Verification</a></h2>
<p>Create a simple test to verify your installation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::json;

#[tokio::test]
async fn test_installation() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::new("test".to_string());
    
    // Test creating a simple resource
    let user_data = json!({
        "userName": "test.user",
        "emails": [{"value": "test@example.com", "primary": true}]
    });
    
    let user = provider.create_resource("User", user_data, &amp;context).await.unwrap();
    
    // If this compiles and runs, installation is successful!
    println!("SCIM Server installed successfully!");
    println!("Created test user: {}", user.get_username().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<p>Run the test:</p>
<pre><code class="language-bash">cargo test test_installation
</code></pre>
<h2 id="ide-setup"><a class="header" href="#ide-setup">IDE Setup</a></h2>
<h3 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h3>
<p>For the best development experience with VS Code:</p>
<ol>
<li>Install the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">rust-analyzer extension</a></li>
<li>Install the <a href="https://marketplace.visualstudio.com/items?itemName=bungcip.better-toml">Better TOML extension</a></li>
</ol>
<h3 id="intellij-idea--clion"><a class="header" href="#intellij-idea--clion">IntelliJ IDEA / CLion</a></h3>
<p>Install the <a href="https://plugins.jetbrains.com/plugin/8182-rust">Rust plugin</a> for full Rust support.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you have SCIM Server installed, you're ready to:</p>
<ol>
<li><strong><a href="getting-started/./first-server.html">Create Your First Server</a></strong> - Build a basic SCIM server</li>
<li><strong><a href="getting-started/./basic-operations.html">Learn Basic Operations</a></strong> - Understand CRUD operations</li>
<li><strong><a href="getting-started/../../examples/">Explore Examples</a></strong> - See working code samples</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="common-installation-issues"><a class="header" href="#common-installation-issues">Common Installation Issues</a></h3>
<p><strong>Rust version too old</strong>:</p>
<pre><code class="language-bash">rustup update stable
</code></pre>
<p><strong>Compilation errors</strong>:</p>
<ul>
<li>Ensure you're using exact version pinning (<code>=0.3.2</code>)</li>
<li>Check that all required features are enabled</li>
<li>Verify tokio features include <code>"full"</code> or at minimum <code>"rt-multi-thread", "macros"</code></li>
</ul>
<p><strong>Performance issues during compilation</strong>:</p>
<ul>
<li>Consider disabling unused features</li>
<li>Use <code>cargo build --release</code> for optimized builds</li>
<li>Increase available RAM for compilation</li>
</ul>
<h3 id="getting-help-1"><a class="header" href="#getting-help-1">Getting Help</a></h3>
<p>If you encounter issues:</p>
<ol>
<li>Check the <a href="getting-started/../how-to/troubleshooting.html">Troubleshooting Guide</a></li>
<li>Search existing <a href="https://github.com/pukeko37/scim-server/issues">GitHub Issues</a></li>
<li>Create a new issue with your system details and error messages</li>
</ol>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="windows"><a class="header" href="#windows">Windows</a></h3>
<p>No special requirements. SCIM Server works on all Windows versions supported by Rust.</p>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>No special requirements. Works on both Intel and Apple Silicon Macs.</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<p>Works on all major Linux distributions. If using system packages instead of rustup:</p>
<p><strong>Ubuntu/Debian</strong>:</p>
<pre><code class="language-bash">sudo apt update
sudo apt install build-essential
</code></pre>
<p><strong>CentOS/RHEL/Fedora</strong>:</p>
<pre><code class="language-bash">sudo yum groupinstall "Development Tools"
# or for newer versions:
sudo dnf groupinstall "Development Tools"
</code></pre>
<p>You're now ready to build with SCIM Server! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-scim-server"><a class="header" href="#your-first-scim-server">Your First SCIM Server</a></h1>
<p>This tutorial walks you through creating your first SCIM server from scratch. By the end, you'll have a working SCIM server that can manage users and groups with full CRUD operations.</p>
<h2 id="what-well-build"><a class="header" href="#what-well-build">What We'll Build</a></h2>
<p>We'll create a simple SCIM server that:</p>
<ul>
<li>Manages users and groups</li>
<li>Supports basic CRUD operations</li>
<li>Uses in-memory storage for simplicity</li>
<li>Includes proper error handling</li>
<li>Demonstrates multi-tenant capabilities</li>
</ul>
<h2 id="step-1-project-setup"><a class="header" href="#step-1-project-setup">Step 1: Project Setup</a></h2>
<p>First, create a new Rust project:</p>
<pre><code class="language-bash">cargo new my-scim-server
cd my-scim-server
</code></pre>
<p>Add the required dependencies to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
scim-server = "0.3.2"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
anyhow = "1.0"
</code></pre>
<h2 id="step-2-basic-server-setup"><a class="header" href="#step-2-basic-server-setup">Step 2: Basic Server Setup</a></h2>
<p>Create your first SCIM server in <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    ScimServer,
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, ResourceProvider},
    resource_handlers::{create_user_resource_handler, create_group_resource_handler},
    schema::SchemaRegistry,
    resource::ScimOperation,
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("🚀 Starting SCIM Server...");
    
    // Create storage backend
    let storage = InMemoryStorage::new();
    
    // Create resource provider with storage
    let provider = StandardResourceProvider::new(storage);
    
    // Create SCIM server with provider
    let mut server = ScimServer::new(provider)?;
    
    // Register User resource type
    let user_schema = SchemaRegistry::new()?.get_core_user_schema()?;
    let user_handler = create_user_resource_handler(user_schema);
    server.register_resource_type(
        "User",
        user_handler,
        vec![
            ScimOperation::Create,
            ScimOperation::Read,
            ScimOperation::Update,
            ScimOperation::Delete,
            ScimOperation::List,
            ScimOperation::Search,
        ],
    )?;
    
    // Register Group resource type
    let group_schema = SchemaRegistry::new()?.get_core_group_schema()?;
    let group_handler = create_group_resource_handler(group_schema);
    server.register_resource_type(
        "Group",
        group_handler,
        vec![
            ScimOperation::Create,
            ScimOperation::Read,
            ScimOperation::Update,
            ScimOperation::Delete,
            ScimOperation::List,
            ScimOperation::Search,
        ],
    )?;
    
    println!("✅ SCIM Server initialized successfully!");
    
    // We'll add operations here in the next steps
    
    Ok(())
}</code></pre></pre>
<p>Run this to verify everything works:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>🚀 Starting SCIM Server...
✅ SCIM Server initialized successfully!
</code></pre>
<h2 id="step-3-creating-your-first-user"><a class="header" href="#step-3-creating-your-first-user">Step 3: Creating Your First User</a></h2>
<p>Now let's create a user. Add this after the server initialization:</p>
<pre><pre class="playground"><code class="language-rust">#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // ... previous setup code ...
    
    println!("✅ SCIM Server initialized successfully!");
    
    // Create a request context for our operations
    let context = RequestContext::with_generated_id();
    
    println!("\n📝 Creating a user...");
    
    // Define user data
    let user_data = json!({
        "userName": "alice@example.com",
        "name": {
            "formatted": "Alice Smith",
            "familyName": "Smith",
            "givenName": "Alice"
        },
        "displayName": "Alice Smith",
        "emails": [
            {
                "value": "alice@example.com",
                "type": "work",
                "primary": true
            }
        ],
        "phoneNumbers": [
            {
                "value": "+1-555-123-4567",
                "type": "work"
            }
        ],
        "active": true
    });
    
    // Create the user
    let user = server.create_resource("User", user_data, &amp;context).await?;
    
    println!("✅ Created user: {} (ID: {})", 
             user.get_username().unwrap_or("unknown"),
             user.get_id().unwrap_or("unknown"));
    
    Ok(())
}</code></pre></pre>
<p>Run this:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see:</p>
<pre><code>🚀 Starting SCIM Server...
✅ SCIM Server initialized successfully!

📝 Creating a user...
✅ Created user: alice@example.com (ID: user_abc123)
</code></pre>
<h2 id="step-4-reading-and-updating-users"><a class="header" href="#step-4-reading-and-updating-users">Step 4: Reading and Updating Users</a></h2>
<p>Let's add operations to read and update users:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ... after creating the user ...

println!("\n📖 Reading the user...");

// Get the user by ID
let user_id = user.get_id().unwrap();
let retrieved_user = server.get_resource("User", user_id, &amp;context).await?;

match retrieved_user {
    Some(user) =&gt; {
        println!("✅ Retrieved user: {} ({})", 
                 user.get_username().unwrap_or("unknown"),
                 user.get_display_name().unwrap_or("unknown"));
    }
    None =&gt; {
        println!("❌ User not found");
    }
}

println!("\n📝 Updating the user...");

// Update user data
let updated_data = json!({
    "id": user_id,
    "userName": "alice@example.com",
    "name": {
        "formatted": "Alice Johnson",
        "familyName": "Johnson",  // Changed last name
        "givenName": "Alice"
    },
    "displayName": "Alice Johnson",
    "emails": [
        {
            "value": "alice@example.com",
            "type": "work",
            "primary": true
        },
        {
            "value": "alice.johnson@personal.com",  // Added personal email
            "type": "home",
            "primary": false
        }
    ],
    "active": true
});

// Update the user
let updated_user = server.update_resource("User", user_id, updated_data, &amp;context).await?;

println!("✅ Updated user: {} ({})", 
         updated_user.get_username().unwrap_or("unknown"),
         updated_user.get_display_name().unwrap_or("unknown"));
<span class="boring">}</span></code></pre></pre>
<h2 id="step-5-working-with-groups"><a class="header" href="#step-5-working-with-groups">Step 5: Working with Groups</a></h2>
<p>Let's create a group and manage membership:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ... after updating the user ...

println!("\n👥 Creating a group...");

let group_data = json!({
    "displayName": "Engineering Team",
    "members": [
        {
            "value": user_id,
            "display": "Alice Johnson",
            "type": "User"
        }
    ]
});

// Create the group
let group = server.create_resource("Group", group_data, &amp;context).await?;

println!("✅ Created group: {} (ID: {})", 
         group.get_display_name().unwrap_or("unknown"),
         group.get_id().unwrap_or("unknown"));
<span class="boring">}</span></code></pre></pre>
<h2 id="step-6-listing-resources"><a class="header" href="#step-6-listing-resources">Step 6: Listing Resources</a></h2>
<p>Add functionality to list users and groups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ... after creating the group ...

println!("\n📋 Listing all users...");

// List all users
let users = server.list_resources("User", None, &amp;context).await?;
println!("✅ Found {} users:", users.len());
for user in &amp;users {
    println!("  - {} ({})", 
             user.get_username().unwrap_or("unknown"),
             user.get_display_name().unwrap_or("unknown"));
}

println!("\n📋 Listing all groups...");

// List all groups
let groups = server.list_resources("Group", None, &amp;context).await?;
println!("✅ Found {} groups:", groups.len());
for group in &amp;groups {
    println!("  - {} (ID: {})", 
             group.get_display_name().unwrap_or("unknown"),
             group.get_id().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-7-search-operations"><a class="header" href="#step-7-search-operations">Step 7: Search Operations</a></h2>
<p>Add search functionality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ... after listing resources ...

println!("\n🔍 Searching for users...");

// Search for user by username
let found_user = server.find_resource_by_attribute(
    "User",
    "userName",
    &amp;json!("alice@example.com"),
    &amp;context,
).await?;

match found_user {
    Some(user) =&gt; {
        println!("✅ Found user by username: {} ({})", 
                 user.get_username().unwrap_or("unknown"),
                 user.get_display_name().unwrap_or("unknown"));
    }
    None =&gt; {
        println!("❌ User not found");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-8-multi-tenant-operations"><a class="header" href="#step-8-multi-tenant-operations">Step 8: Multi-Tenant Operations</a></h2>
<p>Finally, let's demonstrate multi-tenant capabilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::TenantContext;

// ... after search operations ...

println!("\n🏢 Multi-tenant operations...");

// Create tenant-specific context
let tenant_context = TenantContext::new(
    "company-123".to_string(),
    "app-456".to_string(),
);
let tenant_request_context = RequestContext::with_tenant_generated_id(tenant_context);

// Create user in specific tenant
let tenant_user_data = json!({
    "userName": "bob@company123.com",
    "name": {
        "formatted": "Bob Wilson",
        "familyName": "Wilson",
        "givenName": "Bob"
    },
    "displayName": "Bob Wilson",
    "active": true
});

let tenant_user = server.create_resource("User", tenant_user_data, &amp;tenant_request_context).await?;

println!("✅ Created user in tenant: {} (ID: {})", 
         tenant_user.get_username().unwrap_or("unknown"),
         tenant_user.get_id().unwrap_or("unknown"));

// Show tenant isolation
let default_users = server.list_resources("User", None, &amp;context).await?;
let tenant_users = server.list_resources("User", None, &amp;tenant_request_context).await?;

println!("📊 Default tenant has {} users", default_users.len());
println!("📊 Company-123 tenant has {} users", tenant_users.len());
println!("✅ Tenant isolation working correctly!");
<span class="boring">}</span></code></pre></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here's the complete working example:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    ScimServer,
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, TenantContext, ResourceProvider},
    resource_handlers::{create_user_resource_handler, create_group_resource_handler},
    schema::SchemaRegistry,
    resource::ScimOperation,
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    println!("🚀 Starting SCIM Server...");
    
    // Create storage backend
    let storage = InMemoryStorage::new();
    
    // Create resource provider with storage
    let provider = StandardResourceProvider::new(storage);
    
    // Create SCIM server with provider
    let mut server = ScimServer::new(provider)?;
    
    // Register User resource type
    let user_schema = SchemaRegistry::new()?.get_core_user_schema()?;
    let user_handler = create_user_resource_handler(user_schema);
    server.register_resource_type(
        "User",
        user_handler,
        vec![
            ScimOperation::Create,
            ScimOperation::Read,
            ScimOperation::Update,
            ScimOperation::Delete,
            ScimOperation::List,
            ScimOperation::Search,
        ],
    )?;
    
    // Register Group resource type
    let group_schema = SchemaRegistry::new()?.get_core_group_schema()?;
    let group_handler = create_group_resource_handler(group_schema);
    server.register_resource_type(
        "Group",
        group_handler,
        vec![
            ScimOperation::Create,
            ScimOperation::Read,
            ScimOperation::Update,
            ScimOperation::Delete,
            ScimOperation::List,
            ScimOperation::Search,
        ],
    )?;
    
    println!("✅ SCIM Server initialized successfully!");
    
    // Create request context
    let context = RequestContext::with_generated_id();
    
    // Create a user
    let user_data = json!({
        "userName": "alice@example.com",
        "name": {
            "formatted": "Alice Smith",
            "familyName": "Smith",
            "givenName": "Alice"
        },
        "displayName": "Alice Smith",
        "emails": [
            {
                "value": "alice@example.com",
                "type": "work",
                "primary": true
            }
        ],
        "active": true
    });
    
    let user = server.create_resource("User", user_data, &amp;context).await?;
    let user_id = user.get_id().unwrap();
    
    println!("✅ Created user: {} (ID: {})", 
             user.get_username().unwrap_or("unknown"), user_id);
    
    // Create a group
    let group_data = json!({
        "displayName": "Engineering Team",
        "members": [
            {
                "value": user_id,
                "display": "Alice Smith",
                "type": "User"
            }
        ]
    });
    
    let group = server.create_resource("Group", group_data, &amp;context).await?;
    
    println!("✅ Created group: {} (ID: {})", 
             group.get_display_name().unwrap_or("unknown"),
             group.get_id().unwrap_or("unknown"));
    
    // List resources
    let users = server.list_resources("User", None, &amp;context).await?;
    let groups = server.list_resources("Group", None, &amp;context).await?;
    
    println!("📊 Total: {} users, {} groups", users.len(), groups.len());
    
    println!("🎉 SCIM Server example completed successfully!");
    
    Ok(())
}</code></pre></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you have a working SCIM server, you can:</p>
<ol>
<li><strong><a href="getting-started/../tutorials/authentication-setup.html">Add Authentication</a></strong> - Secure your SCIM endpoints</li>
<li><strong><a href="getting-started/../tutorials/custom-resources.html">Implement Custom Resources</a></strong> - Extend beyond Users and Groups</li>
<li><strong><a href="getting-started/../advanced/production-deployment.html">Deploy for Production</a></strong> - Scale your SCIM server</li>
<li><strong><a href="getting-started/../providers/basic.html">Add Database Storage</a></strong> - Replace in-memory storage with persistence</li>
<li><strong><a href="getting-started/../tutorials/multi-tenant-deployment.html">Set up Multi-Tenancy</a></strong> - Support multiple customers</li>
</ol>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h3>
<p><strong>Compilation Errors</strong></p>
<ul>
<li>Make sure you're using the correct version: <code>scim-server = "0.3.2"</code></li>
<li>Ensure all required features are enabled</li>
</ul>
<p><strong>Runtime Errors</strong></p>
<ul>
<li>Check that all resource types are registered before use</li>
<li>Verify request contexts are properly created</li>
</ul>
<p><strong>Resource Not Found</strong></p>
<ul>
<li>Ensure you're using the correct tenant context</li>
<li>Check that the resource was created successfully</li>
</ul>
<p>For more help, see the <a href="getting-started/../how-to/troubleshooting.html">Troubleshooting Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-operations"><a class="header" href="#basic-operations">Basic Operations</a></h1>
<p>This guide covers the fundamental SCIM operations you'll use most frequently. After reading this, you'll understand how to perform all basic CRUD operations and work with SCIM resources effectively.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>SCIM (System for Cross-domain Identity Management) defines standard operations for managing identity resources. SCIM Server implements all core operations:</p>
<ul>
<li><strong>Create</strong> - Add new resources</li>
<li><strong>Read</strong> - Retrieve existing resources</li>
<li><strong>Update</strong> - Modify existing resources</li>
<li><strong>Delete</strong> - Remove resources</li>
<li><strong>List</strong> - Query multiple resources with filtering and pagination</li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting, ensure you have:</p>
<ul>
<li>SCIM Server installed and configured</li>
<li>Basic understanding of JSON structure</li>
<li>Familiarity with async/await in Rust</li>
</ul>
<h2 id="basic-setup"><a class="header" href="#basic-setup">Basic Setup</a></h2>
<p>All examples assume this basic setup:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::new("my-request".to_string());
    
    // Operations go here...
    
    Ok(())
}</code></pre></pre>
<h2 id="user-operations"><a class="header" href="#user-operations">User Operations</a></h2>
<h3 id="creating-users"><a class="header" href="#creating-users">Creating Users</a></h3>
<p>The most basic operation is creating a user:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Minimal user creation
let user_data = json!({
    "userName": "alice@example.com"
});

let user = provider.create_resource("User", user_data, &amp;context).await?;
println!("Created user: {} with ID: {}", 
         user.get_username().unwrap_or("unknown"),
         user.get_id().unwrap_or("unknown"));
<span class="boring">}</span></code></pre></pre>
<p><strong>Complete user with all common fields:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let full_user_data = json!({
    "userName": "alice@example.com",
    "name": {
        "givenName": "Alice",
        "familyName": "Smith",
        "middleName": "M",
        "honorificPrefix": "Ms.",
        "honorificSuffix": "PhD"
    },
    "displayName": "Alice Smith",
    "nickName": "Ally",
    "emails": [
        {
            "value": "alice@example.com",
            "type": "work",
            "primary": true
        },
        {
            "value": "alice.personal@gmail.com",
            "type": "home",
            "primary": false
        }
    ],
    "phoneNumbers": [
        {
            "value": "+1-555-123-4567",
            "type": "work",
            "primary": true
        }
    ],
    "addresses": [
        {
            "type": "work",
            "streetAddress": "123 Business St",
            "locality": "Springfield",
            "region": "IL",
            "postalCode": "62701",
            "country": "US",
            "primary": true
        }
    ],
    "active": true,
    "title": "Senior Developer",
    "userType": "Employee",
    "preferredLanguage": "en-US",
    "locale": "en-US",
    "timezone": "America/Chicago"
});

let full_user = provider.create_resource("User", full_user_data, &amp;context).await?;

// Access user data using typed methods
if let Some(name) = full_user.get_name() {
    println!("Created user: {} {}", 
             name.given_name.as_ref().unwrap_or(&amp;"".to_string()),
             name.family_name.as_ref().unwrap_or(&amp;"".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="reading-users"><a class="header" href="#reading-users">Reading Users</a></h3>
<p><strong>Get a specific user by ID:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
println!("User: {}", user.get_username().unwrap_or("unknown"));
println!("Active: {}", user.get_active().unwrap_or(false));
if let Some(meta) = user.get_meta() {
    println!("Created: {}", meta.created);
    println!("Version: {}", meta.version.as_ref().unwrap_or(&amp;"unknown".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Check if user exists:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match provider.get_resource("User", &amp;user_id, &amp;context).await {
    Ok(user) =&gt; println!("User exists: {}", user.get_username().unwrap_or("unknown")),
    Err(e) if e.to_string().contains("not found") =&gt; println!("User not found"),
    Err(e) =&gt; println!("Error: {}", e),
}

// Or use the dedicated exists method
let exists = provider.resource_exists("User", &amp;user_id, &amp;context).await?;
println!("User exists: {}", exists);
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-users"><a class="header" href="#updating-users">Updating Users</a></h3>
<p><strong>Replace entire user (PUT semantics):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let updated_data = json!({
    "userName": "alice@example.com",
    "name": {
        "givenName": "Alice",
        "familyName": "Johnson" // Changed last name
    },
    "active": false // Deactivated user
});

let updated_user = provider.update_resource("User", &amp;user_id, updated_data, &amp;context).await?;
println!("Updated user: {}", updated_user.get_username().unwrap_or("unknown"));
<span class="boring">}</span></code></pre></pre>
<p><strong>Partial update:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current user first
let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;

// Create updated data with changes
let mut updated_data = current_user.data.clone();
updated_data["active"] = json!(false);
updated_data["title"] = json!("Lead Developer");

let patched_user = provider.update_resource("User", &amp;user_id, updated_data, &amp;context).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Working with ETags for concurrency control:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current user to check ETag
let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
if let Some(meta) = current_user.get_meta() {
    println!("Current ETag: {}", meta.version.as_ref().unwrap_or(&amp;"none".to_string()));
}

// Update with the current version
let mut update_data = current_user.data.clone();
update_data["active"] = json!(false);

let updated_user = provider.update_resource("User", &amp;user_id, update_data, &amp;context).await?;

// Check new ETag
if let Some(meta) = updated_user.get_meta() {
    println!("New ETag: {}", meta.version.as_ref().unwrap_or(&amp;"none".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="deleting-users"><a class="header" href="#deleting-users">Deleting Users</a></h3>
<p><strong>Simple deletion:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>provider.delete_resource("User", &amp;user_id, &amp;context).await?;
println!("User deleted successfully");
<span class="boring">}</span></code></pre></pre>
<p><strong>Verify deletion:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if user still exists
let exists = provider.resource_exists("User", &amp;user_id, &amp;context).await?;
println!("User exists after deletion: {}", exists);
<span class="boring">}</span></code></pre></pre>
<p><strong>Safe deletion with existence check:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if user exists before deleting
if provider.resource_exists("User", &amp;user_id, &amp;context).await? {
    provider.delete_resource("User", &amp;user_id, &amp;context).await?;
    println!("User deleted successfully");
} else {
    println!("User does not exist");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="group-operations"><a class="header" href="#group-operations">Group Operations</a></h2>
<h3 id="creating-groups"><a class="header" href="#creating-groups">Creating Groups</a></h3>
<p><strong>Basic group:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let group_data = json!({
    "displayName": "Developers"
});

let group = provider.create_resource("Group", group_data, &amp;context).await?;
println!("Created group: {}", group.get_display_name().unwrap_or("unknown"));
<span class="boring">}</span></code></pre></pre>
<p><strong>Group with members:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming you have user IDs from previous operations
let group_with_members = json!({
    "displayName": "Engineering Team",
    "members": [
        {
            "value": user1_id,
            "display": "Alice Smith"
        },
        {
            "value": user2_id,
            "display": "Bob Johnson"
        }
    ]
});

let group = provider.create_resource("Group", group_with_members, &amp;context).await?;
println!("Created group with {} members", 
         group.get_members().map(|m| m.len()).unwrap_or(0));
<span class="boring">}</span></code></pre></pre>
<h3 id="managing-group-membership"><a class="header" href="#managing-group-membership">Managing Group Membership</a></h3>
<p><strong>Add user to group:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current group
let mut group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;

// Add member to the group data
let mut group_data = group.data.clone();
let mut members = group_data.get("members").unwrap_or(&amp;json!([])).as_array().unwrap().clone();
members.push(json!({
    "value": user_id,
    "display": "User Display Name"
}));
group_data["members"] = json!(members);

// Update the group
let updated_group = provider.update_resource("Group", &amp;group_id, group_data, &amp;context).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Remove user from group:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get current group
let mut group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;

// Remove member from the group data
let mut group_data = group.data.clone();
if let Some(members) = group_data.get_mut("members") {
    if let Some(members_array) = members.as_array_mut() {
        members_array.retain(|member| {
            member.get("value").and_then(|v| v.as_str()) != Some(&amp;user_id)
        });
        group_data["members"] = json!(members_array);
    }
}

// Update the group
let updated_group = provider.update_resource("Group", &amp;group_id, group_data, &amp;context).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Get group members:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;
if let Some(members) = group.get_members() {
    println!("Group has {} members:", members.len());
    for member in members {
        println!("  - {} ({})", 
                 member.display.as_ref().unwrap_or(&amp;"unknown".to_string()), 
                 member.value);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="listing-and-querying"><a class="header" href="#listing-and-querying">Listing and Querying</a></h2>
<h3 id="basic-listing"><a class="header" href="#basic-listing">Basic Listing</a></h3>
<p><strong>List all users:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = provider.list_resources("User", None, &amp;context).await?;
println!("Found {} users", users.len());

for user in users {
    println!("  - {} ({})", 
             user.get_username().unwrap_or("unknown"),
             user.get_id().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>List all groups:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let groups = provider.list_resources("Group", None, &amp;context).await?;
println!("Found {} groups", groups.len());

for group in groups {
    println!("  - {} ({})",
             group.get_display_name().unwrap_or("unknown"),
             group.get_id().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="pagination"><a class="header" href="#pagination">Pagination</a></h3>
<p><strong>Using provider's built-in pagination:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The StandardResourceProvider handles pagination internally
// For large datasets, you can implement pagination by querying in chunks

let all_users = provider.list_resources("User", None, &amp;context).await?;
println!("Total users: {}", all_users.len());

// For manual pagination, you can filter results
let first_10_users: Vec&lt;_&gt; = all_users.into_iter().take(10).collect();
println!("First 10 users:");
for user in first_10_users {
    println!("  - {}", user.get_username().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Working with large datasets:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For very large datasets, consider implementing pagination at the storage level
// This example shows conceptual pagination handling

async fn get_users_page(
    provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
    context: &amp;RequestContext,
    page: usize,
    page_size: usize
) -&gt; Result&lt;Vec&lt;ScimResource&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let all_users = provider.list_resources("User", None, context).await?;
    let start = page * page_size;
    let end = std::cmp::min(start + page_size, all_users.len());
    
    if start &gt;= all_users.len() {
        return Ok(Vec::new());
    }
    
    Ok(all_users[start..end].to_vec())
}

// Example usage:
let page_0 = get_users_page(&amp;provider, &amp;context, 0, 10).await?;
let page_1 = get_users_page(&amp;provider, &amp;context, 1, 10).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="filtering"><a class="header" href="#filtering">Filtering</a></h3>
<p>The StandardResourceProvider supports attribute-based filtering:</p>
<p><strong>Basic attribute filtering:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find user by username
let user = provider.find_resource_by_attribute(
    "User",
    "userName", 
    &amp;json!("alice@example.com"),
    &amp;context
).await?;

if let Some(user) = user {
    println!("Found user: {}", user.get_username().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Find by email:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Find user by email address
let user_by_email = provider.find_resource_by_attribute(
    "User",
    "emails.value",
    &amp;json!("alice@example.com"),
    &amp;context
).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Client-side filtering for complex queries:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Get all users and filter on the client side
let all_users = provider.list_resources("User", None, &amp;context).await?;

// Filter active users
let active_users: Vec&lt;_&gt; = all_users.into_iter()
    .filter(|user| user.get_active().unwrap_or(false))
    .collect();

println!("Found {} active users", active_users.len());
<span class="boring">}</span></code></pre></pre>
<p><strong>Filter by email domain:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let all_users = provider.list_resources("User", None, &amp;context).await?;

let company_users: Vec&lt;_&gt; = all_users.into_iter()
    .filter(|user| {
        if let Some(emails) = user.get_emails() {
            emails.iter().any(|email| email.value.contains("@company.com"))
        } else {
            false
        }
    })
    .collect();

println!("Found {} company users", company_users.len());
<span class="boring">}</span></code></pre></pre>
<h3 id="sorting"><a class="header" href="#sorting">Sorting</a></h3>
<p><strong>Client-side sorting:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let all_users = provider.list_resources("User", None, &amp;context).await?;

// Sort by username
let mut sorted_users = all_users;
sorted_users.sort_by(|a, b| {
    let a_name = a.get_username().unwrap_or("");
    let b_name = b.get_username().unwrap_or("");
    a_name.cmp(b_name)
});

println!("Users sorted by username:");
for user in sorted_users.iter().take(5) {
    println!("  - {}", user.get_username().unwrap_or("unknown"));
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Sort by creation date:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let all_users = provider.list_resources("User", None, &amp;context).await?;

// Sort by creation date (newest first)
let mut users_by_date = all_users;
users_by_date.sort_by(|a, b| {
    let a_created = a.get_meta().and_then(|m| m.created.as_ref());
    let b_created = b.get_meta().and_then(|m| m.created.as_ref());
    b_created.cmp(&amp;a_created) // Reverse for newest first
});
<span class="boring">}</span></code></pre></pre>
<h2 id="bulk-operations"><a class="header" href="#bulk-operations">Bulk Operations</a></h2>
<p>The StandardResourceProvider processes operations individually. For bulk efficiency, use async iteration:</p>
<p><strong>Create multiple users:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bulk_users = vec![
    json!({
        "userName": "user1@example.com",
        "active": true
    }),
    json!({
        "userName": "user2@example.com", 
        "active": true
    }),
    json!({
        "userName": "user3@example.com",
        "active": true
    })
];

// Create users concurrently
let mut created_users = Vec::new();
for user_data in bulk_users {
    match provider.create_resource("User", user_data, &amp;context).await {
        Ok(user) =&gt; {
            println!("Created user: {}", user.get_username().unwrap_or("unknown"));
            created_users.push(user);
        },
        Err(e) =&gt; {
            println!("Failed to create user: {}", e);
        }
    }
}

println!("Successfully created {} users", created_users.len());
<span class="boring">}</span></code></pre></pre>
<p><strong>Bulk update multiple users:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user_ids = vec!["user1", "user2", "user3"];

for user_id in user_ids {
    // Get current user
    if let Ok(mut user) = provider.get_resource("User", user_id, &amp;context).await {
        // Update the user data
        let mut user_data = user.data.clone();
        user_data["active"] = json!(false);
        
        match provider.update_resource("User", user_id, user_data, &amp;context).await {
            Ok(_) =&gt; println!("Updated user: {}", user_id),
            Err(e) =&gt; println!("Failed to update user {}: {}", user_id, e),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-patterns"><a class="header" href="#error-handling-patterns">Error Handling Patterns</a></h2>
<h3 id="comprehensive-error-handling"><a class="header" href="#comprehensive-error-handling">Comprehensive Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn safe_user_operation(
    provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
    context: &amp;RequestContext,
    user_id: &amp;str,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    match provider.get_resource("User", user_id, context).await {
        Ok(user) =&gt; {
            println!("Found user: {}", user.get_username().unwrap_or("unknown"));
            Ok(())
        },
        Err(e) if e.to_string().contains("not found") =&gt; {
            println!("User {} not found", user_id);
            Err("User not found".into())
        },
        Err(e) if e.to_string().contains("validation") =&gt; {
            println!("Validation failed: {}", e);
            Err("Invalid data".into())
        },
        Err(e) if e.to_string().contains("conflict") =&gt; {
            println!("Conflict detected for resource: {}", user_id);
            Err("Resource conflict".into())
        },
        Err(e) if e.to_string().contains("storage") =&gt; {
            println!("Storage error: {}", e);
            Err("Storage issue".into())
        },
        Err(e) =&gt; {
            println!("Unexpected error: {}", e);
            Err(e.into())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="retry-logic-for-conflicts"><a class="header" href="#retry-logic-for-conflicts">Retry Logic for Conflicts</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::time::{sleep, Duration};

async fn retry_update_user(
    provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
    context: &amp;RequestContext,
    user_id: &amp;str,
    update_data: serde_json::Value,
    max_retries: u32,
) -&gt; Result&lt;ScimResource, Box&lt;dyn std::error::Error&gt;&gt; {
    for attempt in 0..max_retries {
        // Get current user and version
        let current_user = provider.get_resource("User", user_id, context).await?;
        let current_version = current_user.get_meta()
            .and_then(|m| m.version.as_ref())
            .cloned();
        
        // Attempt update
        match provider.update_resource("User", user_id, update_data.clone(), context).await {
            Ok(updated_user) =&gt; {
                println!("Successfully updated user after {} attempt(s)", attempt + 1);
                return Ok(updated_user);
            },
            Err(e) if e.to_string().contains("conflict") =&gt; {
                if attempt &lt; max_retries - 1 {
                    // Exponential backoff
                    let delay = Duration::from_millis(100 * 2_u64.pow(attempt));
                    println!("Conflict detected, retrying in {:?}...", delay);
                    sleep(delay).await;
                    continue;
                } else {
                    return Err(format!("Max retries ({}) exceeded due to conflicts", max_retries).into());
                }
            },
            Err(e) =&gt; return Err(e.into()),
        }
    }
    
    unreachable!()
}

// Example usage:
let update_data = json!({ "active": false });
match retry_update_user(&amp;provider, &amp;context, "user123", update_data, 3).await {
    Ok(user) =&gt; println!("Updated user successfully"),
    Err(e) =&gt; println!("Failed to update user: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-always-use-request-context"><a class="header" href="#1-always-use-request-context">1. Always Use Request Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Always provide request context
let context = RequestContext::new("operation-123".to_string());
let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;

// The request context provides operation tracking and audit trails
<span class="boring">}</span></code></pre></pre>
<h3 id="2-handle-versions-for-updates"><a class="header" href="#2-handle-versions-for-updates">2. Handle Versions for Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Check versions for safe updates
let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
if let Some(meta) = current_user.get_meta() {
    println!("Current version: {}", meta.version.as_ref().unwrap_or(&amp;"none".to_string()));
}

// Update with current data
let mut update_data = current_user.data.clone();
update_data["active"] = json!(false);
let result = provider.update_resource("User", &amp;user_id, update_data, &amp;context).await?;

// Check new version
if let Some(meta) = result.get_meta() {
    println!("New version: {}", meta.version.as_ref().unwrap_or(&amp;"none".to_string()));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-use-appropriate-operations"><a class="header" href="#3-use-appropriate-operations">3. Use Appropriate Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For creating new resources
let user = provider.create_resource("User", user_data, &amp;context).await?;

// For updating existing resources
let updated_user = provider.update_resource("User", &amp;user_id, updated_data, &amp;context).await?;

// For retrieving resources
let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;

// For deleting resources
provider.delete_resource("User", &amp;user_id, &amp;context).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="4-validate-data-before-operations"><a class="header" href="#4-validate-data-before-operations">4. Validate Data Before Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn validate_email(email: &amp;str) -&gt; bool {
    email.contains('@') &amp;&amp; email.contains('.')
}

async fn create_user_safely(
    provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
    context: &amp;RequestContext,
    user_data: serde_json::Value,
) -&gt; Result&lt;ScimResource, Box&lt;dyn std::error::Error&gt;&gt; {
    // Validate email if present
    if let Some(username) = user_data.get("userName").and_then(|v| v.as_str()) {
        if !validate_email(username) {
            return Err("Invalid email format".into());
        }
    }
    
    // Validate required fields
    if user_data.get("userName").is_none() {
        return Err("userName is required".into());
    }
    
    // Create user if validation passes
    provider.create_resource("User", user_data, context).await
        .map_err(|e| e.into())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="5-use-pagination-for-large-results"><a class="header" href="#5-use-pagination-for-large-results">5. Use Pagination for Large Results</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn process_all_users(
    provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
    context: &amp;RequestContext,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let all_users = provider.list_resources("User", None, context).await?;
    
    // Process in chunks for memory efficiency
    for chunk in all_users.chunks(100) {
        for user in chunk {
            // Process each user
            println!("Processing user: {}", user.get_username().unwrap_or("unknown"));
        }
        
        // Optional: Add delay between chunks to avoid overwhelming the system
        tokio::time::sleep(std::time::Duration::from_millis(10)).await;
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This guide covered all fundamental SCIM operations using the StandardResourceProvider:</p>
<p><strong>CRUD Operations</strong>:</p>
<ul>
<li>✅ <strong>Create</strong> resources with <code>create_resource()</code></li>
<li>✅ <strong>Read</strong> resources with <code>get_resource()</code> and <code>list_resources()</code></li>
<li>✅ <strong>Update</strong> resources with <code>update_resource()</code></li>
<li>✅ <strong>Delete</strong> resources with <code>delete_resource()</code></li>
</ul>
<p><strong>Advanced Features</strong>:</p>
<ul>
<li>✅ <strong>Attribute search</strong> with <code>find_resource_by_attribute()</code></li>
<li>✅ <strong>Resource existence</strong> checks with <code>resource_exists()</code></li>
<li>✅ <strong>Version management</strong> with ETag support</li>
<li>✅ <strong>Client-side filtering</strong> and sorting</li>
<li>✅ <strong>Bulk operations</strong> with async iteration</li>
<li>✅ <strong>Error handling</strong> patterns and retry logic</li>
</ul>
<p><strong>Key Takeaways</strong>:</p>
<ol>
<li>Always use <code>RequestContext</code> for operation tracking</li>
<li>Leverage typed methods like <code>get_username()</code>, <code>get_emails()</code> for safe data access</li>
<li>Handle errors gracefully with proper pattern matching</li>
<li>Use ETags for concurrency control in multi-client scenarios</li>
<li>Implement client-side filtering for complex queries</li>
</ol>
<p>You're now ready to build robust SCIM applications! Next, explore <a href="getting-started/../tutorials/custom-resources.html">Custom Resource Types</a> or <a href="getting-started/../tutorials/multi-tenant-deployment.html">Multi-Tenant Deployment</a> for advanced scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scim-protocol-overview"><a class="header" href="#scim-protocol-overview">SCIM Protocol Overview</a></h1>
<p>Welcome to the SCIM (System for Cross-domain Identity Management) protocol! This chapter provides a comprehensive introduction to SCIM 2.0 and explains why it's essential for modern identity provisioning.</p>
<h2 id="what-is-scim"><a class="header" href="#what-is-scim">What is SCIM?</a></h2>
<p>SCIM is an open standard for automating the exchange of user identity information between identity domains or IT systems. Think of it as "REST for identity management" - it provides a standardized way to create, read, update, and delete user and group information across different systems.</p>
<h3 id="the-problem-scim-solves"><a class="header" href="#the-problem-scim-solves">The Problem SCIM Solves</a></h3>
<p>Before SCIM, organizations faced these challenges:</p>
<p><strong>Manual Provisioning</strong>:</p>
<ul>
<li>IT administrators manually creating accounts in each system</li>
<li>Human errors leading to security gaps</li>
<li>Slow onboarding and offboarding processes</li>
</ul>
<p><strong>Custom Integrations</strong>:</p>
<ul>
<li>Each system had its own API for user management</li>
<li>Expensive custom integration development</li>
<li>Maintenance nightmares when systems changed</li>
</ul>
<p><strong>Security Risks</strong>:</p>
<ul>
<li>Orphaned accounts when employees left</li>
<li>Inconsistent access control across systems</li>
<li>No centralized audit trail</li>
</ul>
<p><strong>SCIM's Solution</strong>: A standardized protocol that enables automatic, secure, and consistent identity provisioning across all systems.</p>
<h2 id="scim-20-core-concepts"><a class="header" href="#scim-20-core-concepts">SCIM 2.0 Core Concepts</a></h2>
<h3 id="resources"><a class="header" href="#resources">Resources</a></h3>
<p>SCIM models identity information as <strong>resources</strong>. The two primary resource types are:</p>
<h4 id="users"><a class="header" href="#users">Users</a></h4>
<p>Represent individual people with attributes like:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "id": "2819c223-7f76-453a-919d-413861904646",
  "userName": "bjensen@example.com",
  "name": {
    "formatted": "Ms. Barbara J Jensen III",
    "familyName": "Jensen",
    "givenName": "Barbara"
  },
  "emails": [
    {
      "value": "bjensen@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "active": true
}
</code></pre>
<h4 id="groups"><a class="header" href="#groups">Groups</a></h4>
<p>Represent collections of users:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "id": "e9e30dba-f08f-4109-8486-d5c6a331660a",
  "displayName": "Tour Guides",
  "members": [
    {
      "value": "2819c223-7f76-453a-919d-413861904646",
      "$ref": "../Users/2819c223-7f76-453a-919d-413861904646",
      "display": "Barbara Jensen"
    }
  ]
}
</code></pre>
<h3 id="schemas"><a class="header" href="#schemas">Schemas</a></h3>
<p>SCIM uses <strong>schemas</strong> to define the structure and validation rules for resources. Every resource must declare which schemas it conforms to.</p>
<p><strong>Core Schemas</strong>:</p>
<ul>
<li><code>urn:ietf:params:scim:schemas:core:2.0:User</code> - Standard user attributes</li>
<li><code>urn:ietf:params:scim:schemas:core:2.0:Group</code> - Standard group attributes</li>
</ul>
<p><strong>Extension Schemas</strong>:</p>
<ul>
<li><code>urn:ietf:params:scim:schemas:extension:enterprise:2.0:User</code> - Enterprise attributes (employee ID, manager, etc.)</li>
<li>Custom schemas for organization-specific attributes</li>
</ul>
<h3 id="operations"><a class="header" href="#operations">Operations</a></h3>
<p>SCIM defines standard HTTP operations for resource management:</p>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>HTTP Method</th><th>Purpose</th><th>Status</th></tr></thead><tbody>
<tr><td><strong>Create</strong></td><td>POST</td><td>Add new users or groups</td><td>✅ Implemented</td></tr>
<tr><td><strong>Read</strong></td><td>GET</td><td>Retrieve specific resources</td><td>✅ Implemented</td></tr>
<tr><td><strong>Replace</strong></td><td>PUT</td><td>Replace entire resource</td><td>✅ Implemented</td></tr>
<tr><td><strong>Update</strong></td><td>PATCH</td><td>Modify specific attributes</td><td>✅ Implemented</td></tr>
<tr><td><strong>Delete</strong></td><td>DELETE</td><td>Remove resources</td><td>✅ Implemented</td></tr>
<tr><td><strong>Search</strong></td><td>GET</td><td>Query resources with filters</td><td>⚠️ Limited (pagination only)</td></tr>
<tr><td><strong>Bulk</strong></td><td>POST</td><td>Perform multiple operations</td><td>❌ Not implemented</td></tr>
</tbody></table>
</div>
<h2 id="scim-endpoints"><a class="header" href="#scim-endpoints">SCIM Endpoints</a></h2>
<p>A SCIM server exposes these standard endpoints:</p>
<h3 id="resource-endpoints"><a class="header" href="#resource-endpoints">Resource Endpoints</a></h3>
<pre><code>GET    /Users                    # List all users
POST   /Users                    # Create new user
GET    /Users/{id}               # Get specific user
PUT    /Users/{id}               # Replace user
PATCH  /Users/{id}               # Update user
DELETE /Users/{id}               # Delete user

GET    /Groups                   # List all groups
POST   /Groups                   # Create new group
GET    /Groups/{id}              # Get specific group
PUT    /Groups/{id}              # Replace group
PATCH  /Groups/{id}              # Update group
DELETE /Groups/{id}              # Delete group
</code></pre>
<h3 id="special-endpoints"><a class="header" href="#special-endpoints">Special Endpoints</a></h3>
<pre><code>GET    /ServiceProviderConfig    # Server capabilities
GET    /ResourceTypes            # Available resource types
GET    /Schemas                  # Schema definitions
POST   /Bulk                     # Bulk operations (not yet implemented)
</code></pre>
<h2 id="filtering-and-querying"><a class="header" href="#filtering-and-querying">Filtering and Querying</a></h2>
<p>SCIM provides powerful filtering capabilities for finding specific resources:</p>
<h3 id="basic-filters"><a class="header" href="#basic-filters">Basic Filters</a></h3>
<pre><code># Find users by email
GET /Users?filter=emails.value eq "bjensen@example.com"

# Find active users
GET /Users?filter=active eq true

# Find users by department
GET /Users?filter=department eq "Engineering"
</code></pre>
<h3 id="complex-filters"><a class="header" href="#complex-filters">Complex Filters</a></h3>
<pre><code># Multiple conditions
GET /Users?filter=active eq true and emails.type eq "work"

# Pattern matching
GET /Users?filter=userName sw "john"

# Date comparisons
GET /Users?filter=meta.lastModified gt "2023-01-01T00:00:00Z"
</code></pre>
<h3 id="pagination-1"><a class="header" href="#pagination-1">Pagination</a></h3>
<pre><code># Paginated results
GET /Users?startIndex=1&amp;count=50

# Sorted results
GET /Users?sortBy=meta.lastModified&amp;sortOrder=descending
</code></pre>
<h2 id="versioning-and-concurrency"><a class="header" href="#versioning-and-concurrency">Versioning and Concurrency</a></h2>
<p>SCIM uses <strong>ETags</strong> for optimistic concurrency control:</p>
<h3 id="version-detection"><a class="header" href="#version-detection">Version Detection</a></h3>
<pre><code class="language-http">GET /Users/123
Response Headers:
ETag: "W/\"3694e05e9dff590\""
</code></pre>
<h3 id="conditional-updates"><a class="header" href="#conditional-updates">Conditional Updates</a></h3>
<pre><code class="language-http">PUT /Users/123
If-Match: "W/\"3694e05e9dff590\""
</code></pre>
<p>If the resource was modified by someone else, the server returns <code>412 Precondition Failed</code>.</p>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>SCIM defines standard error responses:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidFilter",
  "detail": "The specified filter syntax is invalid"
}
</code></pre>
<p>Common error types:</p>
<ul>
<li><code>invalidFilter</code> - Malformed filter expression</li>
<li><code>tooMany</code> - Query returned too many results</li>
<li><code>uniqueness</code> - Unique constraint violation</li>
<li><code>mutability</code> - Attempt to modify read-only attribute</li>
</ul>
<h2 id="bulk-operations-1"><a class="header" href="#bulk-operations-1">Bulk Operations</a></h2>
<blockquote>
<p><strong>⚠️ Implementation Status</strong>: Bulk operations are <strong>not yet implemented</strong> in this library.</p>
</blockquote>
<p>While the SCIM 2.0 specification includes bulk operations for efficiency, this library currently requires individual API calls for each operation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current approach: Individual operations
async fn create_multiple_users(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    users: Vec&lt;serde_json::Value&gt;
) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("batch-create", None);
    let mut created_users = Vec::new();
    
    for user_data in users {
        let user = provider.create_resource("User", user_data, &amp;context).await?;
        created_users.push(user);
    }
    
    Ok(created_users)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Future Implementation</strong>: The SCIM bulk endpoint specification would look like:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:BulkRequest"],
  "Operations": [
    {
      "method": "POST",
      "path": "/Users",
      "bulkId": "qwerty",
      "data": {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@example.com"
      }
    }
  ]
}
</code></pre>
<h2 id="benefits-of-scim"><a class="header" href="#benefits-of-scim">Benefits of SCIM</a></h2>
<h3 id="for-organizations"><a class="header" href="#for-organizations">For Organizations</a></h3>
<ul>
<li><strong>Automated Provisioning</strong>: Eliminate manual account management</li>
<li><strong>Security</strong>: Consistent access control and rapid deprovisioning</li>
<li><strong>Compliance</strong>: Centralized audit trails and access reviews</li>
<li><strong>Cost Reduction</strong>: Reduce IT overhead and integration costs</li>
</ul>
<h3 id="for-developers"><a class="header" href="#for-developers">For Developers</a></h3>
<ul>
<li><strong>Standardization</strong>: One API to learn instead of dozens</li>
<li><strong>Interoperability</strong>: Works with existing identity providers</li>
<li><strong>Type Safety</strong>: Well-defined schemas prevent errors</li>
<li><strong>Scalability</strong>: Pagination support and planned bulk operations</li>
</ul>
<h3 id="for-users"><a class="header" href="#for-users">For Users</a></h3>
<ul>
<li><strong>Faster Onboarding</strong>: Immediate access to necessary systems</li>
<li><strong>Self-Service</strong>: Update profile information in one place</li>
<li><strong>Better Experience</strong>: Consistent identity across applications</li>
</ul>
<h2 id="scim-in-practice"><a class="header" href="#scim-in-practice">SCIM in Practice</a></h2>
<h3 id="common-use-cases"><a class="header" href="#common-use-cases">Common Use Cases</a></h3>
<p><strong>Employee Lifecycle Management</strong>:</p>
<ul>
<li>Automatically create accounts when employees join</li>
<li>Update access when roles change</li>
<li>Remove access when employees leave</li>
</ul>
<p><strong>Application Integration</strong>:</p>
<ul>
<li>Sync users from Active Directory to SaaS applications</li>
<li>Provision groups based on organizational structure</li>
<li>Maintain consistent user profiles across systems</li>
</ul>
<p><strong>Compliance and Auditing</strong>:</p>
<ul>
<li>Track all identity changes with timestamps</li>
<li>Generate access reports for compliance reviews</li>
<li>Ensure timely deprovisioning for security</li>
</ul>
<h3 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h3>
<p><strong>Identity Provider → Applications</strong>:</p>
<pre><code>[Active Directory] → [SCIM Server] → [Slack, GitHub, Salesforce]
</code></pre>
<p><strong>HR System → Everything</strong>:</p>
<pre><code>[HR System] → [SCIM Server] → [All IT Systems]
</code></pre>
<p><strong>Federated Identity</strong>:</p>
<pre><code>[Company A SCIM] ←→ [Company B SCIM] (via secure federation)
</code></pre>
<h2 id="why-choose-scim-server-library"><a class="header" href="#why-choose-scim-server-library">Why Choose SCIM Server Library?</a></h2>
<p>While SCIM standardizes the protocol, implementation quality varies widely. This library provides:</p>
<h3 id="enterprise-grade-features"><a class="header" href="#enterprise-grade-features">Enterprise-Grade Features</a></h3>
<ul>
<li><strong>Multi-tenancy</strong>: Isolate different organizations</li>
<li><strong>Type Safety</strong>: Prevent runtime errors with Rust's type system</li>
<li><strong>Performance</strong>: Async-first design with minimal overhead</li>
<li><strong>Extensibility</strong>: Easy schema customization and validation</li>
</ul>
<h3 id="developer-experience"><a class="header" href="#developer-experience">Developer Experience</a></h3>
<ul>
<li><strong>Framework Agnostic</strong>: Works with Axum, Warp, Actix, or custom HTTP</li>
<li><strong>Rich Filtering</strong>: Full SCIM filter expression support</li>
<li><strong>Comprehensive Testing</strong>: Battle-tested with extensive test suites</li>
<li><strong>Clear Documentation</strong>: This guide plus API documentation</li>
</ul>
<h3 id="production-ready"><a class="header" href="#production-ready">Production Ready</a></h3>
<ul>
<li><strong>Concurrency Control</strong>: Automatic ETag handling</li>
<li><strong>Error Handling</strong>: Comprehensive error types and messages</li>
<li><strong>Monitoring</strong>: Built-in observability hooks</li>
<li><strong>Security</strong>: Input validation and sanitization</li>
</ul>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand SCIM fundamentals, you're ready to:</p>
<ol>
<li><strong><a href="concepts/../getting-started/installation.html">Set up your development environment</a></strong></li>
<li><strong><a href="concepts/../getting-started/first-server.html">Build your first SCIM server</a></strong></li>
<li><strong><a href="concepts/./architecture.html">Learn the architecture</a></strong> behind this library</li>
<li><strong><a href="concepts/./multi-tenancy.html">Explore multi-tenancy</a></strong> for enterprise deployments</li>
</ol>
<p>The SCIM protocol provides the foundation for modern identity management. With this library, you can focus on your business logic while we handle the complex protocol details.</p>
<p>Ready to provision some identities? Let's get started! 🚀</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>This chapter explains the SCIM Server's three-layer architecture and how it enables flexible, scalable identity provisioning systems.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The SCIM Server acts as <strong>intelligent middleware</strong> that handles all provisioning complexity so your applications don't have to. It follows a clean three-layer architecture that separates concerns and enables flexibility:</p>
<pre><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Client Layer  │    │   SCIM Server    │    │  Storage Layer  │
│                 │    │                  │    │                 │
│  • Web Apps     │───▶│  • Validation    │───▶│  • In-Memory    │
│  • AI Tools     │    │  • Operations    │    │  • Database     │
│  • CLI Scripts  │    │  • Multi-tenant  │    │  • Custom       │
│  • Custom APIs  │    │  • Type Safety   │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
</code></pre>
<p>This design provides flexibility at each layer while maintaining consistency and type safety throughout.</p>
<h2 id="client-layer-multiple-ways-to-connect"><a class="header" href="#client-layer-multiple-ways-to-connect">Client Layer: Multiple Ways to Connect</a></h2>
<p>The SCIM Server supports diverse client types through standardized interfaces:</p>
<h3 id="web-applications"><a class="header" href="#web-applications">Web Applications</a></h3>
<ul>
<li><strong>Admin Portals</strong>: Full-featured management interfaces</li>
<li><strong>User Dashboards</strong>: Self-service identity management</li>
<li><strong>Sync Tools</strong>: Automated synchronization between systems</li>
<li><strong>Integration APIs</strong>: RESTful endpoints for custom applications</li>
</ul>
<h3 id="ai-assistants"><a class="header" href="#ai-assistants">AI Assistants</a></h3>
<ul>
<li><strong>Natural Language Processing</strong>: Convert human requests to SCIM operations</li>
<li><strong>Model Context Protocol (MCP)</strong>: Direct integration with Claude, ChatGPT, and custom bots</li>
<li><strong>Conversational Interfaces</strong>: Chat-based identity management</li>
<li><strong>Intelligent Automation</strong>: AI-driven provisioning decisions</li>
</ul>
<h3 id="automation-tools"><a class="header" href="#automation-tools">Automation Tools</a></h3>
<ul>
<li><strong>CLI Scripts</strong>: Command-line tools for bulk operations</li>
<li><strong>Migration Scripts</strong>: Data import/export utilities</li>
<li><strong>DevOps Pipelines</strong>: CI/CD integration for automated provisioning</li>
<li><strong>Batch Processing</strong>: Scheduled bulk operations</li>
</ul>
<h3 id="custom-integrations"><a class="header" href="#custom-integrations">Custom Integrations</a></h3>
<ul>
<li><strong>GraphQL</strong>: Type-safe query interfaces</li>
<li><strong>gRPC</strong>: High-performance binary protocols</li>
<li><strong>Message Queues</strong>: Asynchronous processing workflows</li>
<li><strong>Webhooks</strong>: Event-driven integrations</li>
<li><strong>Custom Protocols</strong>: Adapt to any existing system</li>
</ul>
<h2 id="intelligence-layer-the-scim-server-core"><a class="header" href="#intelligence-layer-the-scim-server-core">Intelligence Layer: The SCIM Server Core</a></h2>
<p>The SCIM Server core provides enterprise-grade capabilities that would take months to build yourself:</p>
<h3 id="dynamic-schema-management"><a class="header" href="#dynamic-schema-management">Dynamic Schema Management</a></h3>
<ul>
<li><strong>Custom Resource Types</strong>: Define schemas beyond users and groups</li>
<li><strong>Automatic Validation</strong>: Schema-driven input validation</li>
<li><strong>Schema Evolution</strong>: Version and migrate schemas over time</li>
<li><strong>Type Safety</strong>: Compile-time schema validation</li>
</ul>
<h3 id="comprehensive-validation"><a class="header" href="#comprehensive-validation">Comprehensive Validation</a></h3>
<ul>
<li><strong>Input Validation</strong>: Automatic validation against SCIM schemas</li>
<li><strong>Business Rules</strong>: Custom validation logic</li>
<li><strong>Error Reporting</strong>: Detailed, actionable error messages</li>
<li><strong>Data Integrity</strong>: Ensure consistency across operations</li>
</ul>
<h3 id="standardized-operations"><a class="header" href="#standardized-operations">Standardized Operations</a></h3>
<ul>
<li><strong>CRUD Operations</strong>: Create, Read, Update, Delete with SCIM semantics</li>
<li><strong>Filtering</strong>: Rich query capabilities with SCIM filter syntax</li>
<li><strong>Bulk Operations</strong>: Efficient batch processing</li>
<li><strong>PATCH Operations</strong>: Granular updates with RFC 7644 compliance</li>
</ul>
<h3 id="multi-tenant-architecture"><a class="header" href="#multi-tenant-architecture">Multi-Tenant Architecture</a></h3>
<ul>
<li><strong>Organization Isolation</strong>: Complete data separation between tenants</li>
<li><strong>Configuration Management</strong>: Tenant-specific settings and schemas</li>
<li><strong>Resource Scoping</strong>: Automatic tenant boundary enforcement</li>
<li><strong>Performance Isolation</strong>: Independent scaling per tenant</li>
</ul>
<h3 id="automatic-capabilities"><a class="header" href="#automatic-capabilities">Automatic Capabilities</a></h3>
<ul>
<li><strong>Service Provider Configuration</strong>: Self-documenting API features</li>
<li><strong>Schema Discovery</strong>: Runtime schema introspection</li>
<li><strong>Capability Advertisement</strong>: Automatic feature detection</li>
<li><strong>API Documentation</strong>: Generated OpenAPI specifications</li>
</ul>
<h2 id="storage-layer-flexible-backend-options"><a class="header" href="#storage-layer-flexible-backend-options">Storage Layer: Flexible Backend Options</a></h2>
<p>Choose your data storage strategy without changing your application code:</p>
<h3 id="development-options"><a class="header" href="#development-options">Development Options</a></h3>
<ul>
<li><strong>In-Memory Storage</strong>: Fast prototyping and testing</li>
<li><strong>SQLite</strong>: Local file-based persistence</li>
<li><strong>Mock Providers</strong>: Testing and simulation</li>
</ul>
<h3 id="enterprise-options"><a class="header" href="#enterprise-options">Enterprise Options</a></h3>
<ul>
<li><strong>PostgreSQL</strong>: ACID compliance with advanced features</li>
<li><strong>MySQL</strong>: Reliable relational database</li>
<li><strong>SQL Server</strong>: Enterprise Microsoft integration</li>
</ul>
<h3 id="cloud-native-options"><a class="header" href="#cloud-native-options">Cloud-Native Options</a></h3>
<ul>
<li><strong>DynamoDB</strong>: AWS NoSQL for massive scale</li>
<li><strong>MongoDB</strong>: Document-based flexible schemas</li>
<li><strong>Redis</strong>: High-performance caching layer</li>
<li><strong>S3</strong>: Object storage for archival</li>
</ul>
<h3 id="custom-providers"><a class="header" href="#custom-providers">Custom Providers</a></h3>
<ul>
<li><strong>Trait-Based</strong>: Implement the <code>StorageProvider</code> trait</li>
<li><strong>Async Support</strong>: Full async/await compatibility</li>
<li><strong>Error Handling</strong>: Rich error types and recovery</li>
<li><strong>Testing</strong>: Built-in test utilities</li>
</ul>
<h2 id="value-proposition-complexity-reduction"><a class="header" href="#value-proposition-complexity-reduction">Value Proposition: Complexity Reduction</a></h2>
<p>Instead of building provisioning logic into every application, SCIM Server centralizes complexity:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Without SCIM Server</strong></th><th><strong>With SCIM Server</strong></th></tr></thead><tbody>
<tr><td>❌ Custom validation in each app</td><td>✅ <strong>Centralized validation engine</strong></td></tr>
<tr><td>❌ Manual concurrency control</td><td>✅ <strong>Automatic ETag versioning</strong></td></tr>
<tr><td>❌ Manual schema management</td><td>✅ <strong>Dynamic schema registry</strong></td></tr>
<tr><td>❌ Ad-hoc API endpoints</td><td>✅ <strong>Standardized SCIM protocol</strong></td></tr>
<tr><td>❌ Reinvent capability discovery</td><td>✅ <strong>Automatic capability construction</strong></td></tr>
<tr><td>❌ Build multi-tenancy from scratch</td><td>✅ <strong>Built-in tenant isolation</strong></td></tr>
<tr><td>❌ Custom error handling per resource</td><td>✅ <strong>Consistent error semantics</strong></td></tr>
<tr><td>❌ Lost updates in concurrent scenarios</td><td>✅ <strong>Version conflict detection</strong></td></tr>
</tbody></table>
</div>
<p><strong>Result</strong>: Your applications focus on business logic while SCIM Server handles all provisioning complexity with enterprise-grade capabilities.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p>The architecture follows key design principles:</p>
<h3 id="separation-of-concerns"><a class="header" href="#separation-of-concerns">Separation of Concerns</a></h3>
<ul>
<li><strong>HTTP handling</strong> is separate from SCIM logic</li>
<li><strong>Business logic</strong> is separate from data storage</li>
<li><strong>Validation</strong> is separate from persistence</li>
<li><strong>Multi-tenancy</strong> is handled at the core, not storage level</li>
</ul>
<h3 id="type-safety"><a class="header" href="#type-safety">Type Safety</a></h3>
<ul>
<li><strong>Compile-time validation</strong> prevents runtime errors</li>
<li><strong>Strong typing</strong> throughout the API</li>
<li><strong>Schema validation</strong> ensures data integrity</li>
<li><strong>Error types</strong> provide rich error handling</li>
</ul>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<ul>
<li><strong>Async-first design</strong> for high concurrency</li>
<li><strong>Minimal allocations</strong> in hot paths</li>
<li><strong>Efficient serialization</strong> with zero-copy where possible</li>
<li><strong>Connection pooling</strong> for database providers</li>
</ul>
<h3 id="flexibility"><a class="header" href="#flexibility">Flexibility</a></h3>
<ul>
<li><strong>Pluggable storage</strong> adapts to any backend</li>
<li><strong>Framework agnostic</strong> works with any HTTP library</li>
<li><strong>Extensible schemas</strong> support custom resource types</li>
<li><strong>Configuration driven</strong> behavior without code changes</li>
</ul>
<h2 id="scalability-considerations"><a class="header" href="#scalability-considerations">Scalability Considerations</a></h2>
<p>The architecture scales in multiple dimensions:</p>
<h3 id="horizontal-scaling"><a class="header" href="#horizontal-scaling">Horizontal Scaling</a></h3>
<ul>
<li><strong>Stateless design</strong> enables multiple server instances</li>
<li><strong>Database scaling</strong> through read replicas and sharding</li>
<li><strong>Load balancing</strong> across SCIM server instances</li>
<li><strong>Cache layers</strong> for frequently accessed data</li>
</ul>
<h3 id="vertical-scaling"><a class="header" href="#vertical-scaling">Vertical Scaling</a></h3>
<ul>
<li><strong>Async processing</strong> maximizes CPU utilization</li>
<li><strong>Memory efficiency</strong> through careful allocation patterns</li>
<li><strong>Connection reuse</strong> reduces resource overhead</li>
<li><strong>Batching</strong> optimizes database interactions</li>
</ul>
<h3 id="multi-tenant-scaling"><a class="header" href="#multi-tenant-scaling">Multi-Tenant Scaling</a></h3>
<ul>
<li><strong>Tenant isolation</strong> prevents noisy neighbor problems</li>
<li><strong>Resource quotas</strong> enable fair resource sharing</li>
<li><strong>Performance monitoring</strong> per tenant</li>
<li><strong>Independent scaling</strong> based on tenant needs</li>
</ul>
<h2 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h2>
<p>Security is built into every layer:</p>
<h3 id="authentication--authorization"><a class="header" href="#authentication--authorization">Authentication &amp; Authorization</a></h3>
<ul>
<li><strong>Compile-time auth</strong> prevents unauthorized access</li>
<li><strong>Tenant isolation</strong> enforces data boundaries</li>
<li><strong>Role-based access</strong> with fine-grained permissions</li>
<li><strong>API key management</strong> with rotation support</li>
</ul>
<h3 id="data-protection"><a class="header" href="#data-protection">Data Protection</a></h3>
<ul>
<li><strong>Encryption at rest</strong> through storage providers</li>
<li><strong>Encryption in transit</strong> via HTTPS</li>
<li><strong>PII handling</strong> with appropriate safeguards</li>
<li><strong>Audit logging</strong> for compliance requirements</li>
</ul>
<h3 id="concurrency-safety"><a class="header" href="#concurrency-safety">Concurrency Safety</a></h3>
<ul>
<li><strong>ETag versioning</strong> prevents lost updates</li>
<li><strong>Atomic operations</strong> ensure data consistency</li>
<li><strong>Transaction support</strong> where available</li>
<li><strong>Conflict resolution</strong> with clear error messages</li>
</ul>
<p>This architecture provides a solid foundation for building scalable, secure, and maintainable identity provisioning systems while keeping complexity manageable for developers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resource-model"><a class="header" href="#resource-model">Resource Model</a></h1>
<p>The SCIM Server's resource model provides a type-safe, extensible foundation for identity management. This chapter explains how resources work, how to customize them, and how the type system prevents common errors.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>In SCIM, everything is a <strong>resource</strong> - users, groups, and custom objects all follow the same fundamental patterns. The SCIM Server library models these as Rust types that provide compile-time safety while maintaining runtime flexibility.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimUser, ScimGroup, ScimResource};

// Type-safe resource creation
let user = ScimUser::builder()
    .username("alice@example.com")
    .given_name("Alice")
    .family_name("Johnson")
    .email("alice@example.com")
    .build()?;

// Compile-time guarantees
let id = user.id(); // Always returns a valid UUID
let version = user.version(); // ETag for concurrency control
<span class="boring">}</span></code></pre></pre>
<p>This design provides the flexibility of JSON with the safety of Rust's type system.</p>
<h2 id="core-resource-structure"><a class="header" href="#core-resource-structure">Core Resource Structure</a></h2>
<h3 id="base-resource-traits"><a class="header" href="#base-resource-traits">Base Resource Traits</a></h3>
<p>All SCIM resources implement the <code>ScimResource</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ScimResource {
    fn id(&amp;self) -&gt; &amp;str;
    fn schemas(&amp;self) -&gt; &amp;[String];
    fn meta(&amp;self) -&gt; &amp;ResourceMeta;
    fn external_id(&amp;self) -&gt; Option&lt;&amp;str&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-metadata"><a class="header" href="#resource-metadata">Resource Metadata</a></h3>
<p>Every resource includes metadata for versioning and auditing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ResourceMeta {
    pub resource_type: String,
    pub created: DateTime&lt;Utc&gt;,
    pub last_modified: DateTime&lt;Utc&gt;,
    pub version: String,  // ETag for concurrency control
    pub location: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The metadata is automatically managed by the SCIM Server:</p>
<pre><code class="language-json">{
  "meta": {
    "resourceType": "User",
    "created": "2023-12-01T10:30:00Z",
    "lastModified": "2023-12-01T15:45:00Z",
    "version": "W/\"3694e05e9dff590\"",
    "location": "https://api.example.com/scim/v2/Users/123"
  }
}
</code></pre>
<h2 id="user-resources"><a class="header" href="#user-resources">User Resources</a></h2>
<h3 id="core-user-attributes"><a class="header" href="#core-user-attributes">Core User Attributes</a></h3>
<p>The <code>ScimUser</code> type models the standard SCIM user schema:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimUser, Name, Email, PhoneNumber};

let user = ScimUser::builder()
    .username("bjensen@example.com")
    .name(Name {
        formatted: Some("Ms. Barbara J Jensen III".to_string()),
        family_name: Some("Jensen".to_string()),
        given_name: Some("Barbara".to_string()),
        middle_name: Some("Jane".to_string()),
        honorific_prefix: Some("Ms.".to_string()),
        honorific_suffix: Some("III".to_string()),
    })
    .display_name("Babs Jensen")
    .nick_name("Babs")
    .profile_url("https://login.example.com/bjensen")
    .email(Email {
        value: "bjensen@example.com".to_string(),
        type_: Some("work".to_string()),
        primary: Some(true),
    })
    .phone_number(PhoneNumber {
        value: "+1-555-555-8377".to_string(),
        type_: Some("work".to_string()),
        primary: Some(true),
    })
    .active(true)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-value-attributes"><a class="header" href="#multi-value-attributes">Multi-Value Attributes</a></h3>
<p>SCIM supports multi-value attributes for emails, phone numbers, and addresses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = ScimUser::builder()
    .username("alice@example.com")
    .emails(vec![
        Email {
            value: "alice@work.com".to_string(),
            type_: Some("work".to_string()),
            primary: Some(true),
        },
        Email {
            value: "alice@personal.com".to_string(),
            type_: Some("home".to_string()),
            primary: Some(false),
        },
    ])
    .phone_numbers(vec![
        PhoneNumber {
            value: "+1-555-555-1234".to_string(),
            type_: Some("work".to_string()),
            primary: Some(true),
        },
        PhoneNumber {
            value: "+1-555-555-5678".to_string(),
            type_: Some("mobile".to_string()),
            primary: Some(false),
        },
    ])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="enterprise-extensions"><a class="header" href="#enterprise-extensions">Enterprise Extensions</a></h3>
<p>For enterprise environments, SCIM provides additional attributes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimUser, EnterpriseUser};

let user = ScimUser::builder()
    .username("alice@example.com")
    .given_name("Alice")
    .family_name("Johnson")
    .enterprise(EnterpriseUser {
        employee_number: Some("12345".to_string()),
        cost_center: Some("Engineering".to_string()),
        organization: Some("ACME Corp".to_string()),
        division: Some("Technology".to_string()),
        department: Some("Software Development".to_string()),
        manager: Some(Manager {
            value: "manager-id-456".to_string(),
            ref_: Some("../Users/manager-id-456".to_string()),
            display_name: Some("Bob Smith".to_string()),
        }),
    })
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="group-resources"><a class="header" href="#group-resources">Group Resources</a></h2>
<h3 id="basic-group-structure"><a class="header" href="#basic-group-structure">Basic Group Structure</a></h3>
<p>Groups represent collections of users with optional hierarchical relationships:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimGroup, GroupMember};

let group = ScimGroup::builder()
    .display_name("Engineering Team")
    .members(vec![
        GroupMember {
            value: "user-id-123".to_string(),
            ref_: Some("../Users/user-id-123".to_string()),
            type_: Some("User".to_string()),
            display: Some("Alice Johnson".to_string()),
        },
        GroupMember {
            value: "user-id-456".to_string(),
            ref_: Some("../Users/user-id-456".to_string()),
            type_: Some("User".to_string()),
            display: Some("Bob Smith".to_string()),
        },
    ])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="nested-groups"><a class="header" href="#nested-groups">Nested Groups</a></h3>
<p>Groups can contain other groups for hierarchical organization:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let parent_group = ScimGroup::builder()
    .display_name("All Engineering")
    .members(vec![
        GroupMember {
            value: "group-frontend".to_string(),
            ref_: Some("../Groups/group-frontend".to_string()),
            type_: Some("Group".to_string()),
            display: Some("Frontend Team".to_string()),
        },
        GroupMember {
            value: "group-backend".to_string(),
            ref_: Some("../Groups/group-backend".to_string()),
            type_: Some("Group".to_string()),
            display: Some("Backend Team".to_string()),
        },
    ])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="schema-system"><a class="header" href="#schema-system">Schema System</a></h2>
<h3 id="schema-definition"><a class="header" href="#schema-definition">Schema Definition</a></h3>
<p>Schemas define the structure and validation rules for resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{Schema, Attribute, AttributeType, Mutability, Returned};

let user_schema = Schema::builder()
    .id("urn:ietf:params:scim:schemas:core:2.0:User")
    .name("User")
    .description("User Account")
    .attribute(
        Attribute::builder()
            .name("userName")
            .type_(AttributeType::String)
            .mutability(Mutability::ReadWrite)
            .returned(Returned::Default)
            .uniqueness(true)
            .required(true)
            .case_exact(false)
            .build()
    )
    .attribute(
        Attribute::builder()
            .name("name")
            .type_(AttributeType::Complex)
            .mutability(Mutability::ReadWrite)
            .returned(Returned::Default)
            .sub_attribute(
                Attribute::builder()
                    .name("givenName")
                    .type_(AttributeType::String)
                    .mutability(Mutability::ReadWrite)
                    .build()
            )
            .build()
    )
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="dynamic-schema-registry"><a class="header" href="#dynamic-schema-registry">Dynamic Schema Registry</a></h3>
<p>The SCIM Server maintains a registry of available schemas:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{SchemaRegistry, CoreSchemas};

let mut registry = SchemaRegistry::new();

// Register core schemas
registry.register(CoreSchemas::user());
registry.register(CoreSchemas::group());
registry.register(CoreSchemas::enterprise_user());

// Register custom schemas
registry.register(custom_department_schema());

// Validate resources against schemas
let validation_result = registry.validate_user(&amp;user)?;
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-resources"><a class="header" href="#custom-resources">Custom Resources</a></h2>
<h3 id="defining-custom-resource-types"><a class="header" href="#defining-custom-resource-types">Defining Custom Resource Types</a></h3>
<p>You can extend SCIM with custom resource types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimResource, ResourceMeta};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Project {
    pub id: String,
    pub schemas: Vec&lt;String&gt;,
    pub meta: ResourceMeta,
    pub external_id: Option&lt;String&gt;,
    
    // Custom attributes
    pub name: String,
    pub description: Option&lt;String&gt;,
    pub owner: String,
    pub status: ProjectStatus,
    pub created_date: DateTime&lt;Utc&gt;,
    pub budget: Option&lt;f64&gt;,
    pub team_members: Vec&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProjectStatus {
    Planning,
    Active,
    OnHold,
    Completed,
    Cancelled,
}

impl ScimResource for Project {
    fn id(&amp;self) -&gt; &amp;str {
        &amp;self.id
    }
    
    fn schemas(&amp;self) -&gt; &amp;[String] {
        &amp;self.schemas
    }
    
    fn meta(&amp;self) -&gt; &amp;ResourceMeta {
        &amp;self.meta
    }
    
    fn external_id(&amp;self) -&gt; Option&lt;&amp;str&gt; {
        self.external_id.as_deref()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-schema-definition"><a class="header" href="#custom-schema-definition">Custom Schema Definition</a></h3>
<p>Define the schema for your custom resource:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn project_schema() -&gt; Schema {
    Schema::builder()
        .id("urn:company:params:scim:schemas:core:2.0:Project")
        .name("Project")
        .description("Project Management Resource")
        .attribute(
            Attribute::builder()
                .name("name")
                .type_(AttributeType::String)
                .mutability(Mutability::ReadWrite)
                .returned(Returned::Default)
                .required(true)
                .case_exact(false)
                .build()
        )
        .attribute(
            Attribute::builder()
                .name("status")
                .type_(AttributeType::String)
                .mutability(Mutability::ReadWrite)
                .returned(Returned::Default)
                .canonical_values(vec![
                    "Planning".to_string(),
                    "Active".to_string(),
                    "OnHold".to_string(),
                    "Completed".to_string(),
                    "Cancelled".to_string(),
                ])
                .build()
        )
        .build()
        .unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="type-safety-features"><a class="header" href="#type-safety-features">Type Safety Features</a></h2>
<h3 id="compile-time-validation"><a class="header" href="#compile-time-validation">Compile-Time Validation</a></h3>
<p>The type system prevents many common errors:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ This compiles - valid email
let user = ScimUser::builder()
    .email("alice@example.com")
    .build()?;

// ❌ This won't compile - wrong type
let user = ScimUser::builder()
    .email(123)  // Error: expected String, found integer
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="builder-pattern-safety"><a class="header" href="#builder-pattern-safety">Builder Pattern Safety</a></h3>
<p>The builder pattern ensures required fields are provided:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// ✅ This compiles - username is required and provided
let user = ScimUser::builder()
    .username("alice@example.com")
    .build()?;

// ❌ This won't compile - missing required username
let user = ScimUser::builder()
    .given_name("Alice")
    .build()?;  // Error: username is required
<span class="boring">}</span></code></pre></pre>
<h3 id="option-types-for-optional-fields"><a class="header" href="#option-types-for-optional-fields">Option Types for Optional Fields</a></h3>
<p>Optional fields use Rust's <code>Option</code> type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = ScimUser::builder()
    .username("alice@example.com")
    .given_name("Alice")  // Option&lt;String&gt; - automatically wrapped
    .middle_name(None)    // Explicitly no middle name
    .family_name(Some("Johnson".to_string()))  // Explicitly provided
    .build()?;

// Safe access to optional fields
match user.middle_name() {
    Some(middle) =&gt; println!("Middle name: {}", middle),
    None =&gt; println!("No middle name provided"),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-and-constraints"><a class="header" href="#validation-and-constraints">Validation and Constraints</a></h2>
<h3 id="built-in-validation"><a class="header" href="#built-in-validation">Built-in Validation</a></h3>
<p>The SCIM Server provides automatic validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimUser, ValidationError};

// Email format validation
let result = ScimUser::builder()
    .username("invalid-email")  // Missing @ symbol
    .build();

match result {
    Ok(user) =&gt; println!("User created: {}", user.username()),
    Err(ValidationError::InvalidEmail(email)) =&gt; {
        println!("Invalid email format: {}", email);
    },
    Err(e) =&gt; println!("Other validation error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-validation-rules"><a class="header" href="#custom-validation-rules">Custom Validation Rules</a></h3>
<p>Add your own validation logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ScimUser {
    pub fn validate_business_rules(&amp;self) -&gt; Result&lt;(), ValidationError&gt; {
        // Custom rule: work emails must be from company domain
        if let Some(work_email) = self.work_email() {
            if !work_email.ends_with("@company.com") {
                return Err(ValidationError::InvalidWorkEmail);
            }
        }
        
        // Custom rule: employee number format
        if let Some(employee_number) = self.employee_number() {
            if !employee_number.starts_with("EMP") {
                return Err(ValidationError::InvalidEmployeeNumber);
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="serialization-and-json"><a class="header" href="#serialization-and-json">Serialization and JSON</a></h2>
<h3 id="automatic-json-serialization"><a class="header" href="#automatic-json-serialization">Automatic JSON Serialization</a></h3>
<p>Resources automatically serialize to SCIM-compliant JSON:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json;

let user = ScimUser::builder()
    .username("alice@example.com")
    .given_name("Alice")
    .family_name("Johnson")
    .build()?;

let json = serde_json::to_string_pretty(&amp;user)?;
println!("{}", json);
<span class="boring">}</span></code></pre></pre>
<p>Output:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "id": "2819c223-7f76-453a-919d-413861904646",
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Johnson"
  },
  "meta": {
    "resourceType": "User",
    "created": "2023-12-01T10:30:00Z",
    "lastModified": "2023-12-01T10:30:00Z",
    "version": "W/\"1\""
  }
}
</code></pre>
<h3 id="json-deserialization"><a class="header" href="#json-deserialization">JSON Deserialization</a></h3>
<p>Parse JSON into type-safe resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let json = r#"
{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Johnson"
  }
}
"#;

let user: ScimUser = serde_json::from_str(json)?;
println!("User: {} {}", user.given_name(), user.family_name());
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="memory-efficiency"><a class="header" href="#memory-efficiency">Memory Efficiency</a></h3>
<p>The resource model is designed for efficiency:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Zero-copy string references where possible
impl ScimUser {
    pub fn username(&amp;self) -&gt; &amp;str {  // Returns reference, not owned String
        &amp;self.username
    }
    
    pub fn display_name(&amp;self) -&gt; Option&lt;&amp;str&gt; {  // Optional reference
        self.display_name.as_deref()
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lazy-loading"><a class="header" href="#lazy-loading">Lazy Loading</a></h3>
<p>Complex attributes can be loaded on demand:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only load enterprise attributes when needed
impl ScimUser {
    pub fn enterprise(&amp;self) -&gt; Option&lt;&amp;EnterpriseUser&gt; {
        self.enterprise.as_ref()
    }
    
    pub fn load_enterprise(&amp;mut self, provider: &amp;impl Provider) -&gt; Result&lt;(), Error&gt; {
        if self.enterprise.is_none() {
            self.enterprise = provider.load_enterprise_data(&amp;self.id)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="resource-creation"><a class="header" href="#resource-creation">Resource Creation</a></h3>
<p><strong>Use builders for complex resources</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = ScimUser::builder()
    .username("alice@example.com")
    .given_name("Alice")
    .family_name("Johnson")
    .email("alice@example.com")
    .active(true)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Validate early and often</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Validate during creation
let user = ScimUser::builder()
    .username("alice@example.com")
    .validate()  // Explicit validation
    .build()?;

// Validate before persistence
user.validate_business_rules()?;
provider.create_user(user)?;
<span class="boring">}</span></code></pre></pre>
<h3 id="schema-management"><a class="header" href="#schema-management">Schema Management</a></h3>
<p><strong>Register schemas at startup</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_schemas(registry: &amp;mut SchemaRegistry) {
    registry.register(CoreSchemas::user());
    registry.register(CoreSchemas::group());
    registry.register(custom_project_schema());
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Version your custom schemas</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PROJECT_SCHEMA_V1: &amp;str = "urn:company:scim:schemas:project:1.0";
const PROJECT_SCHEMA_V2: &amp;str = "urn:company:scim:schemas:project:2.0";
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<p><strong>Handle validation errors gracefully</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match ScimUser::builder().username("invalid").build() {
    Ok(user) =&gt; process_user(user),
    Err(ValidationError::InvalidUsername(username)) =&gt; {
        log::warn!("Invalid username format: {}", username);
        return_error_response("Invalid username format");
    },
    Err(e) =&gt; {
        log::error!("Unexpected validation error: {}", e);
        return_error_response("Internal validation error");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that you understand the resource model, you're ready to:</p>
<ol>
<li><strong><a href="concepts/./multi-tenancy.html">Learn about multi-tenancy</a></strong> for isolating resources</li>
<li><strong><a href="concepts/./providers.html">Explore storage providers</a></strong> for persistence</li>
<li><strong><a href="concepts/./etag-concurrency.html">Understand ETag concurrency</a></strong> for safe updates</li>
<li><strong><a href="concepts/../tutorials/custom-resources.html">Build custom resources</a></strong> for your domain</li>
</ol>
<p>The resource model provides the foundation for type-safe SCIM operations. Combined with Rust's ownership system, it prevents many classes of runtime errors while maintaining the flexibility needed for diverse identity management scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-tenancy"><a class="header" href="#multi-tenancy">Multi-Tenancy</a></h1>
<p>Multi-tenancy is a core architectural pattern that allows a single SCIM Server instance to serve multiple organizations while keeping their data completely isolated. This chapter explains how SCIM Server implements multi-tenancy and how to use it effectively.</p>
<h2 id="what-is-multi-tenancy"><a class="header" href="#what-is-multi-tenancy">What is Multi-Tenancy?</a></h2>
<p>Multi-tenancy is a software architecture where a single instance of an application serves multiple customers (tenants). Each tenant's data is isolated and invisible to other tenants, creating the appearance of having their own dedicated instance.</p>
<h3 id="benefits-of-multi-tenancy"><a class="header" href="#benefits-of-multi-tenancy">Benefits of Multi-Tenancy</a></h3>
<ul>
<li><strong>Cost Efficiency</strong>: Shared infrastructure reduces operational costs</li>
<li><strong>Simplified Management</strong>: Single deployment to maintain and update</li>
<li><strong>Resource Optimization</strong>: Better utilization of hardware and services</li>
<li><strong>Faster Scaling</strong>: Add new tenants without new infrastructure</li>
<li><strong>Centralized Security</strong>: Consistent security policies across all tenants</li>
</ul>
<h3 id="scim-servers-multi-tenant-approach"><a class="header" href="#scim-servers-multi-tenant-approach">SCIM Server's Multi-Tenant Approach</a></h3>
<p>SCIM Server implements multi-tenancy at the application layer, providing:</p>
<ul>
<li><strong>Complete Data Isolation</strong>: No tenant can access another's data</li>
<li><strong>Tenant-Specific Configuration</strong>: Schemas and settings per tenant</li>
<li><strong>Performance Isolation</strong>: Resource quotas and monitoring per tenant</li>
<li><strong>Independent Scaling</strong>: Different tenants can have different performance profiles</li>
</ul>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="tenant-identification"><a class="header" href="#tenant-identification">Tenant Identification</a></h3>
<p>Each tenant is identified by a unique tenant ID that's used throughout the system:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimServer, TenantId, storage::InMemoryStorage};

// Create a server with multi-tenant support
let storage = InMemoryStorage::new();
let server = ScimServer::new(storage).await?;

// Operations are scoped to specific tenants
let tenant_id = TenantId::new("acme-corp");
let user = server.create_user(&amp;tenant_id, user_data).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation"><a class="header" href="#tenant-isolation">Tenant Isolation</a></h3>
<p>Data isolation is enforced at multiple levels:</p>
<ol>
<li><strong>API Level</strong>: All operations require a tenant context</li>
<li><strong>Validation Level</strong>: Schemas are tenant-specific</li>
<li><strong>Storage Level</strong>: Data is partitioned by tenant</li>
<li><strong>Authentication Level</strong>: Users belong to specific tenants</li>
</ol>
<h3 id="tenant-configuration"><a class="header" href="#tenant-configuration">Tenant Configuration</a></h3>
<p>Each tenant can have its own configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{TenantConfig, SchemaConfig};

let tenant_config = TenantConfig::builder()
    .tenant_id("acme-corp")
    .display_name("Acme Corporation")
    .max_users(1000)
    .custom_schema(custom_employee_schema)
    .features(vec!["bulk_operations", "filtering"])
    .build();

server.configure_tenant(tenant_config).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-patterns"><a class="header" href="#implementation-patterns">Implementation Patterns</a></h2>
<h3 id="basic-multi-tenant-setup"><a class="header" href="#basic-multi-tenant-setup">Basic Multi-Tenant Setup</a></h3>
<p>The simplest multi-tenant setup uses tenant IDs in all operations:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, TenantId, storage::InMemoryStorage};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = InMemoryStorage::new();
    let server = ScimServer::new(storage).await?;
    
    // Create users for different tenants
    let acme_tenant = TenantId::new("acme-corp");
    let beta_tenant = TenantId::new("beta-inc");
    
    // Acme Corp user
    let acme_user = server.create_user(&amp;acme_tenant, json!({
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@acme.com",
        "displayName": "Alice Smith"
    })).await?;
    
    // Beta Inc user
    let beta_user = server.create_user(&amp;beta_tenant, json!({
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "bob@beta.com",
        "displayName": "Bob Johnson"
    })).await?;
    
    // Users are completely isolated
    let acme_users = server.list_users(&amp;acme_tenant).await?;
    let beta_users = server.list_users(&amp;beta_tenant).await?;
    
    // acme_users contains only Alice, beta_users contains only Bob
    
    Ok(())
}</code></pre></pre>
<h3 id="http-integration-with-tenant-context"><a class="header" href="#http-integration-with-tenant-context">HTTP Integration with Tenant Context</a></h3>
<p>When integrating with HTTP frameworks, extract tenant ID from the request:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{extract::Path, Extension, Json};
use scim_server::{ScimServer, TenantId};

async fn create_user(
    Path(tenant_id): Path&lt;String&gt;,
    Extension(server): Extension&lt;ScimServer&gt;,
    Json(user_data): Json&lt;serde_json::Value&gt;,
) -&gt; Result&lt;Json&lt;serde_json::Value&gt;, AppError&gt; {
    let tenant = TenantId::new(tenant_id);
    let user = server.create_user(&amp;tenant, user_data).await?;
    Ok(Json(user))
}

// Route: POST /tenants/{tenant_id}/scim/v2/Users
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-specific-schemas"><a class="header" href="#tenant-specific-schemas">Tenant-Specific Schemas</a></h3>
<p>Different tenants can have different schema requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{CustomSchema, AttributeType, TenantId};

// Healthcare tenant needs additional fields
let healthcare_schema = CustomSchema::builder()
    .id("urn:healthcare:schemas:Employee")
    .add_attribute("licenseNumber", AttributeType::String, false)
    .add_attribute("department", AttributeType::String, false)
    .add_attribute("certifications", AttributeType::MultiValue, false)
    .build();

let healthcare_tenant = TenantId::new("healthcare-corp");
server.register_schema(&amp;healthcare_tenant, healthcare_schema).await?;

// Financial tenant needs different fields
let financial_schema = CustomSchema::builder()
    .id("urn:financial:schemas:Employee")
    .add_attribute("employeeId", AttributeType::String, true)
    .add_attribute("clearanceLevel", AttributeType::String, false)
    .add_attribute("tradingPermissions", AttributeType::MultiValue, false)
    .build();

let financial_tenant = TenantId::new("financial-corp");
server.register_schema(&amp;financial_tenant, financial_schema).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="tenant-management"><a class="header" href="#tenant-management">Tenant Management</a></h2>
<h3 id="creating-and-configuring-tenants"><a class="header" href="#creating-and-configuring-tenants">Creating and Configuring Tenants</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{TenantConfig, ResourceQuota, TenantFeatures};

async fn setup_new_tenant(
    server: &amp;ScimServer,
    tenant_id: &amp;str,
    org_name: &amp;str,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let tenant = TenantId::new(tenant_id);
    
    // Configure tenant with specific limits and features
    let config = TenantConfig::builder()
        .tenant_id(tenant_id)
        .display_name(org_name)
        .quota(ResourceQuota {
            max_users: 500,
            max_groups: 50,
            max_custom_resources: 100,
        })
        .features(TenantFeatures {
            bulk_operations: true,
            patch_operations: true,
            filtering: true,
            sorting: true,
            ai_integration: false, // Disabled for basic plan
        })
        .build();
    
    server.create_tenant(config).await?;
    
    // Set up default schemas
    server.register_default_schemas(&amp;tenant).await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-discovery-and-listing"><a class="header" href="#tenant-discovery-and-listing">Tenant Discovery and Listing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List all configured tenants
let tenants = server.list_tenants().await?;

for tenant in tenants {
    println!("Tenant: {} ({})", tenant.id, tenant.display_name);
    println!("  Users: {}/{}", tenant.user_count, tenant.max_users);
    println!("  Features: {:?}", tenant.enabled_features);
}

// Get specific tenant information
let tenant_info = server.get_tenant_info(&amp;TenantId::new("acme-corp")).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-considerations"><a class="header" href="#storage-considerations">Storage Considerations</a></h2>
<h3 id="database-multi-tenancy"><a class="header" href="#database-multi-tenancy">Database Multi-Tenancy</a></h3>
<p>When using database storage, tenant isolation can be implemented in several ways:</p>
<h4 id="shared-database-separate-schemas"><a class="header" href="#shared-database-separate-schemas">Shared Database, Separate Schemas</a></h4>
<pre><code class="language-sql">-- Each tenant gets its own schema
CREATE SCHEMA tenant_acme_corp;
CREATE SCHEMA tenant_beta_inc;

-- Tables are created in tenant-specific schemas
CREATE TABLE tenant_acme_corp.users (...);
CREATE TABLE tenant_beta_inc.users (...);
</code></pre>
<h4 id="shared-database-shared-tables-with-tenant-column"><a class="header" href="#shared-database-shared-tables-with-tenant-column">Shared Database, Shared Tables with Tenant Column</a></h4>
<pre><code class="language-sql">-- Single table with tenant_id column
CREATE TABLE users (
    tenant_id VARCHAR(255) NOT NULL,
    user_id VARCHAR(255) NOT NULL,
    username VARCHAR(255) NOT NULL,
    -- ... other columns
    PRIMARY KEY (tenant_id, user_id)
);

-- All queries include tenant_id in WHERE clause
SELECT * FROM users WHERE tenant_id = 'acme-corp';
</code></pre>
<h4 id="separate-databases-per-tenant"><a class="header" href="#separate-databases-per-tenant">Separate Databases per Tenant</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::DatabaseConfig;

// Configure separate databases per tenant
let acme_config = DatabaseConfig::new("postgresql://host/acme_corp_db");
let beta_config = DatabaseConfig::new("postgresql://host/beta_inc_db");

// Storage provider handles routing based on tenant
let storage = MultiTenantDatabaseStorage::new()
    .add_tenant("acme-corp", acme_config)
    .add_tenant("beta-inc", beta_config);
<span class="boring">}</span></code></pre></pre>
<h2 id="security-and-compliance"><a class="header" href="#security-and-compliance">Security and Compliance</a></h2>
<h3 id="authentication-integration"><a class="header" href="#authentication-integration">Authentication Integration</a></h3>
<p>Combine multi-tenancy with authentication for complete security:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{AuthenticationWitness, TenantAuthority};

async fn authenticated_operation(
    auth: AuthenticationWitness&lt;Authenticated&gt;,
    tenant_id: TenantId,
    server: &amp;ScimServer,
) -&gt; Result&lt;(), AuthError&gt; {
    // Verify user has access to this tenant
    let tenant_authority = auth.verify_tenant_access(&amp;tenant_id)?;
    
    // Operation is now both authenticated and tenant-scoped
    let users = server.list_users_with_auth(
        &amp;tenant_id,
        &amp;auth,
        &amp;tenant_authority
    ).await?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-logging"><a class="header" href="#audit-logging">Audit Logging</a></h3>
<p>Multi-tenant systems require comprehensive audit trails:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::audit::{AuditEvent, AuditLogger};

// All operations are logged with tenant context
let audit_logger = AuditLogger::new();

// Log tenant-scoped operations
audit_logger.log(AuditEvent::UserCreated {
    tenant_id: "acme-corp",
    user_id: "user123",
    performed_by: "admin@acme.com",
    timestamp: Utc::now(),
}).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="data-residency-and-compliance"><a class="header" href="#data-residency-and-compliance">Data Residency and Compliance</a></h3>
<p>Different tenants may have different compliance requirements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{DataResidency, ComplianceMode};

let eu_tenant_config = TenantConfig::builder()
    .tenant_id("eu-customer")
    .data_residency(DataResidency::EuropeanUnion)
    .compliance_mode(ComplianceMode::GDPR)
    .encryption_required(true)
    .audit_retention_days(2555) // 7 years
    .build();

let us_tenant_config = TenantConfig::builder()
    .tenant_id("us-customer")
    .data_residency(DataResidency::UnitedStates)
    .compliance_mode(ComplianceMode::SOX)
    .encryption_required(true)
    .audit_retention_days(2555)
    .build();
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-and-scaling"><a class="header" href="#performance-and-scaling">Performance and Scaling</a></h2>
<h3 id="resource-isolation"><a class="header" href="#resource-isolation">Resource Isolation</a></h3>
<p>Prevent one tenant from affecting others:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ResourceLimits, RateLimiting};

let tenant_limits = ResourceLimits::builder()
    .max_requests_per_minute(1000)
    .max_concurrent_operations(50)
    .max_query_complexity(100)
    .memory_limit_mb(512)
    .build();

server.set_tenant_limits(&amp;tenant_id, tenant_limits).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="monitoring-per-tenant"><a class="header" href="#monitoring-per-tenant">Monitoring per Tenant</a></h3>
<p>Track performance and usage metrics per tenant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{TenantMetrics, MetricsCollector};

let metrics = server.get_tenant_metrics(&amp;tenant_id).await?;

println!("Tenant {} metrics:", tenant_id);
println!("  Requests/minute: {}", metrics.requests_per_minute);
println!("  Average response time: {}ms", metrics.avg_response_time);
println!("  Storage usage: {}MB", metrics.storage_usage_mb);
println!("  Error rate: {}%", metrics.error_rate);
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="tenant-id-strategy"><a class="header" href="#tenant-id-strategy">Tenant ID Strategy</a></h3>
<p>Choose tenant IDs carefully:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Clear, unique, URL-safe
let tenant_id = TenantId::new("acme-corp-prod");

// Avoid: Ambiguous or containing sensitive data
let bad_tenant_id = TenantId::new("customer-123-secret-key");
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-management"><a class="header" href="#configuration-management">Configuration Management</a></h3>
<p>Use environment-specific configurations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::config::TenantConfigLoader;

// Load tenant configurations from external sources
let config_loader = TenantConfigLoader::new()
    .from_file("tenants.yaml")
    .from_env_prefix("SCIM_TENANT_")
    .from_database(&amp;config_db);

let tenant_configs = config_loader.load_all().await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h3>
<p>Provide tenant-aware error messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::error::{ScimError, TenantError};

match server.get_user(&amp;tenant_id, &amp;user_id).await {
    Ok(user) =&gt; Ok(user),
    Err(ScimError::TenantNotFound(tenant)) =&gt; {
        Err(format!("Organization '{}' not found", tenant))
    },
    Err(ScimError::UserNotFound { tenant, user_id }) =&gt; {
        Err(format!("User '{}' not found in organization '{}'", user_id, tenant))
    },
    Err(e) =&gt; Err(e.into()),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="testing-multi-tenant-code"><a class="header" href="#testing-multi-tenant-code">Testing Multi-Tenant Code</a></h3>
<p>Test with multiple tenants to ensure isolation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_tenant_isolation() {
    let server = test_server().await;
    
    let tenant_a = TenantId::new("tenant-a");
    let tenant_b = TenantId::new("tenant-b");
    
    // Create user in tenant A
    let user_a = server.create_user(&amp;tenant_a, user_data.clone()).await?;
    
    // Verify user is not visible in tenant B
    let tenant_b_users = server.list_users(&amp;tenant_b).await?;
    assert!(tenant_b_users.is_empty());
    
    // Verify user is visible in tenant A
    let tenant_a_users = server.list_users(&amp;tenant_a).await?;
    assert_eq!(tenant_a_users.len(), 1);
}
<span class="boring">}</span></code></pre></pre>
<p>Multi-tenancy in SCIM Server provides a robust foundation for building SaaS applications that serve multiple organizations while maintaining security, performance, and compliance requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-providers"><a class="header" href="#storage-providers">Storage Providers</a></h1>
<p>Storage providers are the backbone of the SCIM Server library, handling all data persistence and retrieval operations. The library uses a two-layer architecture that cleanly separates storage concerns from SCIM protocol logic.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The SCIM Server implements data access through two complementary abstractions:</p>
<ul>
<li><strong>StorageProvider</strong>: Low-level trait for pure data persistence operations</li>
<li><strong>ResourceProvider</strong>: High-level trait for SCIM-aware resource management</li>
</ul>
<p>This separation allows you to plug in different storage backends (database, file system, cloud storage) without changing SCIM protocol logic, and conversely modify SCIM behavior without touching storage implementation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, ResourceProvider},
};

// Create storage backend
let storage = InMemoryStorage::new();

// Create SCIM provider with storage
let provider = StandardResourceProvider::new(storage);

// Use for SCIM operations
let context = RequestContext::with_generated_id();
let user = provider.create_resource("User", user_data, &amp;context).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="storageprovider-layer"><a class="header" href="#storageprovider-layer">StorageProvider Layer</a></h2>
<p>The <code>StorageProvider</code> trait defines protocol-agnostic storage operations:</p>
<h3 id="core-operations"><a class="header" href="#core-operations">Core Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageProvider: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;

    // Basic CRUD operations
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt;;
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt;;
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt;;
    
    // Query operations
    async fn list(&amp;self, prefix: StoragePrefix, offset: usize, limit: usize) 
        -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt;;
    async fn find_by_attribute(&amp;self, prefix: StoragePrefix, attribute: &amp;str, value: &amp;str) 
        -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt;;
    async fn exists(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt;;
    async fn count(&amp;self, prefix: StoragePrefix) -&gt; Result&lt;usize, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation-1"><a class="header" href="#tenant-isolation-1">Tenant Isolation</a></h3>
<p>All storage operations are scoped by tenant through hierarchical keys:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StorageKey {
    tenant_id: String,      // "tenant-1" or "default"
    resource_type: String,  // "User", "Group", etc.
    resource_id: String,    // "user-123"
}

// Examples:
// StorageKey::new("tenant-1", "User", "alice-123")
// StorageKey::new("default", "Group", "admins-456")
<span class="boring">}</span></code></pre></pre>
<p>This provides automatic tenant isolation without complex tenant management systems.</p>
<h2 id="built-in-storage-providers"><a class="header" href="#built-in-storage-providers">Built-in Storage Providers</a></h2>
<h3 id="inmemorystorage"><a class="header" href="#inmemorystorage">InMemoryStorage</a></h3>
<p>Thread-safe in-memory storage using <code>HashMap</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::InMemoryStorage;

let storage = InMemoryStorage::new();

// Get statistics
let stats = storage.stats().await;
println!("Total resources: {}", stats.total_resources);
println!("Tenants: {}", stats.tenant_count);
<span class="boring">}</span></code></pre></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Development and testing</li>
<li>Proof of concepts</li>
<li>Small deployments without persistence requirements</li>
</ul>
<p><strong>Characteristics:</strong></p>
<ul>
<li>Thread-safe with <code>RwLock</code></li>
<li>No persistence across restarts</li>
<li>Excellent performance for development</li>
<li>Built-in statistics and metrics</li>
</ul>
<h3 id="custom-storage-implementation"><a class="header" href="#custom-storage-implementation">Custom Storage Implementation</a></h3>
<p>Implement <code>StorageProvider</code> for custom backends:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{StorageProvider, StorageKey, StorageError};
use serde_json::Value;

#[derive(Clone)]
pub struct DatabaseStorage {
    pool: sqlx::PgPool,
}

impl StorageProvider for DatabaseStorage {
    type Error = StorageError;
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        sqlx::query!(
            "INSERT INTO scim_resources (tenant_id, resource_type, resource_id, data) 
             VALUES ($1, $2, $3, $4) 
             ON CONFLICT (tenant_id, resource_type, resource_id) 
             DO UPDATE SET data = $4, updated_at = NOW()",
            key.tenant_id(),
            key.resource_type(), 
            key.resource_id(),
            data
        )
        .execute(&amp;self.pool)
        .await
        .map_err(|e| StorageError::Internal(e.to_string()))?;
        
        Ok(data)
    }
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        let row = sqlx::query!(
            "SELECT data FROM scim_resources 
             WHERE tenant_id = $1 AND resource_type = $2 AND resource_id = $3",
            key.tenant_id(),
            key.resource_type(),
            key.resource_id()
        )
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| StorageError::Internal(e.to_string()))?;
        
        Ok(row.map(|r| r.data))
    }
    
    // ... implement other methods
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resourceprovider-layer"><a class="header" href="#resourceprovider-layer">ResourceProvider Layer</a></h2>
<p>The <code>ResourceProvider</code> trait handles SCIM-specific logic:</p>
<h3 id="standard-implementation"><a class="header" href="#standard-implementation">Standard Implementation</a></h3>
<p>Most applications use <code>StandardResourceProvider</code> with a pluggable storage backend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::providers::StandardResourceProvider;

let storage = DatabaseStorage::new(pool);
let provider = StandardResourceProvider::new(storage);

// The provider handles:
// - SCIM metadata generation (timestamps, ETags)
// - Resource validation
// - Tenant context processing
// - Error translation
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-implementation"><a class="header" href="#direct-implementation">Direct Implementation</a></h3>
<p>For custom SCIM behavior, implement <code>ResourceProvider</code> directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::{ResourceProvider, Resource, RequestContext};

pub struct CustomResourceProvider {
    storage: Box&lt;dyn StorageProvider&lt;Error = StorageError&gt;&gt;,
    validator: CustomValidator,
}

impl ResourceProvider for CustomResourceProvider {
    type Error = CustomError;
    
    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt; {
        // Custom validation
        self.validator.validate_resource(resource_type, &amp;data)?;
        
        // Custom metadata
        let enriched_data = self.add_custom_metadata(data, context)?;
        
        // Delegate to storage
        let key = self.build_storage_key(resource_type, context);
        let stored = self.storage.put(key, enriched_data).await?;
        
        Ok(Resource::from_json(resource_type.to_string(), stored)?)
    }
    
    // ... implement other methods
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenancy-support"><a class="header" href="#multi-tenancy-support">Multi-Tenancy Support</a></h2>
<h3 id="context-driven-isolation"><a class="header" href="#context-driven-isolation">Context-Driven Isolation</a></h3>
<p>The library provides automatic tenant isolation through <code>RequestContext</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::{RequestContext, TenantContext};

// Single-tenant operation (uses "default" tenant)
let single_context = RequestContext::with_generated_id();

// Multi-tenant operation
let tenant_context = TenantContext::new(
    "customer-123".to_string(),
    "app-456".to_string(),
);
let multi_context = RequestContext::with_tenant_generated_id(tenant_context);

// Same provider, different tenant isolation
let user1 = provider.create_resource("User", data1, &amp;single_context).await?;
let user2 = provider.create_resource("User", data2, &amp;multi_context).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="storage-layout"><a class="header" href="#storage-layout">Storage Layout</a></h3>
<p>Resources are automatically organized by tenant:</p>
<pre><code>Storage Hierarchy:
├── default/           # Single-tenant operations
│   ├── User/
│   │   ├── user-1 → {user data}
│   │   └── user-2 → {user data}
│   └── Group/
│       └── group-1 → {group data}
├── customer-123/      # Tenant-specific data
│   ├── User/
│   │   └── user-1 → {different user data}
│   └── Group/
└── customer-456/      # Another tenant
    └── User/
        └── user-1 → {yet different user data}
</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<h3 id="storage-error-types"><a class="header" href="#storage-error-types">Storage Error Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::StorageError;

pub enum StorageError {
    NotFound(String),
    Conflict(String),
    Internal(String),
}

// Usage in custom storage
impl StorageProvider for MyStorage {
    type Error = StorageError;
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        self.database.get(&amp;key)
            .await
            .map_err(|e| StorageError::Internal(e.to_string()))
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-propagation"><a class="header" href="#error-propagation">Error Propagation</a></h3>
<p>The architecture provides clean error propagation from storage to SCIM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>StorageError → ResourceProviderError → SCIM HTTP Status
NotFound     → ResourceNotFound       → 404 Not Found
Conflict     → ResourceConflict       → 409 Conflict
Internal     → InternalError          → 500 Internal Server Error
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="storage-layer-optimizations"><a class="header" href="#storage-layer-optimizations">Storage Layer Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connection pooling in storage
pub struct PooledStorage {
    pool: Arc&lt;Pool&lt;PostgresConnectionManager&gt;&gt;,
}

// Caching decorator
pub struct CachedStorage&lt;S&gt; {
    inner: S,
    cache: Arc&lt;Cache&lt;String, Value&gt;&gt;,
}

impl&lt;S: StorageProvider&gt; StorageProvider for CachedStorage&lt;S&gt; {
    type Error = S::Error;
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        let cache_key = format!("{}", key);
        
        // Check cache first
        if let Some(cached) = self.cache.get(&amp;cache_key).await {
            return Ok(Some(cached));
        }
        
        // Fallback to storage
        let result = self.inner.get(key).await?;
        
        // Cache the result
        if let Some(ref value) = result {
            self.cache.insert(cache_key, value.clone()).await;
        }
        
        Ok(result)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-layer-optimizations"><a class="header" href="#resource-layer-optimizations">Resource Layer Optimizations</a></h3>
<ul>
<li><strong>Metadata Caching</strong>: Cache computed SCIM metadata</li>
<li><strong>Validation Caching</strong>: Cache validation results for schemas</li>
<li><strong>Bulk Operations</strong>: Implement batch processing for list operations</li>
</ul>
<h2 id="testing-strategies"><a class="header" href="#testing-strategies">Testing Strategies</a></h2>
<h3 id="unit-testing-storage"><a class="header" href="#unit-testing-storage">Unit Testing Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use scim_server::storage::{StorageKey, StoragePrefix};
    use serde_json::json;
    
    #[tokio::test]
    async fn test_storage_crud() {
        let storage = MyStorage::new();
        let key = StorageKey::new("tenant1", "User", "123");
        let data = json!({"userName": "test"});
        
        // Test put
        let stored = storage.put(key.clone(), data.clone()).await.unwrap();
        assert_eq!(stored, data);
        
        // Test get
        let retrieved = storage.get(key.clone()).await.unwrap();
        assert_eq!(retrieved, Some(data));
        
        // Test delete
        let deleted = storage.delete(key.clone()).await.unwrap();
        assert!(deleted);
        
        // Verify deletion
        let after_delete = storage.get(key).await.unwrap();
        assert_eq!(after_delete, None);
    }
    
    #[tokio::test]
    async fn test_tenant_isolation() {
        let storage = MyStorage::new();
        
        let key1 = StorageKey::new("tenant1", "User", "123");
        let key2 = StorageKey::new("tenant2", "User", "123");
        
        let data1 = json!({"userName": "user1"});
        let data2 = json!({"userName": "user2"});
        
        storage.put(key1.clone(), data1.clone()).await.unwrap();
        storage.put(key2.clone(), data2.clone()).await.unwrap();
        
        // Verify isolation
        assert_eq!(storage.get(key1).await.unwrap(), Some(data1));
        assert_eq!(storage.get(key2).await.unwrap(), Some(data2));
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_full_provider_stack() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    
    let context = RequestContext::with_generated_id();
    
    // Test full SCIM workflow
    let user = provider.create_resource(
        "User",
        json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        }),
        &amp;context,
    ).await.unwrap();
    
    assert!(user.get_id().is_some());
    assert_eq!(user.get_username().unwrap(), "alice@example.com");
    
    // Test retrieval
    let retrieved = provider.get_resource(
        "User",
        user.get_id().unwrap(),
        &amp;context,
    ).await.unwrap();
    
    assert!(retrieved.is_some());
    assert_eq!(retrieved.unwrap().get_username().unwrap(), "alice@example.com");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="provider-selection"><a class="header" href="#provider-selection">Provider Selection</a></h3>
<p>Choose the right provider pattern for your use case:</p>
<ul>
<li><strong>Standard + InMemory</strong>: Development, testing, proof of concepts</li>
<li><strong>Standard + Database</strong>: Production deployments with persistence</li>
<li><strong>Standard + Custom</strong>: Specialized storage requirements (cloud, distributed)</li>
<li><strong>Custom ResourceProvider</strong>: Non-standard SCIM behavior or extensive customization</li>
</ul>
<h3 id="configuration-management-1"><a class="header" href="#configuration-management-1">Configuration Management</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
pub struct StorageConfig {
    pub storage_type: String,
    pub connection_url: Option&lt;String&gt;,
    pub max_connections: Option&lt;u32&gt;,
    pub enable_ssl: bool,
    pub cache_ttl_seconds: Option&lt;u64&gt;,
}

pub async fn create_storage_provider(config: &amp;StorageConfig) -&gt; Result&lt;Box&lt;dyn StorageProvider&lt;Error = StorageError&gt;&gt;, ConfigError&gt; {
    match config.storage_type.as_str() {
        "memory" =&gt; Ok(Box::new(InMemoryStorage::new())),
        "postgres" =&gt; {
            let pool = create_postgres_pool(&amp;config.connection_url.as_ref().unwrap()).await?;
            Ok(Box::new(PostgresStorage::new(pool)))
        }
        "redis" =&gt; {
            let client = create_redis_client(&amp;config.connection_url.as_ref().unwrap()).await?;
            Ok(Box::new(RedisStorage::new(client)))
        }
        _ =&gt; Err(ConfigError::UnsupportedStorageType(config.storage_type.clone())),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="monitoring-and-observability"><a class="header" href="#monitoring-and-observability">Monitoring and Observability</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, error, instrument};

impl&lt;S: StorageProvider&gt; StandardResourceProvider&lt;S&gt; {
    #[instrument(skip(self, data, context))]
    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt; {
        info!(
            resource_type = resource_type,
            tenant_id = context.tenant_context.as_ref().map(|t| t.tenant_id.as_str()),
            "Creating resource"
        );
        
        let result = self.inner_create_resource(resource_type, data, context).await;
        
        match &amp;result {
            Ok(resource) =&gt; {
                info!(
                    resource_type = resource_type,
                    resource_id = resource.get_id().unwrap_or("unknown"),
                    "Resource created successfully"
                );
            }
            Err(e) =&gt; {
                error!(
                    resource_type = resource_type,
                    error = %e,
                    "Failed to create resource"
                );
            }
        }
        
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="concepts/../providers/architecture.html">Provider Architecture</a> - Deep dive into the two-layer architecture</li>
<li><a href="concepts/../providers/basic.html">Basic Implementation</a> - Learn to implement storage providers</li>
<li><a href="concepts/../providers/advanced.html">Advanced Features</a> - Explore advanced provider capabilities</li>
<li><a href="concepts/./multi-tenancy.html">Multi-Tenancy</a> - Comprehensive guide to multi-tenant deployments</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="etag-concurrency-control"><a class="header" href="#etag-concurrency-control">ETag Concurrency Control</a></h1>
<p>ETag concurrency control is a critical feature for preventing lost updates in multi-client environments. This chapter explains how SCIM Server implements enterprise-grade optimistic locking using ETags to ensure data consistency.</p>
<h2 id="what-are-etags"><a class="header" href="#what-are-etags">What are ETags?</a></h2>
<p>ETags (Entity Tags) are HTTP headers that represent the version of a resource. They enable optimistic concurrency control, where multiple clients can work on the same resource without locking, but updates are validated to prevent conflicts.</p>
<h3 id="benefits-of-etag-concurrency-control"><a class="header" href="#benefits-of-etag-concurrency-control">Benefits of ETag Concurrency Control</a></h3>
<ul>
<li><strong>Prevent Lost Updates</strong>: Avoid scenarios where one client overwrites another's changes</li>
<li><strong>Optimistic Locking</strong>: No blocking - clients work independently until conflict detection</li>
<li><strong>Performance</strong>: Better than pessimistic locking for distributed systems</li>
<li><strong>Consistency</strong>: Ensure data integrity in concurrent environments</li>
<li><strong>Auditability</strong>: Track version changes for compliance and debugging</li>
</ul>
<h2 id="how-etags-work-in-scim-server"><a class="header" href="#how-etags-work-in-scim-server">How ETags Work in SCIM Server</a></h2>
<p>SCIM Server automatically manages ETags for all resources, providing seamless concurrency control:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, storage::InMemoryStorage};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = InMemoryStorage::new();
    let server = ScimServer::new(storage).await?;
    
    // Create a user - ETag is automatically generated
    let user_data = json!({
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@example.com",
        "active": true
    });

    let user = server.create_user("tenant-1", user_data).await?;
    println!("Created user with ETag: {}", user.meta.version);
    // Output: W/"1-abc123def456"
    
    Ok(())
}</code></pre></pre>
<h2 id="etag-format-and-structure"><a class="header" href="#etag-format-and-structure">ETag Format and Structure</a></h2>
<p>SCIM Server uses weak ETags following HTTP standards:</p>
<pre><code>W/"&lt;version&gt;-&lt;hash&gt;"
</code></pre>
<ul>
<li><strong>W/</strong>: Indicates a weak ETag (semantic equivalence)</li>
<li><strong>version</strong>: Monotonically increasing version number</li>
<li><strong>hash</strong>: Content hash for additional validation</li>
</ul>
<p>Examples:</p>
<ul>
<li><code>W/"1-a1b2c3d4"</code> - Version 1, first creation</li>
<li><code>W/"2-e5f6g7h8"</code> - Version 2, after first update</li>
<li><code>W/"3-i9j0k1l2"</code> - Version 3, after second update</li>
</ul>
<h2 id="basic-concurrency-control"><a class="header" href="#basic-concurrency-control">Basic Concurrency Control</a></h2>
<h3 id="reading-resources-with-etags"><a class="header" href="#reading-resources-with-etags">Reading Resources with ETags</a></h3>
<p>All read operations return the current ETag:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimServer, TenantId};

async fn read_user_with_etag(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let user = server.get_user(tenant_id, user_id).await?;
    
    println!("User: {}", user.user_name);
    println!("Current ETag: {}", user.meta.version);
    println!("Last Modified: {}", user.meta.last_modified);
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-updates-1"><a class="header" href="#conditional-updates-1">Conditional Updates</a></h3>
<p>Use ETags to ensure updates only succeed if the resource hasn't changed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimServer, ETag, ConditionalResult};

async fn safe_update_user(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
    expected_etag: &amp;ETag,
    updates: serde_json::Value,
) -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    match server.conditional_update_user(
        tenant_id,
        user_id,
        updates,
        Some(expected_etag),
    ).await? {
        ConditionalResult::Success(updated_user) =&gt; {
            println!("Update successful!");
            println!("New ETag: {}", updated_user.meta.version);
        },
        ConditionalResult::VersionMismatch { expected, current } =&gt; {
            println!("Version conflict detected!");
            println!("Expected: {}, Current: {}", expected, current);
            // Handle conflict - see conflict resolution section
        },
        ConditionalResult::NotFound =&gt; {
            println!("User no longer exists");
        }
    }
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-concurrency-patterns"><a class="header" href="#advanced-concurrency-patterns">Advanced Concurrency Patterns</a></h2>
<h3 id="optimistic-update-with-retry"><a class="header" href="#optimistic-update-with-retry">Optimistic Update with Retry</a></h3>
<p>Handle conflicts gracefully with automatic retry:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimServer, ConditionalResult, BackoffStrategy};
use tokio::time::{sleep, Duration};

async fn optimistic_update_with_retry(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
    update_fn: impl Fn(&amp;serde_json::Value) -&gt; serde_json::Value,
    max_retries: u32,
) -&gt; Result&lt;serde_json::Value, Box&lt;dyn std::error::Error&gt;&gt; {
    for attempt in 0..max_retries {
        // Get current version
        let current_user = server.get_user(tenant_id, user_id).await?;
        let current_etag = &amp;current_user.meta.version;
        
        // Apply updates
        let updated_data = update_fn(&amp;current_user);
        
        // Attempt conditional update
        match server.conditional_update_user(
            tenant_id,
            user_id,
            updated_data,
            Some(current_etag),
        ).await? {
            ConditionalResult::Success(user) =&gt; return Ok(user),
            ConditionalResult::VersionMismatch { .. } =&gt; {
                if attempt &lt; max_retries - 1 {
                    // Exponential backoff before retry
                    let delay = Duration::from_millis(100 * 2_u64.pow(attempt));
                    sleep(delay).await;
                    continue;
                } else {
                    return Err("Max retries exceeded".into());
                }
            },
            ConditionalResult::NotFound =&gt; {
                return Err("User was deleted during update".into());
            }
        }
    }
    
    unreachable!()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations-with-version-checking"><a class="header" href="#batch-operations-with-version-checking">Batch Operations with Version Checking</a></h3>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="multiple-operations-with-etags"><a class="header" href="#multiple-operations-with-etags">Multiple Operations with ETags</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ConditionalResult, VersionedResource};

async fn batch_update_with_etags(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;TenantId,
    operations: Vec&lt;(String, serde_json::Value, ETag)&gt;, // (user_id, data, expected_etag)
) -&gt; Result&lt;Vec&lt;ConditionalResult&lt;VersionedResource&gt;&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut results = Vec::new();
    let context = RequestContext::new("batch-update", None);
    
    // Process each operation individually (bulk operations not yet implemented)
    for (user_id, data, expected_etag) in operations {
        let result = provider.conditional_update(
            "User",
            &amp;user_id,
            data,
            &amp;expected_etag,
            &amp;context
        ).await?;
        
        match &amp;result {
            ConditionalResult::Success(versioned) =&gt; {
                println!("Updated {}: new version {}", user_id, versioned.version());
            },
            ConditionalResult::VersionMismatch(conflict) =&gt; {
                println!("Conflict on {}: expected {}, got {}", 
                         user_id, expected_etag, conflict.current_version);
            },
            ConditionalResult::NotFound =&gt; {
                println!("User {} not found", user_id);
            }
        }
        
        results.push(result);
    }
    
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conflict-resolution-strategies"><a class="header" href="#conflict-resolution-strategies">Conflict Resolution Strategies</a></h2>
<p>When version conflicts occur, several strategies can be employed:</p>
<h3 id="strategy-1-last-writer-wins-forced-update"><a class="header" href="#strategy-1-last-writer-wins-forced-update">Strategy 1: Last Writer Wins (Forced Update)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn force_update(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
    updates: serde_json::Value,
) -&gt; Result&lt;serde_json::Value, Box&lt;dyn std::error::Error&gt;&gt; {
    // Update without ETag check - potentially dangerous!
    let result = server.update_user(tenant_id, user_id, updates).await?;
    println!("Forced update completed");
    Ok(result)
}
<span class="boring">}</span></code></pre></pre>
<p>⚠️ <strong>Warning</strong>: Use this strategy only when you're certain it's safe to overwrite changes.</p>
<h3 id="strategy-2-merge-changes"><a class="header" href="#strategy-2-merge-changes">Strategy 2: Merge Changes</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{Value, Map};

async fn merge_and_update(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
    my_changes: serde_json::Value,
    max_attempts: u32,
) -&gt; Result&lt;serde_json::Value, Box&lt;dyn std::error::Error&gt;&gt; {
    for attempt in 0..max_attempts {
        // Get current state
        let current_user = server.get_user(tenant_id, user_id).await?;
        let current_etag = &amp;current_user.meta.version;
        
        // Merge changes (simple field-level merge)
        let merged_data = merge_user_data(&amp;current_user, &amp;my_changes)?;
        
        // Attempt update with current ETag
        match server.conditional_update_user(
            tenant_id,
            user_id,
            merged_data,
            Some(current_etag),
        ).await? {
            ConditionalResult::Success(user) =&gt; return Ok(user),
            ConditionalResult::VersionMismatch { .. } =&gt; {
                // Retry with fresh data
                continue;
            },
            ConditionalResult::NotFound =&gt; {
                return Err("User was deleted".into());
            }
        }
    }
    
    Err("Failed to merge after maximum attempts".into())
}

fn merge_user_data(
    current: &amp;serde_json::Value,
    changes: &amp;serde_json::Value,
) -&gt; Result&lt;serde_json::Value, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut merged = current.clone();
    
    if let (Some(current_obj), Some(changes_obj)) = (
        merged.as_object_mut(),
        changes.as_object()
    ) {
        for (key, value) in changes_obj {
            // Simple field replacement - you might want more sophisticated merging
            current_obj.insert(key.clone(), value.clone());
        }
    }
    
    Ok(merged)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="strategy-3-user-mediated-resolution"><a class="header" href="#strategy-3-user-mediated-resolution">Strategy 3: User-Mediated Resolution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::ConflictResolution;

async fn resolve_conflict_interactively(
    server: &amp;ScimServer,
    tenant_id: &amp;TenantId,
    user_id: &amp;str,
    my_changes: serde_json::Value,
    conflict: ConflictResolution,
) -&gt; Result&lt;serde_json::Value, Box&lt;dyn std::error::Error&gt;&gt; {
    println!("Conflict detected for user {}", user_id);
    println!("Your changes: {}", serde_json::to_string_pretty(&amp;my_changes)?);
    println!("Current state: {}", serde_json::to_string_pretty(&amp;conflict.current_state)?);
    
    // In a real application, present UI for user to choose resolution
    let resolution = prompt_user_for_resolution(&amp;my_changes, &amp;conflict.current_state)?;
    
    match resolution {
        UserChoice::KeepMine =&gt; {
            // Force update with my changes
            server.update_user(tenant_id, user_id, my_changes).await
        },
        UserChoice::KeepTheirs =&gt; {
            // Return current state, no update needed
            Ok(conflict.current_state)
        },
        UserChoice::Merge(merged_data) =&gt; {
            // Use user-provided merge
            server.update_user(tenant_id, user_id, merged_data).await
        }
    }
}

enum UserChoice {
    KeepMine,
    KeepTheirs,
    Merge(serde_json::Value),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="http-integration"><a class="header" href="#http-integration">HTTP Integration</a></h2>
<h3 id="etag-headers-in-http-responses"><a class="header" href="#etag-headers-in-http-responses">ETag Headers in HTTP Responses</a></h3>
<p>SCIM Server automatically includes ETag headers in HTTP responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::Response, http::HeaderMap};

async fn http_get_user(
    tenant_id: String,
    user_id: String,
    server: ScimServer,
) -&gt; Result&lt;Response, AppError&gt; {
    let user = server.get_user(&amp;TenantId::new(tenant_id), &amp;user_id).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("ETag", user.meta.version.to_string().parse()?);
    headers.insert("Last-Modified", user.meta.last_modified.to_rfc2822().parse()?);
    
    let response = Response::builder()
        .status(200)
        .header("Content-Type", "application/scim+json")
        .header("ETag", user.meta.version.to_string())
        .body(serde_json::to_string(&amp;user)?)
        .unwrap();
    
    Ok(response)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-requests-with-if-match"><a class="header" href="#conditional-requests-with-if-match">Conditional Requests with If-Match</a></h3>
<p>Handle conditional updates via HTTP If-Match headers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{extract::HeaderMap, http::StatusCode};

async fn http_update_user(
    tenant_id: String,
    user_id: String,
    headers: HeaderMap,
    Json(updates): Json&lt;serde_json::Value&gt;,
    server: ScimServer,
) -&gt; Result&lt;Response, AppError&gt; {
    let if_match = headers.get("If-Match")
        .and_then(|v| v.to_str().ok())
        .map(ETag::parse)
        .transpose()?;
    
    match server.conditional_update_user(
        &amp;TenantId::new(tenant_id),
        &amp;user_id,
        updates,
        if_match.as_ref(),
    ).await? {
        ConditionalResult::Success(user) =&gt; {
            Ok(Response::builder()
                .status(200)
                .header("ETag", user.meta.version.to_string())
                .body(serde_json::to_string(&amp;user)?)
                .unwrap())
        },
        ConditionalResult::VersionMismatch { expected, current } =&gt; {
            Ok(Response::builder()
                .status(StatusCode::PRECONDITION_FAILED)
                .header("ETag", current.to_string())
                .body(format!("Version mismatch: expected {}, current {}", expected, current))
                .unwrap())
        },
        ConditionalResult::NotFound =&gt; {
            Ok(Response::builder()
                .status(StatusCode::NOT_FOUND)
                .body("User not found")
                .unwrap())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-2"><a class="header" href="#performance-considerations-2">Performance Considerations</a></h2>
<h3 id="etag-storage-optimization"><a class="header" href="#etag-storage-optimization">ETag Storage Optimization</a></h3>
<p>ETags are stored efficiently to minimize overhead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{ETagStorage, CompressionLevel};

// Configure ETag storage for optimal performance
let etag_config = ETagStorage::builder()
    .compression(CompressionLevel::Fast)
    .cache_size_mb(256)
    .cleanup_interval_hours(24)
    .build();

let storage = InMemoryStorage::new()
    .with_etag_config(etag_config);
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-etag-operations"><a class="header" href="#batch-etag-operations">Batch ETag Operations</a></h3>
<p>Efficiently handle ETags in bulk operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pre-fetch ETags for bulk validation
let user_ids = vec!["user1", "user2", "user3"];
let etags = server.get_etags(&amp;tenant_id, &amp;user_ids).await?;

// Validate all ETags before proceeding with bulk operation
for (user_id, expected_etag) in expected_etags {
    let current_etag = etags.get(user_id).ok_or("User not found")?;
    if current_etag != &amp;expected_etag {
        return Err(format!("Version mismatch for user {}", user_id).into());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ai-integration-and-etags"><a class="header" href="#ai-integration-and-etags">AI Integration and ETags</a></h2>
<p>ETags work seamlessly with AI tools via MCP:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::mcp::{McpTool, ConflictResolutionStrategy};

// AI can handle conflicts intelligently
let ai_conflict_resolver = McpTool::new("claude-3-5-sonnet")
    .with_conflict_strategy(ConflictResolutionStrategy::SmartMerge)
    .with_retry_limit(3);

// AI assistant automatically handles ETag conflicts
let result = ai_conflict_resolver.update_user_safe(
    &amp;tenant_id,
    &amp;user_id,
    json!({
        "active": false,
        "lastLogin": "2024-01-15T10:30:00Z"
    })
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="always-use-etags-for-updates"><a class="header" href="#always-use-etags-for-updates">Always Use ETags for Updates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Always check ETags for updates
let user = server.get_user(&amp;tenant_id, &amp;user_id).await?;
let current_etag = &amp;user.meta.version;
let result = server.conditional_update_user(&amp;tenant_id, &amp;user_id, updates, Some(current_etag)).await?;

// Avoid: Blind updates without version checking
let result = server.update_user(&amp;tenant_id, &amp;user_id, updates).await?; // Risky!
<span class="boring">}</span></code></pre></pre>
<h3 id="handle-all-conflict-cases"><a class="header" href="#handle-all-conflict-cases">Handle All Conflict Cases</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match server.conditional_update_user(&amp;tenant_id, &amp;user_id, updates, Some(&amp;etag)).await? {
    ConditionalResult::Success(user) =&gt; {
        // Success case
    },
    ConditionalResult::VersionMismatch { expected, current } =&gt; {
        // Always handle conflicts
    },
    ConditionalResult::NotFound =&gt; {
        // Handle deletion case
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="monitor-conflict-rates"><a class="header" href="#monitor-conflict-rates">Monitor Conflict Rates</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::ConflictMetrics;

// Track conflict rates to identify problematic access patterns
let metrics = server.get_conflict_metrics(&amp;tenant_id).await?;
if metrics.conflict_rate_percent &gt; 5.0 {
    log::warn!("High conflict rate detected: {}%", metrics.conflict_rate_percent);
    // Consider implementing additional coordination mechanisms
}
<span class="boring">}</span></code></pre></pre>
<p>ETag concurrency control in SCIM Server provides robust protection against data loss while maintaining high performance in concurrent environments. By understanding and properly implementing these patterns, you can build reliable multi-client systems that handle conflicts gracefully.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resource-types"><a class="header" href="#custom-resource-types">Custom Resource Types</a></h1>
<p>This tutorial shows you how to extend the SCIM Server with custom resource types beyond the standard User and Group resources. You'll learn to define schemas, implement type-safe resources, and integrate them with your SCIM server.</p>
<h2 id="why-custom-resources"><a class="header" href="#why-custom-resources">Why Custom Resources?</a></h2>
<p>While SCIM's User and Group resources cover most identity scenarios, enterprise environments often need additional resource types:</p>
<ul>
<li><strong>Projects</strong>: Development projects with team assignments</li>
<li><strong>Roles</strong>: Fine-grained permission sets</li>
<li><strong>Devices</strong>: Mobile devices and laptops assigned to users</li>
<li><strong>Applications</strong>: SaaS applications and their configurations</li>
<li><strong>Departments</strong>: Organizational units with hierarchies</li>
<li><strong>Locations</strong>: Office locations and room assignments</li>
</ul>
<p>Custom resources let you manage these entities with the same SCIM operations and guarantees as built-in resources.</p>
<h2 id="quick-start-example"><a class="header" href="#quick-start-example">Quick Start Example</a></h2>
<p>Let's start with a simple Device resource:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimResource, ResourceMeta, Schema, Attribute};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
    pub id: String,
    pub schemas: Vec&lt;String&gt;,
    pub meta: ResourceMeta,
    pub external_id: Option&lt;String&gt;,
    
    // Custom attributes
    pub serial_number: String,
    pub device_type: DeviceType,
    pub manufacturer: String,
    pub model: String,
    pub assigned_to: Option&lt;String&gt;,  // User ID
    pub status: DeviceStatus,
    pub purchase_date: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub warranty_expires: Option&lt;DateTime&lt;Utc&gt;&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceType {
    Laptop,
    Desktop,
    Tablet,
    Phone,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceStatus {
    Available,
    Assigned,
    InRepair,
    Retired,
}

impl ScimResource for Device {
    fn id(&amp;self) -&gt; &amp;str {
        &amp;self.id
    }
    
    fn schemas(&amp;self) -&gt; &amp;[String] {
        &amp;self.schemas
    }
    
    fn meta(&amp;self) -&gt; &amp;ResourceMeta {
        &amp;self.meta
    }
    
    fn external_id(&amp;self) -&gt; Option&lt;&amp;str&gt; {
        self.external_id.as_deref()
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-1-define-your-resource-schema"><a class="header" href="#step-1-define-your-resource-schema">Step 1: Define Your Resource Schema</a></h2>
<p>Every custom resource needs a schema that defines its structure and validation rules:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{Schema, Attribute, AttributeType, Mutability, Returned, Uniqueness};

pub fn device_schema() -&gt; Schema {
    Schema::builder()
        .id("urn:company:params:scim:schemas:core:2.0:Device")
        .name("Device")
        .description("IT Device Resource")
        .attribute(
            Attribute::builder()
                .name("serialNumber")
                .type_(AttributeType::String)
                .mutability(Mutability::Immutable)  // Can't change after creation
                .returned(Returned::Default)
                .uniqueness(Uniqueness::Server)     // Must be unique
                .required(true)
                .case_exact(true)
                .description("Device serial number")
                .build()
        )
        .attribute(
            Attribute::builder()
                .name("deviceType")
                .type_(AttributeType::String)
                .mutability(Mutability::ReadWrite)
                .returned(Returned::Default)
                .required(true)
                .canonical_values(vec![
                    "Laptop".to_string(),
                    "Desktop".to_string(),
                    "Tablet".to_string(),
                    "Phone".to_string(),
                ])
                .description("Type of device")
                .build()
        )
        .attribute(
            Attribute::builder()
                .name("assignedTo")
                .type_(AttributeType::Reference)
                .mutability(Mutability::ReadWrite)
                .returned(Returned::Default)
                .reference_types(vec!["User".to_string()])
                .description("User this device is assigned to")
                .build()
        )
        .attribute(
            Attribute::builder()
                .name("status")
                .type_(AttributeType::String)
                .mutability(Mutability::ReadWrite)
                .returned(Returned::Default)
                .required(true)
                .canonical_values(vec![
                    "Available".to_string(),
                    "Assigned".to_string(),
                    "InRepair".to_string(),
                    "Retired".to_string(),
                ])
                .build()
        )
        .build()
        .unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-2-implement-the-builder-pattern"><a class="header" href="#step-2-implement-the-builder-pattern">Step 2: Implement the Builder Pattern</a></h2>
<p>Provide a convenient builder for creating resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Device {
    pub fn builder() -&gt; DeviceBuilder {
        DeviceBuilder::new()
    }
}

pub struct DeviceBuilder {
    device: Device,
}

impl DeviceBuilder {
    pub fn new() -&gt; Self {
        Self {
            device: Device {
                id: uuid::Uuid::new_v4().to_string(),
                schemas: vec!["urn:company:params:scim:schemas:core:2.0:Device".to_string()],
                meta: ResourceMeta::new("Device"),
                external_id: None,
                serial_number: String::new(),
                device_type: DeviceType::Laptop,
                manufacturer: String::new(),
                model: String::new(),
                assigned_to: None,
                status: DeviceStatus::Available,
                purchase_date: None,
                warranty_expires: None,
            },
        }
    }
    
    pub fn serial_number(mut self, serial: impl Into&lt;String&gt;) -&gt; Self {
        self.device.serial_number = serial.into();
        self
    }
    
    pub fn device_type(mut self, device_type: DeviceType) -&gt; Self {
        self.device.device_type = device_type;
        self
    }
    
    pub fn manufacturer(mut self, manufacturer: impl Into&lt;String&gt;) -&gt; Self {
        self.device.manufacturer = manufacturer.into();
        self
    }
    
    pub fn model(mut self, model: impl Into&lt;String&gt;) -&gt; Self {
        self.device.model = model.into();
        self
    }
    
    pub fn assigned_to(mut self, user_id: Option&lt;impl Into&lt;String&gt;&gt;) -&gt; Self {
        self.device.assigned_to = user_id.map(|id| id.into());
        self
    }
    
    pub fn status(mut self, status: DeviceStatus) -&gt; Self {
        self.device.status = status;
        self
    }
    
    pub fn purchase_date(mut self, date: DateTime&lt;Utc&gt;) -&gt; Self {
        self.device.purchase_date = Some(date);
        self
    }
    
    pub fn warranty_expires(mut self, date: DateTime&lt;Utc&gt;) -&gt; Self {
        self.device.warranty_expires = Some(date);
        self
    }
    
    pub fn build(self) -&gt; Result&lt;Device, ValidationError&gt; {
        // Validate required fields
        if self.device.serial_number.is_empty() {
            return Err(ValidationError::RequiredField("serialNumber"));
        }
        
        if self.device.manufacturer.is_empty() {
            return Err(ValidationError::RequiredField("manufacturer"));
        }
        
        if self.device.model.is_empty() {
            return Err(ValidationError::RequiredField("model"));
        }
        
        Ok(self.device)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-extend-your-provider"><a class="header" href="#step-3-extend-your-provider">Step 3: Extend Your Provider</a></h2>
<p>Add support for your custom resource to your storage provider:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;
use scim_server::{Provider, ProviderError, ListOptions, ListResponse};

#[async_trait]
pub trait DeviceProvider: Provider {
    async fn create_device(&amp;self, tenant_id: &amp;str, device: Device) -&gt; Result&lt;Device, ProviderError&gt;;
    async fn get_device(&amp;self, tenant_id: &amp;str, device_id: &amp;str) -&gt; Result&lt;Option&lt;Device&gt;, ProviderError&gt;;
    async fn update_device(&amp;self, tenant_id: &amp;str, device: Device) -&gt; Result&lt;Device, ProviderError&gt;;
    async fn delete_device(&amp;self, tenant_id: &amp;str, device_id: &amp;str) -&gt; Result&lt;(), ProviderError&gt;;
    async fn list_devices(&amp;self, tenant_id: &amp;str, options: &amp;ListOptions) -&gt; Result&lt;ListResponse&lt;Device&gt;, ProviderError&gt;;
}

// Implement for InMemoryProvider
#[async_trait]
impl DeviceProvider for InMemoryProvider {
    async fn create_device(&amp;self, tenant_id: &amp;str, mut device: Device) -&gt; Result&lt;Device, ProviderError&gt; {
        // Update metadata
        device.meta.created = Utc::now();
        device.meta.last_modified = device.meta.created;
        device.meta.version = "1".to_string();
        
        let mut devices = self.devices.write().await;
        let tenant_devices = devices.entry(tenant_id.to_string()).or_insert_with(HashMap::new);
        
        // Check for duplicate serial number
        for existing_device in tenant_devices.values() {
            if existing_device.serial_number == device.serial_number {
                return Err(ProviderError::Conflict(
                    format!("Device with serial number {} already exists", device.serial_number)
                ));
            }
        }
        
        tenant_devices.insert(device.id.clone(), device.clone());
        Ok(device)
    }
    
    async fn get_device(&amp;self, tenant_id: &amp;str, device_id: &amp;str) -&gt; Result&lt;Option&lt;Device&gt;, ProviderError&gt; {
        let devices = self.devices.read().await;
        let result = devices
            .get(tenant_id)
            .and_then(|tenant_devices| tenant_devices.get(device_id))
            .cloned();
        Ok(result)
    }
    
    async fn update_device(&amp;self, tenant_id: &amp;str, mut device: Device) -&gt; Result&lt;Device, ProviderError&gt; {
        let mut devices = self.devices.write().await;
        let tenant_devices = devices.entry(tenant_id.to_string()).or_insert_with(HashMap::new);
        
        // Check if device exists
        let existing = tenant_devices.get(&amp;device.id)
            .ok_or_else(|| ProviderError::NotFound {
                resource_type: "Device".to_string(),
                id: device.id.clone(),
            })?;
        
        // Version check for concurrency control
        if existing.meta.version != device.meta.version {
            return Err(ProviderError::VersionConflict {
                current_version: existing.meta.version.clone(),
                provided_version: device.meta.version.clone(),
            });
        }
        
        // Update metadata
        device.meta.last_modified = Utc::now();
        device.meta.version = (existing.meta.version.parse::&lt;u64&gt;().unwrap_or(0) + 1).to_string();
        
        tenant_devices.insert(device.id.clone(), device.clone());
        Ok(device)
    }
    
    async fn delete_device(&amp;self, tenant_id: &amp;str, device_id: &amp;str) -&gt; Result&lt;(), ProviderError&gt; {
        let mut devices = self.devices.write().await;
        let tenant_devices = devices.entry(tenant_id.to_string()).or_insert_with(HashMap::new);
        
        tenant_devices.remove(device_id)
            .ok_or_else(|| ProviderError::NotFound {
                resource_type: "Device".to_string(),
                id: device_id.to_string(),
            })?;
        
        Ok(())
    }
    
    async fn list_devices(&amp;self, tenant_id: &amp;str, options: &amp;ListOptions) -&gt; Result&lt;ListResponse&lt;Device&gt;, ProviderError&gt; {
        let devices = self.devices.read().await;
        let tenant_devices = devices.get(tenant_id).map(|d| d.values().cloned().collect::&lt;Vec&lt;_&gt;&gt;())
            .unwrap_or_default();
        
        // Apply filtering
        let filtered: Vec&lt;Device&gt; = if let Some(ref filter) = options.filter {
            tenant_devices.into_iter()
                .filter(|device| self.matches_filter(device, filter))
                .collect()
        } else {
            tenant_devices
        };
        
        // Apply sorting
        let mut sorted = filtered;
        if let Some(ref sort_by) = options.sort_by {
            sorted.sort_by(|a, b| self.compare_devices(a, b, sort_by, &amp;options.sort_order));
        }
        
        // Apply pagination
        let total_results = sorted.len();
        let start_index = options.start_index.unwrap_or(1).max(1) - 1;
        let count = options.count.unwrap_or(100).min(1000);
        
        let page: Vec&lt;Device&gt; = sorted
            .into_iter()
            .skip(start_index)
            .take(count)
            .collect();
        
        Ok(ListResponse {
            schemas: vec!["urn:ietf:params:scim:api:messages:2.0:ListResponse".to_string()],
            total_results,
            start_index: start_index + 1,
            items_per_page: page.len(),
            resources: page,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-add-http-endpoints"><a class="header" href="#step-4-add-http-endpoints">Step 4: Add HTTP Endpoints</a></h2>
<p>Create HTTP endpoints for your custom resource:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde_json::Value;

pub fn device_routes() -&gt; Router&lt;AppState&gt; {
    Router::new()
        .route("/Devices", get(list_devices).post(create_device))
        .route("/Devices/:id", get(get_device).put(update_device).delete(delete_device))
}

async fn create_device(
    State(state): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Json(payload): Json&lt;Value&gt;,
) -&gt; Result&lt;Json&lt;Device&gt;, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    // Parse the JSON into a Device
    let device: Device = serde_json::from_value(payload)
        .map_err(|e| (StatusCode::BAD_REQUEST, Json(ScimError::invalid_syntax(e.to_string()))))?;
    
    // Create the device
    let created_device = state.provider.create_device(&amp;tenant_id, device).await
        .map_err(|e| match e {
            ProviderError::Conflict(msg) =&gt; (StatusCode::CONFLICT, Json(ScimError::uniqueness(msg))),
            ProviderError::ValidationError { message } =&gt; (StatusCode::BAD_REQUEST, Json(ScimError::invalid_value(message))),
            _ =&gt; (StatusCode::INTERNAL_SERVER_ERROR, Json(ScimError::internal_error())),
        })?;
    
    Ok(Json(created_device))
}

async fn get_device(
    State(state): State&lt;AppState&gt;,
    Path((tenant_id, device_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;Json&lt;Device&gt;, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    let device = state.provider.get_device(&amp;tenant_id, &amp;device_id).await
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, Json(ScimError::internal_error())))?
        .ok_or_else(|| (StatusCode::NOT_FOUND, Json(ScimError::not_found("Device", &amp;device_id))))?;
    
    Ok(Json(device))
}

async fn update_device(
    State(state): State&lt;AppState&gt;,
    Path((tenant_id, device_id)): Path&lt;(String, String)&gt;,
    Json(mut payload): Json&lt;Device&gt;,
) -&gt; Result&lt;Json&lt;Device&gt;, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    // Ensure the ID matches the path
    payload.id = device_id;
    
    let updated_device = state.provider.update_device(&amp;tenant_id, payload).await
        .map_err(|e| match e {
            ProviderError::NotFound { .. } =&gt; (StatusCode::NOT_FOUND, Json(ScimError::not_found("Device", &amp;payload.id))),
            ProviderError::VersionConflict { .. } =&gt; (StatusCode::PRECONDITION_FAILED, Json(ScimError::version_conflict())),
            _ =&gt; (StatusCode::INTERNAL_SERVER_ERROR, Json(ScimError::internal_error())),
        })?;
    
    Ok(Json(updated_device))
}

async fn delete_device(
    State(state): State&lt;AppState&gt;,
    Path((tenant_id, device_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;StatusCode, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    state.provider.delete_device(&amp;tenant_id, &amp;device_id).await
        .map_err(|e| match e {
            ProviderError::NotFound { .. } =&gt; (StatusCode::NOT_FOUND, Json(ScimError::not_found("Device", &amp;device_id))),
            _ =&gt; (StatusCode::INTERNAL_SERVER_ERROR, Json(ScimError::internal_error())),
        })?;
    
    Ok(StatusCode::NO_CONTENT)
}

async fn list_devices(
    State(state): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Query(params): Query&lt;ListParameters&gt;,
) -&gt; Result&lt;Json&lt;ListResponse&lt;Device&gt;&gt;, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    let options = ListOptions::from_query_params(params);
    
    let response = state.provider.list_devices(&amp;tenant_id, &amp;options).await
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, Json(ScimError::internal_error())))?;
    
    Ok(Json(response))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-5-register-your-resource"><a class="header" href="#step-5-register-your-resource">Step 5: Register Your Resource</a></h2>
<p>Register your custom resource and schema with the SCIM server:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, SchemaRegistry};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create provider
    let provider = InMemoryProvider::new();
    
    // Create schema registry and register schemas
    let mut schema_registry = SchemaRegistry::new();
    schema_registry.register(CoreSchemas::user());
    schema_registry.register(CoreSchemas::group());
    schema_registry.register(device_schema());  // Register our custom schema
    
    // Create SCIM server
    let scim_server = ScimServer::builder()
        .provider(provider)
        .schema_registry(schema_registry)
        .build();
    
    // Create HTTP router
    let app = Router::new()
        .nest("/scim/v2/:tenant_id", user_routes())
        .nest("/scim/v2/:tenant_id", group_routes())
        .nest("/scim/v2/:tenant_id", device_routes())  // Add device routes
        .route("/scim/v2/:tenant_id/Schemas", get(get_schemas))
        .route("/scim/v2/:tenant_id/ResourceTypes", get(get_resource_types))
        .with_state(AppState { provider: scim_server });
    
    // Start server
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("SCIM server running on http://localhost:3000");
    axum::serve(listener, app).await?;
    
    Ok(())
}</code></pre></pre>
<h2 id="step-6-add-resource-type-configuration"><a class="header" href="#step-6-add-resource-type-configuration">Step 6: Add Resource Type Configuration</a></h2>
<p>Expose your custom resource through the <code>/ResourceTypes</code> endpoint:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn get_resource_types(
    State(state): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
) -&gt; Json&lt;ListResponse&lt;ResourceType&gt;&gt; {
    let resource_types = vec![
        ResourceType {
            schemas: vec!["urn:ietf:params:scim:schemas:core:2.0:ResourceType".to_string()],
            id: "User".to_string(),
            name: "User".to_string(),
            endpoint: "/Users".to_string(),
            description: Some("User Account".to_string()),
            schema: "urn:ietf:params:scim:schemas:core:2.0:User".to_string(),
            schema_extensions: vec![
                SchemaExtension {
                    schema: "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User".to_string(),
                    required: false,
                }
            ],
            meta: ResourceMeta::new("ResourceType"),
        },
        ResourceType {
            schemas: vec!["urn:ietf:params:scim:schemas:core:2.0:ResourceType".to_string()],
            id: "Group".to_string(),
            name: "Group".to_string(),
            endpoint: "/Groups".to_string(),
            description: Some("Group".to_string()),
            schema: "urn:ietf:params:scim:schemas:core:2.0:Group".to_string(),
            schema_extensions: vec![],
            meta: ResourceMeta::new("ResourceType"),
        },
        ResourceType {
            schemas: vec!["urn:ietf:params:scim:schemas:core:2.0:ResourceType".to_string()],
            id: "Device".to_string(),
            name: "Device".to_string(),
            endpoint: "/Devices".to_string(),
            description: Some("IT Device".to_string()),
            schema: "urn:company:params:scim:schemas:core:2.0:Device".to_string(),
            schema_extensions: vec![],
            meta: ResourceMeta::new("ResourceType"),
        },
    ];
    
    Json(ListResponse {
        schemas: vec!["urn:ietf:params:scim:api:messages:2.0:ListResponse".to_string()],
        total_results: resource_types.len(),
        start_index: 1,
        items_per_page: resource_types.len(),
        resources: resource_types,
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="advanced-examples"><a class="header" href="#advanced-examples">Advanced Examples</a></h2>
<h3 id="complex-resource-with-relationships"><a class="header" href="#complex-resource-with-relationships">Complex Resource with Relationships</a></h3>
<p>Here's a more complex example - a Project resource that references users and groups:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Project {
    pub id: String,
    pub schemas: Vec&lt;String&gt;,
    pub meta: ResourceMeta,
    pub external_id: Option&lt;String&gt;,
    
    // Basic attributes
    pub name: String,
    pub description: Option&lt;String&gt;,
    pub status: ProjectStatus,
    pub priority: Priority,
    
    // Relationships
    pub owner: Reference,
    pub team_members: Vec&lt;Reference&gt;,
    pub stakeholder_groups: Vec&lt;Reference&gt;,
    
    // Dates
    pub start_date: DateTime&lt;Utc&gt;,
    pub end_date: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub created_date: DateTime&lt;Utc&gt;,
    
    // Business attributes
    pub budget: Option&lt;Money&gt;,
    pub tags: Vec&lt;String&gt;,
    pub custom_fields: HashMap&lt;String, Value&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reference {
    pub value: String,
    #[serde(rename = "$ref")]
    pub ref_: Option&lt;String&gt;,
    #[serde(rename = "type")]
    pub type_: Option&lt;String&gt;,
    pub display: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Money {
    pub amount: f64,
    pub currency: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ProjectStatus {
    Planning,
    Active,
    OnHold,
    Completed,
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Priority {
    Low,
    Medium,
    High,
    Critical,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-with-validation-rules"><a class="header" href="#resource-with-validation-rules">Resource with Validation Rules</a></h3>
<p>Add complex validation logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Project {
    pub fn validate(&amp;self) -&gt; Result&lt;(), ValidationError&gt; {
        // Name validation
        if self.name.trim().is_empty() {
            return Err(ValidationError::RequiredField("name"));
        }
        
        if self.name.len() &gt; 100 {
            return Err(ValidationError::ValueTooLong("name", 100));
        }
        
        // Date validation
        if let Some(end_date) = self.end_date {
            if end_date &lt;= self.start_date {
                return Err(ValidationError::InvalidDateRange);
            }
        }
        
        // Budget validation
        if let Some(ref budget) = self.budget {
            if budget.amount &lt; 0.0 {
                return Err(ValidationError::InvalidValue("budget.amount", "must be non-negative"));
            }
        }
        
        // Team size validation
        if self.team_members.len() &gt; 50 {
            return Err(ValidationError::ValueTooLong("teamMembers", 50));
        }
        
        // Custom business rules
        if self.status == ProjectStatus::Active &amp;&amp; self.team_members.is_empty() {
            return Err(ValidationError::BusinessRule("Active projects must have team members"));
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-your-custom-resource"><a class="header" href="#testing-your-custom-resource">Testing Your Custom Resource</a></h2>
<p>Create comprehensive tests for your custom resource:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;
    
    #[tokio::test]
    async fn test_device_lifecycle() {
        let provider = InMemoryProvider::new();
        let tenant_id = "test-tenant";
        
        // Create device
        let device = Device::builder()
            .serial_number("ABC123")
            .device_type(DeviceType::Laptop)
            .manufacturer("Dell")
            .model("XPS 13")
            .status(DeviceStatus::Available)
            .build()
            .unwrap();
        
        let created = provider.create_device(tenant_id, device.clone()).await.unwrap();
        assert_eq!(created.serial_number, "ABC123");
        assert_eq!(created.status, DeviceStatus::Available);
        
        // Assign device to user
        let mut assigned = created.clone();
        assigned.assigned_to = Some("user-123".to_string());
        assigned.status = DeviceStatus::Assigned;
        
        let updated = provider.update_device(tenant_id, assigned).await.unwrap();
        assert_eq!(updated.assigned_to, Some("user-123".to_string()));
        assert_eq!(updated.status, DeviceStatus::Assigned);
        
        // List devices
        let list_response = provider.list_devices(tenant_id, &amp;ListOptions::default()).await.unwrap();
        assert_eq!(list_response.total_results, 1);
        assert_eq!(list_response.resources[0].id, created.id);
        
        // Delete device
        provider.delete_device(tenant_id, &amp;created.id).await.unwrap();
        let deleted = provider.get_device(tenant_id, &amp;created.id).await.unwrap();
        assert!(deleted.is_none());
    }
    
    #[tokio::test]
    async fn test_device_validation() {
        // Test missing serial number
        let result = Device::builder()
            .manufacturer("Dell")
            .model("XPS 13")
            .build();
        
        assert!(result.is_err());
        
        // Test valid device
        let result = Device::builder()
            .serial_number("ABC123")
            .manufacturer("Dell")
            .model("XPS 13")
            .build();
        
        assert!(result.is_ok());
    }
    
    #[tokio::test]
    async fn test_device_filtering() {
        let provider = InMemoryProvider::new();
        let tenant_id = "test-tenant";
        
        // Create test devices
        let devices = vec![
            Device::builder().serial_number("LAP001").device_type(DeviceType::Laptop).build().unwrap(),
            Device::builder().serial_number("PHN001").device_type(DeviceType::Phone).build().unwrap(),
            Device::builder().serial_number("LAP002").device_type(DeviceType::Laptop).build().unwrap(),
        ];
        
        for device in devices {
            provider.create_device(tenant_id, device).await.unwrap();
        }
        
        // List all devices and filter in memory (database filtering not yet implemented)
        let options = ListOptions::default();
        let response = provider.list_devices(tenant_id, &amp;options).await.unwrap();
        
        // Filter by device type in memory
        let laptops: Vec&lt;_&gt; = response.resources.into_iter()
            .filter(|device| device.device_type == DeviceType::Laptop)
            .collect();
        
        assert_eq!(laptops.len(), 2);
        for device in laptops {
            assert_eq!(device.device_type, DeviceType::Laptop);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="schema-design"><a class="header" href="#schema-design">Schema Design</a></h3>
<p><strong>Use meaningful schema IDs</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Good: Company-specific with versioning
"urn:company:params:scim:schemas:core:2.0:Device"

// Bad: Generic or unversioned
"device"
"urn:scim:schemas:device"
<span class="boring">}</span></code></pre></pre>
<p><strong>Define appropriate constraints</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.attribute(
    Attribute::builder()
        .name("serialNumber")
        .mutability(Mutability::Immutable)  // Can't change after creation
        .uniqueness(Uniqueness::Server)     // Must be unique across tenant
        .required(true)                     // Must be provided
        .case_exact(true)                   // Exact case matching
        .build()
)
<span class="boring">}</span></code></pre></pre>
<h3 id="type-safety-1"><a class="header" href="#type-safety-1">Type Safety</a></h3>
<p><strong>Use enums for constrained values</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceStatus {
    Available,
    Assigned,
    InRepair,
    Retired,
}

// Instead of just String
<span class="boring">}</span></code></pre></pre>
<p><strong>Implement strong validation</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl DeviceBuilder {
    pub fn serial_number(mut self, serial: impl Into&lt;String&gt;) -&gt; Self {
        let serial = serial.into();
        
        // Validate format (example: must be alphanumeric, 6-20 chars)
        if !serial.chars().all(|c| c.is_alphanumeric()) {
            panic!("Serial number must be alphanumeric");
        }
        
        if serial.len() &lt; 6 || serial.len() &gt; 20 {
            panic!("Serial number must be 6-20 characters");
        }
        
        self.device.serial_number = serial;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h3>
<p><strong>Provide meaningful error messages</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum DeviceError {
    #[error("Serial number {0} is already in use")]
    DuplicateSerial(String),
    
    #[error("Device {device_id} is currently assigned to user {user_id}")]
    DeviceInUse { device_id: String, user_id: String },
    
    #[error("Cannot assign retired device {0}")]
    RetiredDevice(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p><strong>Add appropriate indexes for your provider</strong>:</p>
<pre><code class="language-sql">-- For database providers
CREATE INDEX idx_devices_serial_number ON devices(tenant_id, serial_number);
CREATE INDEX idx_devices_assigned_to ON devices(tenant_id, assigned_to);
CREATE INDEX idx_devices_status ON devices(tenant_id, status);
</code></pre>
<p><strong>Implement efficient querying</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For now, implement pagination and in-memory filtering
impl DatabaseProvider {
    async fn list_devices_paginated(&amp;self, tenant_id: &amp;str, start_index: Option&lt;usize&gt;, count: Option&lt;usize&gt;) -&gt; Result&lt;Vec&lt;Device&gt;, ProviderError&gt; {
        let skip = start_index.unwrap_or(1).saturating_sub(1);
        let limit = count.unwrap_or(50).min(1000); // Cap at 1000 for performance
        
        // Database query with pagination
        let devices = sqlx::query_as!(
            Device,
            "SELECT * FROM devices WHERE tenant_id = $1 ORDER BY created_at LIMIT $2 OFFSET $3",
            tenant_id, limit as i64, skip as i64
        )
        .fetch_all(&amp;self.pool)
        .await?;
        
        Ok(devices)
    }
    
    // Helper method for common filtering patterns
    async fn find_devices_by_type(&amp;self, tenant_id: &amp;str, device_type: &amp;DeviceType) -&gt; Result&lt;Vec&lt;Device&gt;, ProviderError&gt; {
        let devices = sqlx::query_as!(
            Device,
            "SELECT * FROM devices WHERE tenant_id = $1 AND device_type = $2",
            tenant_id, device_type.to_string()
        )
        .fetch_all(&amp;self.pool)
        .await?;
        
        Ok(devices)
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authentication-setup"><a class="header" href="#authentication-setup">Authentication Setup</a></h1>
<p>This tutorial shows you how to implement authentication and authorization for your SCIM Server, covering OAuth 2.0, API keys, and custom authentication schemes.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>SCIM servers typically operate in enterprise environments where security is paramount. The SCIM Server library provides flexible authentication mechanisms that can integrate with existing identity providers and security infrastructure.</p>
<h3 id="common-authentication-patterns"><a class="header" href="#common-authentication-patterns">Common Authentication Patterns</a></h3>
<ol>
<li><strong>OAuth 2.0 Bearer Tokens</strong> - Industry standard for API authentication</li>
<li><strong>API Keys</strong> - Simple shared secrets for service-to-service communication</li>
<li><strong>JWT Tokens</strong> - Self-contained tokens with embedded claims</li>
<li><strong>Basic Authentication</strong> - Username/password for development and testing</li>
<li><strong>Custom Authentication</strong> - Integration with proprietary systems</li>
</ol>
<h2 id="quick-start-basic-authentication"><a class="header" href="#quick-start-basic-authentication">Quick Start: Basic Authentication</a></h2>
<p>Let's start with a simple development setup using basic authentication:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, InMemoryProvider};
use axum::{
    extract::{Request, State},
    http::{StatusCode, HeaderMap},
    middleware::{self, Next},
    response::Response,
    Router,
};
use base64::{Engine as _, engine::general_purpose};

#[derive(Clone)]
struct AppState {
    scim_server: ScimServer,
    admin_credentials: (String, String), // (username, password)
}

async fn basic_auth_middleware(
    State(state): State&lt;AppState&gt;,
    headers: HeaderMap,
    request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Get Authorization header
    let auth_header = headers
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    // Check Basic auth format
    if !auth_header.starts_with("Basic ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // Decode credentials
    let encoded = &amp;auth_header[6..];
    let decoded = general_purpose::STANDARD
        .decode(encoded)
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    let credentials = String::from_utf8(decoded)
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    let mut parts = credentials.splitn(2, ':');
    let username = parts.next().ok_or(StatusCode::UNAUTHORIZED)?;
    let password = parts.next().ok_or(StatusCode::UNAUTHORIZED)?;

    // Validate credentials
    if username == state.admin_credentials.0 &amp;&amp; password == state.admin_credentials.1 {
        Ok(next.run(request).await)
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder()
        .provider(provider)
        .build();

    let state = AppState {
        scim_server,
        admin_credentials: ("admin".to_string(), "secret123".to_string()),
    };

    let app = Router::new()
        .nest("/scim/v2/:tenant_id", scim_routes())
        .layer(middleware::from_fn_with_state(state.clone(), basic_auth_middleware))
        .with_state(state);

    println!("SCIM server with basic auth running on http://localhost:3000");
    println!("Use credentials: admin:secret123");
    
    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, app).await?;
    Ok(())
}</code></pre></pre>
<h2 id="oauth-20-bearer-token-authentication"><a class="header" href="#oauth-20-bearer-token-authentication">OAuth 2.0 Bearer Token Authentication</a></h2>
<p>For production deployments, OAuth 2.0 is the recommended approach:</p>
<h3 id="jwt-token-validation"><a class="header" href="#jwt-token-validation">JWT Token Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use jsonwebtoken::{decode, DecodingKey, Validation, Algorithm};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
struct Claims {
    sub: String,    // Subject (user ID)
    exp: usize,     // Expiration time
    iat: usize,     // Issued at
    iss: String,    // Issuer
    aud: String,    // Audience
    scope: String,  // OAuth scopes
    tenant_id: Option&lt;String&gt;, // Tenant context
}

async fn oauth_middleware(
    State(state): State&lt;AppState&gt;,
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Extract Bearer token
    let auth_header = headers
        .get("Authorization")
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    if !auth_header.starts_with("Bearer ") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    let token = &amp;auth_header[7..];

    // Validate JWT token
    let decoding_key = DecodingKey::from_secret(state.jwt_secret.as_ref());
    let validation = Validation::new(Algorithm::HS256);
    
    let token_data = decode::&lt;Claims&gt;(token, &amp;decoding_key, &amp;validation)
        .map_err(|_| StatusCode::UNAUTHORIZED)?;

    // Check token expiration
    let now = chrono::Utc::now().timestamp() as usize;
    if token_data.claims.exp &lt; now {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // Check required scopes
    let scopes: Vec&lt;&amp;str&gt; = token_data.claims.scope.split(' ').collect();
    if !scopes.contains(&amp;"scim:read") &amp;&amp; !scopes.contains(&amp;"scim:write") {
        return Err(StatusCode::FORBIDDEN);
    }

    // Add user context to request
    request.extensions_mut().insert(UserContext {
        user_id: token_data.claims.sub,
        tenant_id: token_data.claims.tenant_id,
        scopes,
    });

    Ok(next.run(request).await)
}

#[derive(Clone)]
struct UserContext {
    user_id: String,
    tenant_id: Option&lt;String&gt;,
    scopes: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-with-external-oauth-providers"><a class="header" href="#integration-with-external-oauth-providers">Integration with External OAuth Providers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;
use serde_json::Value;

#[derive(Clone)]
struct OAuthConfig {
    introspection_url: String,
    client_id: String,
    client_secret: String,
}

async fn validate_oauth_token(
    config: &amp;OAuthConfig,
    token: &amp;str,
) -&gt; Result&lt;Claims, String&gt; {
    let client = Client::new();
    
    // Call OAuth provider's introspection endpoint
    let response = client
        .post(&amp;config.introspection_url)
        .basic_auth(&amp;config.client_id, Some(&amp;config.client_secret))
        .form(&amp;[("token", token)])
        .send()
        .await
        .map_err(|e| format!("Failed to validate token: {}", e))?;

    let introspection: Value = response
        .json()
        .await
        .map_err(|e| format!("Failed to parse response: {}", e))?;

    // Check if token is active
    if !introspection["active"].as_bool().unwrap_or(false) {
        return Err("Token is not active".to_string());
    }

    // Extract claims
    Ok(Claims {
        sub: introspection["sub"].as_str().unwrap_or("").to_string(),
        exp: introspection["exp"].as_u64().unwrap_or(0) as usize,
        iat: introspection["iat"].as_u64().unwrap_or(0) as usize,
        iss: introspection["iss"].as_str().unwrap_or("").to_string(),
        aud: introspection["aud"].as_str().unwrap_or("").to_string(),
        scope: introspection["scope"].as_str().unwrap_or("").to_string(),
        tenant_id: introspection["tenant_id"].as_str().map(|s| s.to_string()),
    })
}
<span class="boring">}</span></code></pre></pre>
<h2 id="api-key-authentication"><a class="header" href="#api-key-authentication">API Key Authentication</a></h2>
<p>For service-to-service communication, API keys provide a simpler alternative:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sha2::{Sha256, Digest};
use std::collections::HashMap;

#[derive(Clone)]
struct ApiKeyStore {
    keys: HashMap&lt;String, ApiKeyInfo&gt;,
}

#[derive(Clone)]
struct ApiKeyInfo {
    name: String,
    tenant_id: String,
    permissions: Vec&lt;String&gt;,
    created_at: chrono::DateTime&lt;chrono::Utc&gt;,
    last_used: Option&lt;chrono::DateTime&lt;chrono::Utc&gt;&gt;,
}

impl ApiKeyStore {
    fn new() -&gt; Self {
        let mut keys = HashMap::new();
        
        // Example API key (in production, store these securely)
        keys.insert(
            "sk_test_1234567890abcdef".to_string(),
            ApiKeyInfo {
                name: "Development Key".to_string(),
                tenant_id: "tenant-1".to_string(),
                permissions: vec!["scim:read".to_string(), "scim:write".to_string()],
                created_at: chrono::Utc::now(),
                last_used: None,
            },
        );
        
        Self { keys }
    }
    
    async fn validate_key(&amp;mut self, api_key: &amp;str) -&gt; Option&lt;&amp;ApiKeyInfo&gt; {
        if let Some(key_info) = self.keys.get_mut(api_key) {
            key_info.last_used = Some(chrono::Utc::now());
            Some(key_info)
        } else {
            None
        }
    }
}

async fn api_key_middleware(
    State(mut state): State&lt;AppState&gt;,
    headers: HeaderMap,
    mut request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Extract API key from header
    let api_key = headers
        .get("X-API-Key")
        .or_else(|| headers.get("Authorization").and_then(|h| {
            h.to_str().ok().and_then(|s| {
                if s.starts_with("Bearer ") {
                    Some(&amp;s[7..])
                } else {
                    None
                }
            })
        }))
        .and_then(|h| h.to_str().ok())
        .ok_or(StatusCode::UNAUTHORIZED)?;

    // Validate API key
    let key_info = state.api_keys.validate_key(api_key).await
        .ok_or(StatusCode::UNAUTHORIZED)?;

    // Add context to request
    request.extensions_mut().insert(ApiKeyContext {
        tenant_id: key_info.tenant_id.clone(),
        permissions: key_info.permissions.clone(),
        key_name: key_info.name.clone(),
    });

    Ok(next.run(request).await)
}

#[derive(Clone)]
struct ApiKeyContext {
    tenant_id: String,
    permissions: Vec&lt;String&gt;,
    key_name: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenant-authentication"><a class="header" href="#multi-tenant-authentication">Multi-Tenant Authentication</a></h2>
<p>Handle different authentication schemes per tenant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum AuthScheme {
    OAuth {
        jwks_url: String,
        audience: String,
        issuer: String,
    },
    ApiKey {
        keys: HashMap&lt;String, String&gt;, // key -&gt; permissions
    },
    Basic {
        username: String,
        password_hash: String,
    },
}

#[derive(Clone)]
struct TenantAuthConfig {
    tenant_configs: HashMap&lt;String, AuthScheme&gt;,
}

impl TenantAuthConfig {
    async fn authenticate(
        &amp;self,
        tenant_id: &amp;str,
        headers: &amp;HeaderMap,
    ) -&gt; Result&lt;AuthContext, StatusCode&gt; {
        let auth_scheme = self.tenant_configs
            .get(tenant_id)
            .ok_or(StatusCode::NOT_FOUND)?;

        match auth_scheme {
            AuthScheme::OAuth { jwks_url, audience, issuer } =&gt; {
                self.validate_oauth(headers, jwks_url, audience, issuer).await
            },
            AuthScheme::ApiKey { keys } =&gt; {
                self.validate_api_key(headers, keys).await
            },
            AuthScheme::Basic { username, password_hash } =&gt; {
                self.validate_basic(headers, username, password_hash).await
            },
        }
    }
    
    async fn validate_oauth(
        &amp;self,
        headers: &amp;HeaderMap,
        jwks_url: &amp;str,
        audience: &amp;str,
        issuer: &amp;str,
    ) -&gt; Result&lt;AuthContext, StatusCode&gt; {
        // OAuth validation logic
        todo!("Implement OAuth validation")
    }
    
    async fn validate_api_key(
        &amp;self,
        headers: &amp;HeaderMap,
        keys: &amp;HashMap&lt;String, String&gt;,
    ) -&gt; Result&lt;AuthContext, StatusCode&gt; {
        // API key validation logic
        todo!("Implement API key validation")
    }
    
    async fn validate_basic(
        &amp;self,
        headers: &amp;HeaderMap,
        username: &amp;str,
        password_hash: &amp;str,
    ) -&gt; Result&lt;AuthContext, StatusCode&gt; {
        // Basic auth validation logic
        todo!("Implement basic auth validation")
    }
}

#[derive(Clone)]
struct AuthContext {
    tenant_id: String,
    user_id: Option&lt;String&gt;,
    permissions: Vec&lt;String&gt;,
    auth_type: String,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="authorization-and-permissions"><a class="header" href="#authorization-and-permissions">Authorization and Permissions</a></h2>
<p>Implement fine-grained access control:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
struct PermissionChecker {
    // Define permission patterns
}

impl PermissionChecker {
    fn can_access_resource(
        &amp;self,
        context: &amp;AuthContext,
        resource_type: &amp;str,
        operation: &amp;str,
        resource_id: Option&lt;&amp;str&gt;,
    ) -&gt; bool {
        // Check if user has required permissions
        let required_permission = format!("scim:{}:{}", resource_type, operation);
        
        if context.permissions.contains(&amp;required_permission) {
            return true;
        }
        
        // Check wildcard permissions
        let wildcard_permission = format!("scim:{}:*", resource_type);
        if context.permissions.contains(&amp;wildcard_permission) {
            return true;
        }
        
        // Check admin permission
        if context.permissions.contains(&amp;"scim:admin".to_string()) {
            return true;
        }
        
        // Resource-specific checks
        if let Some(id) = resource_id {
            let specific_permission = format!("scim:{}:{}:{}", resource_type, operation, id);
            if context.permissions.contains(&amp;specific_permission) {
                return true;
            }
        }
        
        false
    }
}

// Usage in handlers
async fn get_user_handler(
    State(state): State&lt;AppState&gt;,
    Extension(auth_context): Extension&lt;AuthContext&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;Json&lt;ScimUser&gt;, StatusCode&gt; {
    // Check permissions
    if !state.permissions.can_access_resource(
        &amp;auth_context,
        "users",
        "read",
        Some(&amp;user_id),
    ) {
        return Err(StatusCode::FORBIDDEN);
    }
    
    // Proceed with operation
    let user = state.scim_server
        .get_user(&amp;tenant_id, &amp;user_id)
        .await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?
        .ok_or(StatusCode::NOT_FOUND)?;
    
    Ok(Json(user))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="production-security-considerations"><a class="header" href="#production-security-considerations">Production Security Considerations</a></h2>
<h3 id="rate-limiting"><a class="header" href="#rate-limiting">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tower_governor::{GovernorLayer, governor::GovernorConfig};
use std::time::Duration;

// Add rate limiting middleware
let governor_conf = GovernorConfig::default()
    .per_second(10)
    .burst_size(20)
    .period(Duration::from_secs(60));

let app = Router::new()
    .nest("/scim/v2", scim_routes())
    .layer(GovernorLayer::new(&amp;governor_conf))
    .layer(middleware::from_fn(auth_middleware));
<span class="boring">}</span></code></pre></pre>
<h3 id="request-logging-and-audit"><a class="header" href="#request-logging-and-audit">Request Logging and Audit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn audit_middleware(
    Extension(auth_context): Extension&lt;AuthContext&gt;,
    request: Request,
    next: Next,
) -&gt; Response {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let start_time = std::time::Instant::now();
    
    let response = next.run(request).await;
    
    let duration = start_time.elapsed();
    let status = response.status();
    
    // Log the request
    tracing::info!(
        user_id = auth_context.user_id,
        tenant_id = auth_context.tenant_id,
        method = %method,
        uri = %uri,
        status = %status,
        duration_ms = duration.as_millis(),
        "SCIM API request"
    );
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="https-and-security-headers"><a class="header" href="#https-and-security-headers">HTTPS and Security Headers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tower_http::{
    set_header::SetResponseHeaderLayer,
    cors::CorsLayer,
};

let app = Router::new()
    .nest("/scim/v2", scim_routes())
    .layer(SetResponseHeaderLayer::overriding(
        http::header::STRICT_TRANSPORT_SECURITY,
        http::HeaderValue::from_static("max-age=31536000; includeSubDomains"),
    ))
    .layer(SetResponseHeaderLayer::overriding(
        http::header::X_CONTENT_TYPE_OPTIONS,
        http::HeaderValue::from_static("nosniff"),
    ))
    .layer(SetResponseHeaderLayer::overriding(
        http::header::X_FRAME_OPTIONS,
        http::HeaderValue::from_static("DENY"),
    ))
    .layer(CorsLayer::permissive()) // Configure CORS appropriately
    .layer(middleware::from_fn(auth_middleware));
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-authentication"><a class="header" href="#testing-authentication">Testing Authentication</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use axum_test::TestServer;
    
    #[tokio::test]
    async fn test_basic_auth_success() {
        let app = create_test_app().await;
        let server = TestServer::new(app).unwrap();
        
        let response = server
            .get("/scim/v2/tenant-1/Users")
            .add_header("Authorization", "Basic YWRtaW46c2VjcmV0MTIz") // admin:secret123
            .await;
        
        assert_eq!(response.status_code(), 200);
    }
    
    #[tokio::test]
    async fn test_basic_auth_failure() {
        let app = create_test_app().await;
        let server = TestServer::new(app).unwrap();
        
        let response = server
            .get("/scim/v2/tenant-1/Users")
            .add_header("Authorization", "Basic aW52YWxpZA==") // invalid
            .await;
        
        assert_eq!(response.status_code(), 401);
    }
    
    #[tokio::test]
    async fn test_api_key_auth() {
        let app = create_test_app().await;
        let server = TestServer::new(app).unwrap();
        
        let response = server
            .get("/scim/v2/tenant-1/Users")
            .add_header("X-API-Key", "sk_test_1234567890abcdef")
            .await;
        
        assert_eq!(response.status_code(), 200);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>Create a configuration system for different environments:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(serde::Deserialize)]
struct AuthConfig {
    #[serde(default)]
    basic_auth: Option&lt;BasicAuthConfig&gt;,
    #[serde(default)]
    oauth: Option&lt;OAuthConfig&gt;,
    #[serde(default)]
    api_keys: Option&lt;ApiKeyConfig&gt;,
}

#[derive(serde::Deserialize)]
struct BasicAuthConfig {
    username: String,
    password: String, // In production, use password hash
}

#[derive(serde::Deserialize)]
struct OAuthConfig {
    jwks_url: String,
    audience: String,
    issuer: String,
}

#[derive(serde::Deserialize)]
struct ApiKeyConfig {
    keys_file: String, // Path to API keys file
}

// Load from environment or config file
fn load_auth_config() -&gt; AuthConfig {
    let config_str = std::fs::read_to_string("auth_config.toml")
        .expect("Failed to read auth config");
    
    toml::from_str(&amp;config_str)
        .expect("Failed to parse auth config")
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive authentication setup provides enterprise-grade security for your SCIM Server while maintaining flexibility for different deployment scenarios.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="tutorials/../advanced/custom-validation.html">Implement custom validation</a> for additional security</li>
<li><a href="tutorials/../advanced/monitoring.html">Set up monitoring</a> for security events</li>
<li><a href="tutorials/../advanced/production-deployment.html">Configure production deployment</a> with proper security</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-tenant-deployment"><a class="header" href="#multi-tenant-deployment">Multi-Tenant Deployment</a></h1>
<p>This tutorial shows how to deploy and configure SCIM Server for multi-tenant environments, where you need to isolate data and operations between different organizations or customers.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>Multi-tenancy in SCIM Server provides complete isolation between different organizations while sharing the same infrastructure. Each tenant gets:</p>
<ul>
<li><strong>Complete data isolation</strong> - No tenant can access another's data</li>
<li><strong>Independent configuration</strong> - Per-tenant authentication and settings</li>
<li><strong>Separate namespaces</strong> - Tenant-specific resource URLs</li>
<li><strong>Isolated operations</strong> - All SCIM operations are tenant-scoped</li>
</ul>
<h2 id="basic-multi-tenant-setup-1"><a class="header" href="#basic-multi-tenant-setup-1">Basic Multi-Tenant Setup</a></h2>
<h3 id="single-instance-multiple-tenants"><a class="header" href="#single-instance-multiple-tenants">Single Instance, Multiple Tenants</a></h3>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use axum::{
    extract::{Path, State},
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use serde_json::{json, Value};
use std::collections::HashMap;
use std::sync::Arc;
use uuid::Uuid;

// Multi-tenant configuration
#[derive(Debug, Clone)]
struct TenantConfig {
    name: String,
    max_users: Option&lt;usize&gt;,
    features: Vec&lt;String&gt;,
    auth_config: AuthConfig,
}

#[derive(Debug, Clone)]
enum AuthConfig {
    OAuth { jwks_url: String, audience: String },
    ApiKey { keys: Vec&lt;String&gt; },
    Basic { username: String, password: String },
}

#[derive(Clone)]
struct MultiTenantApp {
    provider: Arc&lt;StandardResourceProvider&lt;InMemoryStorage&gt;&gt;,
    tenant_configs: HashMap&lt;String, TenantConfig&gt;,
}

impl MultiTenantApp {
    fn new() -&gt; Self {
        // Single storage provider with tenant isolation via RequestContext
        let storage = InMemoryStorage::new();
        let provider = Arc::new(StandardResourceProvider::new(storage));

        // Configure tenants
        let mut tenant_configs = HashMap::new();
        
        tenant_configs.insert("company-a".to_string(), TenantConfig {
            name: "Company A".to_string(),
            auth_config: AuthConfig::OAuth {
                jwks_url: "https://company-a.auth0.com/.well-known/jwks.json".to_string(),
                audience: "scim-api".to_string(),
            },
            max_users: Some(1000),
            features: vec!["bulk_operations".to_string(), "custom_schemas".to_string()],
        });

        tenant_configs.insert("company-b".to_string(), TenantConfig {
            name: "Company B".to_string(),
            auth_config: AuthConfig::ApiKey {
                keys: vec!["sk_live_abc123".to_string()],
            },
            max_users: Some(500),
            features: vec!["basic_operations".to_string()],
        });

        Self {
            provider,
            tenant_configs,
        }
    }

    // Create tenant-aware RequestContext
    fn create_context(&amp;self, tenant_id: &amp;str, operation: &amp;str) -&gt; RequestContext {
        RequestContext::new(format!("tenant-{}-{}-{}", tenant_id, operation, Uuid::new_v4()))
    }

    // Validate tenant exists and is authorized
    fn validate_tenant(&amp;self, tenant_id: &amp;str) -&gt; Result&lt;&amp;TenantConfig, String&gt; {
        self.tenant_configs
            .get(tenant_id)
            .ok_or_else(|| format!("Tenant '{}' not found", tenant_id))
    }
}

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = MultiTenantApp::new();

    let router = Router::new()
        // Multi-tenant endpoints: /tenants/{tenant_id}/scim/v2/*
        .route("/tenants/:tenant_id/scim/v2/Users", 
               post(create_user).get(list_users))
        .route("/tenants/:tenant_id/scim/v2/Users/:user_id", 
               get(get_user).put(update_user).delete(delete_user))
        .route("/tenants/:tenant_id/scim/v2/Groups", 
               post(create_group).get(list_groups))
        .route("/tenants/:tenant_id/scim/v2/Groups/:group_id", 
               get(get_group).put(update_group).delete(delete_group))
        // Tenant management endpoints
        .route("/tenants", get(list_tenants))
        .route("/tenants/:tenant_id", get(get_tenant_info))
        .with_state(app);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Multi-tenant SCIM server running on http://localhost:3000");
    println!("Example endpoints:");
    println!("  POST http://localhost:3000/tenants/company-a/scim/v2/Users");
    println!("  GET  http://localhost:3000/tenants/company-b/scim/v2/Users");
    axum::serve(listener, router).await?;
    
    Ok(())
}</code></pre></pre>
<h3 id="tenant-specific-endpoints"><a class="header" href="#tenant-specific-endpoints">Tenant-Specific Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::http::StatusCode;

// Error type for multi-tenant operations
#[derive(Debug)]
enum MultiTenantError {
    TenantNotFound(String),
    TenantLimitExceeded(String),
    FeatureNotEnabled(String),
    InternalError(String),
}

impl axum::response::IntoResponse for MultiTenantError {
    fn into_response(self) -&gt; axum::response::Response {
        let (status, message) = match self {
            MultiTenantError::TenantNotFound(tenant) =&gt; 
                (StatusCode::NOT_FOUND, format!("Tenant '{}' not found", tenant)),
            MultiTenantError::TenantLimitExceeded(limit) =&gt; 
                (StatusCode::FORBIDDEN, format!("Tenant limit exceeded: {}", limit)),
            MultiTenantError::FeatureNotEnabled(feature) =&gt; 
                (StatusCode::FORBIDDEN, format!("Feature '{}' not enabled for tenant", feature)),
            MultiTenantError::InternalError(msg) =&gt; 
                (StatusCode::INTERNAL_SERVER_ERROR, msg),
        };

        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": status.as_u16().to_string(),
            "detail": message
        });

        (status, Json(body)).into_response()
    }
}

// Create user with tenant isolation
async fn create_user(
    State(app): State&lt;MultiTenantApp&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    // Validate tenant exists and get config
    let tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Check tenant limits
    if let Some(max_users) = tenant_config.max_users {
        let context = app.create_context(&amp;tenant_id, "count-users");
        let current_users = app.provider.list_resources("User", None, &amp;context).await
            .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;
        
        if current_users.len() &gt;= max_users {
            return Err(MultiTenantError::TenantLimitExceeded(max_users.to_string()));
        }
    }

    // Create tenant-scoped context
    let context = app.create_context(&amp;tenant_id, "create-user");
    
    // Create user with tenant isolation
    let user = app.provider.create_resource("User", user_data, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(Json(user.data))
}

// Get user with tenant isolation
async fn get_user(
    State(app): State&lt;MultiTenantApp&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    // Validate tenant
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Create tenant-scoped context
    let context = app.create_context(&amp;tenant_id, "get-user");
    
    // Get user (automatically isolated by tenant context)
    let user = app.provider.get_resource("User", &amp;user_id, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(Json(user.data))
}

// List users with tenant isolation
async fn list_users(
    State(app): State&lt;MultiTenantApp&gt;,
    Path(tenant_id): Path&lt;String&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    // Validate tenant
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Create tenant-scoped context
    let context = app.create_context(&amp;tenant_id, "list-users");
    
    // List users (automatically isolated by tenant context)
    let users = app.provider.list_resources("User", None, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": users.len(),
        "startIndex": 1,
        "itemsPerPage": users.len(),
        "Resources": users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });

    Ok(Json(response))
}

// Update user with tenant isolation
async fn update_user(
    State(app): State&lt;MultiTenantApp&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    // Validate tenant
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Create tenant-scoped context
    let context = app.create_context(&amp;tenant_id, "update-user");
    
    // Update user (automatically isolated by tenant context)
    let user = app.provider.update_resource("User", &amp;user_id, user_data, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(Json(user.data))
}

// Delete user with tenant isolation
async fn delete_user(
    State(app): State&lt;MultiTenantApp&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;StatusCode, MultiTenantError&gt; {
    // Validate tenant
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Create tenant-scoped context
    let context = app.create_context(&amp;tenant_id, "delete-user");
    
    // Delete user (automatically isolated by tenant context)
    app.provider.delete_resource("User", &amp;user_id, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(StatusCode::NO_CONTENT)
}

// Example tenant-scoped URLs:
// POST /tenants/company-a/scim/v2/Users
// GET  /tenants/company-a/scim/v2/Users/123
// POST /tenants/company-b/scim/v2/Users
// GET  /tenants/company-b/scim/v2/Users/456
<span class="boring">}</span></code></pre></pre>
<h3 id="group-operations-1"><a class="header" href="#group-operations-1">Group Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Group operations follow the same patterns
async fn create_group(
    State(app): State&lt;MultiTenantApp&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Json(group_data): Json&lt;Value&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    let context = app.create_context(&amp;tenant_id, "create-group");
    let group = app.provider.create_resource("Group", group_data, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(Json(group.data))
}

async fn list_groups(
    State(app): State&lt;MultiTenantApp&gt;,
    Path(tenant_id): Path&lt;String&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    let _tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    let context = app.create_context(&amp;tenant_id, "list-groups");
    let groups = app.provider.list_resources("Group", None, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": groups.len(),
        "startIndex": 1,
        "itemsPerPage": groups.len(),
        "Resources": groups.iter().map(|g| &amp;g.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });

    Ok(Json(response))
}

// Additional group operations (get_group, update_group, delete_group) follow same pattern...
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-management-endpoints"><a class="header" href="#tenant-management-endpoints">Tenant Management Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// List all tenants
async fn list_tenants(
    State(app): State&lt;MultiTenantApp&gt;,
) -&gt; Json&lt;Value&gt; {
    let tenants: Vec&lt;_&gt; = app.tenant_configs.iter()
        .map(|(id, config)| json!({
            "id": id,
            "name": config.name,
            "maxUsers": config.max_users,
            "features": config.features
        }))
        .collect();

    Json(json!({
        "tenants": tenants,
        "total": tenants.len()
    }))
}

// Get tenant information
async fn get_tenant_info(
    State(app): State&lt;MultiTenantApp&gt;,
    Path(tenant_id): Path&lt;String&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, MultiTenantError&gt; {
    let tenant_config = app.validate_tenant(&amp;tenant_id)
        .map_err(|_| MultiTenantError::TenantNotFound(tenant_id.clone()))?;

    // Get usage statistics
    let context = app.create_context(&amp;tenant_id, "get-stats");
    let users = app.provider.list_resources("User", None, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;
    let groups = app.provider.list_resources("Group", None, &amp;context).await
        .map_err(|e| MultiTenantError::InternalError(e.to_string()))?;

    Ok(Json(json!({
        "id": tenant_id,
        "name": tenant_config.name,
        "maxUsers": tenant_config.max_users,
        "features": tenant_config.features,
        "usage": {
            "users": users.len(),
            "groups": groups.len()
        }
    })))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="data-isolation-strategies"><a class="header" href="#data-isolation-strategies">Data Isolation Strategies</a></h2>
<h3 id="application-level-isolation-current-implementation"><a class="header" href="#application-level-isolation-current-implementation">Application-Level Isolation (Current Implementation)</a></h3>
<p>The StandardResourceProvider provides tenant isolation through the RequestContext:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::StorageKey;

// The storage layer automatically handles tenant isolation
impl MultiTenantApp {
    fn create_context(&amp;self, tenant_id: &amp;str, operation: &amp;str) -&gt; RequestContext {
        // The tenant ID becomes part of the request context
        // This ensures all storage operations are tenant-scoped
        RequestContext::new(format!("tenant-{}-{}-{}", tenant_id, operation, Uuid::new_v4()))
    }
}

// Example: How storage keys work with tenants
// For tenant "company-a" creating user "123":
let storage_key = StorageKey::new("company-a", "User", "123");
// Results in storage path: "company-a/User/123"

// This provides automatic isolation:
// - company-a can only access "company-a/User/*" 
// - company-b can only access "company-b/User/*"
// - No cross-tenant data access possible
<span class="boring">}</span></code></pre></pre>
<h3 id="database-level-isolation-advanced"><a class="header" href="#database-level-isolation-advanced">Database-Level Isolation (Advanced)</a></h3>
<p>For production deployments with database storage, implement row-level security:</p>
<pre><code class="language-sql">-- Example PostgreSQL schema with tenant isolation
CREATE TABLE scim_resources (
    tenant_id VARCHAR(255) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id VARCHAR(255) NOT NULL,
    data JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    version VARCHAR(255) NOT NULL,
    PRIMARY KEY (tenant_id, resource_type, resource_id)
);

-- Enable Row-Level Security
ALTER TABLE scim_resources ENABLE ROW LEVEL SECURITY;

-- Create tenant isolation policy
CREATE POLICY tenant_isolation ON scim_resources
    USING (tenant_id = current_setting('app.current_tenant_id'));

-- Function to set tenant context
CREATE OR REPLACE FUNCTION set_tenant_context(p_tenant_id text)
RETURNS void AS $$
BEGIN
    PERFORM set_config('app.current_tenant_id', p_tenant_id, true);
END;
$$ LANGUAGE plpgsql;
</code></pre>
<h3 id="custom-storage-provider-for-database"><a class="header" href="#custom-storage-provider-for-database">Custom Storage Provider for Database</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{StorageProvider, StorageKey, StoragePrefix};
use sqlx::PgPool;
use serde_json::Value;

#[derive(Clone)]
pub struct PostgresStorageProvider {
    pool: PgPool,
}

#[async_trait]
impl StorageProvider for PostgresStorageProvider {
    type Error = sqlx::Error;

    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        // Extract tenant from storage key
        let tenant_id = key.tenant_id();
        
        // Set tenant context for RLS
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(tenant_id)
            .execute(&amp;self.pool)
            .await?;

        // Insert with automatic tenant filtering
        let stored_data = sqlx::query_scalar!(
            "INSERT INTO scim_resources (tenant_id, resource_type, resource_id, data, version)
             VALUES ($1, $2, $3, $4, gen_random_uuid()::text)
             RETURNING data",
            tenant_id,
            key.resource_type(),
            key.resource_id(),
            data
        )
        .fetch_one(&amp;self.pool)
        .await?;

        Ok(stored_data)
    }

    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        // Set tenant context
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(key.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        // Query with automatic tenant filtering
        let data = sqlx::query_scalar!(
            "SELECT data FROM scim_resources 
             WHERE resource_type = $1 AND resource_id = $2",
            key.resource_type(),
            key.resource_id()
        )
        .fetch_optional(&amp;self.pool)
        .await?;

        Ok(data)
    }

    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(key.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        let result = sqlx::query!(
            "DELETE FROM scim_resources 
             WHERE resource_type = $1 AND resource_id = $2",
            key.resource_type(),
            key.resource_id()
        )
        .execute(&amp;self.pool)
        .await?;

        Ok(result.rows_affected() &gt; 0)
    }

    async fn list(
        &amp;self,
        prefix: StoragePrefix,
        offset: usize,
        limit: usize,
    ) -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt; {
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(prefix.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        let rows = sqlx::query!(
            "SELECT resource_id, data FROM scim_resources 
             WHERE resource_type = $1 
             ORDER BY resource_id 
             LIMIT $2 OFFSET $3",
            prefix.resource_type(),
            limit as i64,
            offset as i64
        )
        .fetch_all(&amp;self.pool)
        .await?;

        let results = rows.into_iter()
            .map(|row| {
                let key = StorageKey::new(
                    prefix.tenant_id(),
                    prefix.resource_type(),
                    &amp;row.resource_id
                );
                (key, row.data)
            })
            .collect();

        Ok(results)
    }

    async fn find_by_attribute(
        &amp;self,
        prefix: StoragePrefix,
        attribute: &amp;str,
        value: &amp;str,
    ) -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt; {
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(prefix.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        // Use JSONB operators for efficient attribute search
        let rows = sqlx::query!(
            "SELECT resource_id, data FROM scim_resources 
             WHERE resource_type = $1 AND data -&gt;&gt; $2 = $3",
            prefix.resource_type(),
            attribute,
            value
        )
        .fetch_all(&amp;self.pool)
        .await?;

        let results = rows.into_iter()
            .map(|row| {
                let key = StorageKey::new(
                    prefix.tenant_id(),
                    prefix.resource_type(),
                    &amp;row.resource_id
                );
                (key, row.data)
            })
            .collect();

        Ok(results)
    }

    async fn exists(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(key.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        let exists = sqlx::query_scalar!(
            "SELECT EXISTS(SELECT 1 FROM scim_resources 
             WHERE resource_type = $1 AND resource_id = $2)",
            key.resource_type(),
            key.resource_id()
        )
        .fetch_one(&amp;self.pool)
        .await?;

        Ok(exists.unwrap_or(false))
    }

    async fn count(&amp;self, prefix: StoragePrefix) -&gt; Result&lt;usize, Self::Error&gt; {
        sqlx::query("SELECT set_tenant_context($1)")
            .bind(prefix.tenant_id())
            .execute(&amp;self.pool)
            .await?;

        let count = sqlx::query_scalar!(
            "SELECT COUNT(*) FROM scim_resources WHERE resource_type = $1",
            prefix.resource_type()
        )
        .fetch_one(&amp;self.pool)
        .await?;

        Ok(count.unwrap_or(0) as usize)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deployment-patterns"><a class="header" href="#deployment-patterns">Deployment Patterns</a></h2>
<h3 id="single-instance-multiple-tenants-1"><a class="header" href="#single-instance-multiple-tenants-1">Single Instance, Multiple Tenants</a></h3>
<p>The most common pattern for multi-tenant SCIM deployments:</p>
<pre><pre class="playground"><code class="language-rust">// Production multi-tenant setup
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Load tenant configurations from environment/config file
    let tenant_configs = load_tenant_configs_from_env()?;
    
    // Create storage provider (could be database, Redis, etc.)
    let storage = create_storage_provider().await?;
    let provider = Arc::new(StandardResourceProvider::new(storage));
    
    let app = MultiTenantApp {
        provider,
        tenant_configs,
    };

    // Production server with proper middleware
    let router = Router::new()
        .route("/tenants/:tenant_id/scim/v2/Users", 
               post(create_user).get(list_users))
        .route("/tenants/:tenant_id/scim/v2/Users/:user_id", 
               get(get_user).put(update_user).delete(delete_user))
        .route("/tenants/:tenant_id/scim/v2/Groups", 
               post(create_group).get(list_groups))
        .route("/tenants/:tenant_id/scim/v2/Groups/:group_id", 
               get(get_group).put(update_group).delete(delete_group))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(TimeoutLayer::new(Duration::from_secs(30)))
                .layer(CompressionLayer::new())
                .layer(cors_layer())
        )
        .with_state(app);

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    println!("Multi-tenant SCIM server running on port 3000");
    axum::serve(listener, router).await?;
    
    Ok(())
}

fn load_tenant_configs_from_env() -&gt; Result&lt;HashMap&lt;String, TenantConfig&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let mut configs = HashMap::new();
    
    // Load from environment variables or config files
    for tenant_id in std::env::var("TENANT_IDS")?.split(',') {
        let config = TenantConfig {
            name: std::env::var(format!("TENANT_{}_NAME", tenant_id.to_uppercase()))?,
            max_users: std::env::var(format!("TENANT_{}_MAX_USERS", tenant_id.to_uppercase()))
                .ok().and_then(|s| s.parse().ok()),
            features: std::env::var(format!("TENANT_{}_FEATURES", tenant_id.to_uppercase()))
                .unwrap_or_default()
                .split(',')
                .map(|s| s.to_string())
                .collect(),
            auth_config: load_auth_config_for_tenant(tenant_id)?,
        };
        configs.insert(tenant_id.to_string(), config);
    }
    
    Ok(configs)
}</code></pre></pre>
<h3 id="separate-instances-per-tenant"><a class="header" href="#separate-instances-per-tenant">Separate Instances Per Tenant</a></h3>
<p>For high-isolation requirements:</p>
<pre><pre class="playground"><code class="language-rust">// Per-tenant instance deployment
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let tenant_id = std::env::var("TENANT_ID")
        .expect("TENANT_ID environment variable required");
    
    // Dedicated storage for this tenant
    let storage_url = format!("postgresql://user:pass@localhost/scim_{}", tenant_id);
    let storage = PostgresStorageProvider::new(&amp;storage_url).await?;
    let provider = StandardResourceProvider::new(storage);
    
    // Single-tenant routes (no tenant_id in path)
    let router = Router::new()
        .route("/scim/v2/Users", post(create_user).get(list_users))
        .route("/scim/v2/Users/:user_id", 
               get(get_user).put(update_user).delete(delete_user))
        .route("/scim/v2/Groups", post(create_group).get(list_groups))
        .with_state(SingleTenantApp { provider, tenant_id });

    let listener = tokio::net::TcpListener::bind("0.0.0.0:3000").await?;
    axum::serve(listener, router).await?;
    
    Ok(())
}

#[derive(Clone)]
struct SingleTenantApp {
    provider: StandardResourceProvider&lt;PostgresStorageProvider&gt;,
    tenant_id: String,
}

impl SingleTenantApp {
    fn create_context(&amp;self, operation: &amp;str) -&gt; RequestContext {
        RequestContext::new(format!("{}-{}-{}", self.tenant_id, operation, Uuid::new_v4()))
    }
}</code></pre></pre>
<h2 id="configuration-management-2"><a class="header" href="#configuration-management-2">Configuration Management</a></h2>
<h3 id="environment-based-configuration"><a class="header" href="#environment-based-configuration">Environment-Based Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct TenantConfig {
    pub name: String,
    pub max_users: Option&lt;usize&gt;,
    pub features: Vec&lt;String&gt;,
    pub auth_config: AuthConfig,
}

// Load from environment variables
fn load_tenant_config(tenant_id: &amp;str) -&gt; Result&lt;TenantConfig, Box&lt;dyn std::error::Error&gt;&gt; {
    let prefix = format!("TENANT_{}", tenant_id.to_uppercase());
    
    Ok(TenantConfig {
        name: std::env::var(format!("{}_NAME", prefix))?,
        max_users: std::env::var(format!("{}_MAX_USERS", prefix))
            .ok().and_then(|s| s.parse().ok()),
        features: std::env::var(format!("{}_FEATURES", prefix))
            .unwrap_or_default()
            .split(',')
            .filter(|s| !s.is_empty())
            .map(|s| s.to_string())
            .collect(),
        auth_config: AuthConfig::OAuth {
            jwks_url: std::env::var(format!("{}_JWKS_URL", prefix))?,
            audience: std::env::var(format!("{}_AUDIENCE", prefix))?,
        },
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="file-based-configuration"><a class="header" href="#file-based-configuration">File-Based Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// config/tenants.yaml
use serde_yaml;

#[derive(Debug, Deserialize)]
struct TenantsConfig {
    tenants: HashMap&lt;String, TenantConfig&gt;,
}

async fn load_tenant_configs_from_file() -&gt; Result&lt;HashMap&lt;String, TenantConfig&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let config_content = tokio::fs::read_to_string("config/tenants.yaml").await?;
    let config: TenantsConfig = serde_yaml::from_str(&amp;config_content)?;
    Ok(config.tenants)
}
<span class="boring">}</span></code></pre></pre>
<p>Example <code>config/tenants.yaml</code>:</p>
<pre><code class="language-yaml">tenants:
  company-a:
    name: "Company A"
    max_users: 1000
    features: ["bulk_operations", "custom_schemas"]
    auth_config:
      OAuth:
        jwks_url: "https://company-a.auth0.com/.well-known/jwks.json"
        audience: "scim-api"
  
  company-b:
    name: "Company B"
    max_users: 500
    features: ["basic_operations"]
    auth_config:
      ApiKey:
        keys: ["sk_live_abc123"]
</code></pre>
<h2 id="security-considerations"><a class="header" href="#security-considerations">Security Considerations</a></h2>
<h3 id="authentication-per-tenant"><a class="header" href="#authentication-per-tenant">Authentication Per Tenant</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::http::HeaderMap;

async fn authenticate_tenant_request(
    headers: &amp;HeaderMap,
    tenant_id: &amp;str,
    tenant_configs: &amp;HashMap&lt;String, TenantConfig&gt;,
) -&gt; Result&lt;(), MultiTenantError&gt; {
    let tenant_config = tenant_configs.get(tenant_id)
        .ok_or_else(|| MultiTenantError::TenantNotFound(tenant_id.to_string()))?;

    match &amp;tenant_config.auth_config {
        AuthConfig::OAuth { jwks_url, audience } =&gt; {
            // Validate JWT token
            let auth_header = headers.get("authorization")
                .and_then(|h| h.to_str().ok())
                .ok_or_else(|| MultiTenantError::InternalError("Missing authorization header".to_string()))?;
                
            if !auth_header.starts_with("Bearer ") {
                return Err(MultiTenantError::InternalError("Invalid authorization format".to_string()));
            }
            
            let token = &amp;auth_header[7..];
            validate_jwt_token(token, jwks_url, audience).await?;
        },
        
        AuthConfig::ApiKey { keys } =&gt; {
            // Validate API key
            let api_key = headers.get("x-api-key")
                .and_then(|h| h.to_str().ok())
                .ok_or_else(|| MultiTenantError::InternalError("Missing API key".to_string()))?;
                
            if !keys.contains(&amp;api_key.to_string()) {
                return Err(MultiTenantError::InternalError("Invalid API key".to_string()));
            }
        },
        
        AuthConfig::Basic { username, password } =&gt; {
            // Validate basic auth
            let auth_header = headers.get("authorization")
                .and_then(|h| h.to_str().ok())
                .ok_or_else(|| MultiTenantError::InternalError("Missing authorization header".to_string()))?;
                
            // Decode and validate basic auth credentials
            validate_basic_auth(auth_header, username, password)?;
        },
    }

    Ok(())
}

async fn validate_jwt_token(token: &amp;str, jwks_url: &amp;str, audience: &amp;str) -&gt; Result&lt;(), MultiTenantError&gt; {
    // JWT validation implementation
    // This would use a JWT library to validate the token
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="rate-limiting-per-tenant"><a class="header" href="#rate-limiting-per-tenant">Rate Limiting Per Tenant</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use std::collections::HashMap;
use std::sync::{Arc, Mutex};

#[derive(Debug, Clone)]
struct RateLimiter {
    requests: Arc&lt;Mutex&lt;HashMap&lt;String, Vec&lt;Instant&gt;&gt;&gt;&gt;,
}

impl RateLimiter {
    fn new() -&gt; Self {
        Self {
            requests: Arc::new(Mutex::new(HashMap::new())),
        }
    }

    fn check_rate_limit(&amp;self, tenant_id: &amp;str, limit_per_minute: usize) -&gt; bool {
        let mut requests = self.requests.lock().unwrap();
        let now = Instant::now();
        let minute_ago = now - Duration::from_secs(60);
        
        let tenant_requests = requests.entry(tenant_id.to_string()).or_insert_with(Vec::new);
        
        // Remove old requests
        tenant_requests.retain(|&amp;request_time| request_time &gt; minute_ago);
        
        if tenant_requests.len() &gt;= limit_per_minute {
            false
        } else {
            tenant_requests.push(now);
            true
        }
    }
}

// Usage in middleware
async fn rate_limit_middleware(
    tenant_id: &amp;str,
    tenant_config: &amp;TenantConfig,
    rate_limiter: &amp;RateLimiter,
) -&gt; Result&lt;(), MultiTenantError&gt; {
    if let Some(limit) = tenant_config.max_requests_per_minute {
        if !rate_limiter.check_rate_limit(tenant_id, limit) {
            return Err(MultiTenantError::TenantLimitExceeded(
                format!("Rate limit of {} requests per minute exceeded", limit)
            ));
        }
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-and-observability-1"><a class="header" href="#monitoring-and-observability-1">Monitoring and Observability</a></h2>
<h3 id="per-tenant-metrics"><a class="header" href="#per-tenant-metrics">Per-Tenant Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Gauge, Registry};
use std::collections::HashMap;

#[derive(Clone)]
struct TenantMetrics {
    request_counter: Counter,
    response_time: Histogram,
    active_users: Gauge,
    active_groups: Gauge,
}

struct MultiTenantMetrics {
    registry: Registry,
    tenant_metrics: HashMap&lt;String, TenantMetrics&gt;,
}

impl MultiTenantMetrics {
    fn new() -&gt; Self {
        Self {
            registry: Registry::new(),
            tenant_metrics: HashMap::new(),
        }
    }

    fn get_or_create_tenant_metrics(&amp;mut self, tenant_id: &amp;str) -&gt; &amp;TenantMetrics {
        self.tenant_metrics.entry(tenant_id.to_string()).or_insert_with(|| {
            let request_counter = Counter::new(
                "scim_requests_total",
                "Total number of SCIM requests per tenant"
            ).unwrap();
            
            let response_time = Histogram::new(
                "scim_request_duration_seconds",
                "SCIM request duration in seconds"
            ).unwrap();
            
            let active_users = Gauge::new(
                "scim_active_users",
                "Number of active users per tenant"
            ).unwrap();
            
            let active_groups = Gauge::new(
                "scim_active_groups", 
                "Number of active groups per tenant"
            ).unwrap();

            TenantMetrics {
                request_counter,
                response_time,
                active_users,
                active_groups,
            }
        })
    }

    fn record_request(&amp;mut self, tenant_id: &amp;str, duration: Duration) {
        let metrics = self.get_or_create_tenant_metrics(tenant_id);
        metrics.request_counter.inc();
        metrics.response_time.observe(duration.as_secs_f64());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-tenant-validation"><a class="header" href="#1-tenant-validation">1. Tenant Validation</a></h3>
<ul>
<li>Always validate tenant existence before processing requests</li>
<li>Implement consistent error responses for invalid tenants</li>
<li>Use meaningful tenant identifiers (avoid sequential IDs)</li>
</ul>
<h3 id="2-data-isolation"><a class="header" href="#2-data-isolation">2. Data Isolation</a></h3>
<ul>
<li>Use tenant-aware RequestContext for all operations</li>
<li>Implement database-level isolation for sensitive deployments</li>
<li>Audit cross-tenant access attempts</li>
</ul>
<h3 id="3-configuration-management"><a class="header" href="#3-configuration-management">3. Configuration Management</a></h3>
<ul>
<li>Store tenant configs securely (encrypted secrets)</li>
<li>Implement hot-reloading for configuration changes</li>
<li>Version configuration changes for rollback capability</li>
</ul>
<h3 id="4-performance"><a class="header" href="#4-performance">4. Performance</a></h3>
<ul>
<li>Implement per-tenant rate limiting</li>
<li>Monitor tenant resource usage</li>
<li>Scale storage based on tenant data growth</li>
</ul>
<h3 id="5-security"><a class="header" href="#5-security">5. Security</a></h3>
<ul>
<li>Use different authentication schemes per tenant as needed</li>
<li>Implement audit logging for all tenant operations</li>
<li>Regular security reviews of tenant isolation</li>
</ul>
<h2 id="testing-multi-tenant-deployments"><a class="header" href="#testing-multi-tenant-deployments">Testing Multi-Tenant Deployments</a></h2>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_tenant_isolation() {
        let app = MultiTenantApp::new();
        
        // Create users in different tenants
        let tenant_a_context = app.create_context("tenant-a", "test");
        let tenant_b_context = app.create_context("tenant-b", "test");
        
        let user_data = json!({"userName": "test@example.com"});
        
        let user_a = app.provider.create_resource("User", user_data.clone(), &amp;tenant_a_context).await.unwrap();
        let user_b = app.provider.create_resource("User", user_data, &amp;tenant_b_context).await.unwrap();
        
        // Verify isolation - tenant A cannot see tenant B's user
        let tenant_a_users = app.provider.list_resources("User", None, &amp;tenant_a_context).await.unwrap();
        let tenant_b_users = app.provider.list_resources("User", None, &amp;tenant_b_context).await.unwrap();
        
        assert_eq!(tenant_a_users.len(), 1);
        assert_eq!(tenant_b_users.len(), 1);
        assert_ne!(user_a.get_id(), user_b.get_id());
    }

    #[tokio::test]
    async fn test_tenant_limits() {
        let mut tenant_configs = HashMap::new();
        tenant_configs.insert("limited-tenant".to_string(), TenantConfig {
            name: "Limited Tenant".to_string(),
            max_users: Some(1),
            features: vec![],
            auth_config: AuthConfig::ApiKey { keys: vec!["test".to_string()] },
        });
        
        let app = MultiTenantApp {
            provider: Arc::new(StandardResourceProvider::new(InMemoryStorage::new())),
            tenant_configs,
        };
        
        // Create first user (should succeed)
        let context = app.create_context("limited-tenant", "test");
        let user_data = json!({"userName": "user1@example.com"});
        let result1 = app.provider.create_resource("User", user_data, &amp;context).await;
        assert!(result1.is_ok());
        
        // Try to create second user (should fail due to limit)
        let user_data2 = json!({"userName": "user2@example.com"});
        let context2 = app.create_context("limited-tenant", "test");
        
        // In a real implementation, this would be checked in the handler
        let users = app.provider.list_resources("User", None, &amp;context2).await.unwrap();
        assert_eq!(users.len(), 1); // At limit
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>This tutorial demonstrated comprehensive multi-tenant SCIM deployments:</p>
<p>✅ <strong>Multi-Tenant Architecture</strong>:</p>
<ul>
<li>Application-level isolation via RequestContext</li>
<li>Database-level isolation with Row-Level Security</li>
<li>Flexible deployment patterns (single vs. separate instances)</li>
</ul>
<p>✅ <strong>Configuration Management</strong>:</p>
<ul>
<li>Environment and file-based tenant configuration</li>
<li>Per-tenant authentication schemes</li>
<li>Feature flags and limits per tenant</li>
</ul>
<p>✅ <strong>Security &amp; Isolation</strong>:</p>
<ul>
<li>Complete data isolation between tenants</li>
<li>Per-tenant authentication and authorization</li>
<li>Rate limiting and resource controls</li>
</ul>
<p>✅ <strong>Production Considerations</strong>:</p>
<ul>
<li>Monitoring and metrics per tenant</li>
<li>Performance optimization strategies</li>
<li>Comprehensive testing approaches</li>
</ul>
<p><strong>Next Steps</strong>:</p>
<ul>
<li>
<p><a href="tutorials/./authentication-setup.html">Authentication Setup</a> - Secure your multi-tenant endpoints</p>
</li>
<li>
<p><a href="tutorials/./custom-resources.html">Custom Resources</a> - Extend SCIM for tenant-specific needs</p>
</li>
<li>
<p><a href="tutorials/./performance-optimization.html">Performance Optimization</a> - Scale for multiple tenants
let mut configs = HashMap::new();</p>
<p>// Load from database
let rows = sqlx::query("SELECT tenant_id, config FROM tenant_configs")
.fetch_all(&amp;pool)
.await?;</p>
<p>for row in rows {
let tenant_id: String = row.get("tenant_id");
let config_json: serde_json::Value = row.get("config");
let config: TenantConfig = serde_json::from_value(config_json)?;
configs.insert(tenant_id, config);
}</p>
<p>Ok(configs)
}</p>
</li>
</ul>
<pre><code>
### Tenant Registration

```rust
async fn register_tenant(
    State(app): State&lt;MultiTenantApp&gt;,
    Json(registration): Json&lt;TenantRegistration&gt;,
) -&gt; Result&lt;Json&lt;TenantInfo&gt;, (StatusCode, Json&lt;ScimError&gt;)&gt; {
    // Validate registration
    if registration.tenant_id.is_empty() || registration.name.is_empty() {
        return Err((StatusCode::BAD_REQUEST, Json(ScimError::invalid_value("Missing required fields"))));
    }

    // Check if tenant already exists
    if app.tenant_configs.contains_key(&amp;registration.tenant_id) {
        return Err((StatusCode::CONFLICT, Json(ScimError::uniqueness("Tenant ID already exists"))));
    }

    // Create tenant configuration
    let config = TenantConfig {
        name: registration.name,
        display_name: registration.display_name,
        auth_scheme: registration.auth_scheme,
        limits: TenantLimits {
            max_users: Some(1000),
            max_groups: Some(100),
            max_requests_per_minute: Some(1000),
            max_bulk_operations: Some(100),
        },
        features: vec!["basic_operations".to_string()],
        custom_schemas: vec![],
        webhook_endpoints: vec![],
    };

    // Save to database
    sqlx::query(
        "INSERT INTO tenant_configs (tenant_id, config) VALUES ($1, $2)"
    )
    .bind(&amp;registration.tenant_id)
    .bind(serde_json::to_value(&amp;config)?)
    .execute(&amp;app.pool)
    .await?;

    // Generate API key for the tenant
    let api_key = generate_api_key(&amp;registration.tenant_id);

    Ok(Json(TenantInfo {
        tenant_id: registration.tenant_id,
        name: config.name,
        api_key,
        endpoints: TenantEndpoints {
            base_url: format!("https://api.example.com/scim/v2/{}", registration.tenant_id),
            users: format!("https://api.example.com/scim/v2/{}/Users", registration.tenant_id),
            groups: format!("https://api.example.com/scim/v2/{}/Groups", registration.tenant_id),
        },
    }))
}
</code></pre>
<h2 id="advanced-multi-tenant-patterns"><a class="header" href="#advanced-multi-tenant-patterns">Advanced Multi-Tenant Patterns</a></h2>
<h3 id="tenant-middleware"><a class="header" href="#tenant-middleware">Tenant Middleware</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{extract::Request, middleware::Next, response::Response};

async fn tenant_middleware(
    mut request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Extract tenant ID from path
    let tenant_id = request
        .uri()
        .path()
        .split('/')
        .nth(3) // /scim/v2/:tenant_id/...
        .ok_or(StatusCode::BAD_REQUEST)?;

    // Validate tenant exists
    let tenant_config = TENANT_CONFIGS
        .get(tenant_id)
        .ok_or(StatusCode::NOT_FOUND)?;

    // Add tenant context to request
    request.extensions_mut().insert(TenantContext {
        tenant_id: tenant_id.to_string(),
        config: tenant_config.clone(),
    });

    // Check tenant limits
    if let Err(status) = check_tenant_limits(&amp;tenant_config, &amp;request).await {
        return Err(status);
    }

    Ok(next.run(request).await)
}

async fn check_tenant_limits(
    config: &amp;TenantConfig,
    request: &amp;Request,
) -&gt; Result&lt;(), StatusCode&gt; {
    // Check rate limits
    if let Some(limit) = config.limits.max_requests_per_minute {
        let current_rate = get_current_request_rate(&amp;config.name).await;
        if current_rate &gt; limit {
            return Err(StatusCode::TOO_MANY_REQUESTS);
        }
    }

    // Check feature availability
    let requested_feature = extract_feature_from_request(request);
    if let Some(feature) = requested_feature {
        if !config.features.contains(&amp;feature) {
            return Err(StatusCode::FORBIDDEN);
        }
    }

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation-testing"><a class="header" href="#tenant-isolation-testing">Tenant Isolation Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use axum_test::TestServer;

    #[tokio::test]
    async fn test_tenant_isolation() {
        let app = create_test_app().await;
        let server = TestServer::new(app).unwrap();

        // Create user in tenant A
        let user_a = create_test_user("alice@company-a.com");
        let response = server
            .post("/scim/v2/company-a/Users")
            .json(&amp;user_a)
            .await;
        assert_eq!(response.status_code(), 201);
        let created_user_a: ScimUser = response.json();

        // Create user in tenant B
        let user_b = create_test_user("bob@company-b.com");
        let response = server
            .post("/scim/v2/company-b/Users")
            .json(&amp;user_b)
            .await;
        assert_eq!(response.status_code(), 201);
        let created_user_b: ScimUser = response.json();

        // Verify tenant A cannot see tenant B's users
        let response = server
            .get(&amp;format!("/scim/v2/company-a/Users/{}", created_user_b.id()))
            .await;
        assert_eq!(response.status_code(), 404);

        // Verify tenant B cannot see tenant A's users
        let response = server
            .get(&amp;format!("/scim/v2/company-b/Users/{}", created_user_a.id()))
            .await;
        assert_eq!(response.status_code(), 404);

        // Verify each tenant can see their own users
        let response = server
            .get(&amp;format!("/scim/v2/company-a/Users/{}", created_user_a.id()))
            .await;
        assert_eq!(response.status_code(), 200);

        let response = server
            .get(&amp;format!("/scim/v2/company-b/Users/{}", created_user_b.id()))
            .await;
        assert_eq!(response.status_code(), 200);
    }

    #[tokio::test]
    async fn test_tenant_limits() {
        let app = create_test_app().await;
        let server = TestServer::new(app).unwrap();

        // Create users up to the limit
        for i in 0..1000 {
            let user = create_test_user(&amp;format!("user{}@company-a.com", i));
            let response = server
                .post("/scim/v2/company-a/Users")
                .json(&amp;user)
                .await;
            assert_eq!(response.status_code(), 201);
        }

        // Try to create one more user (should fail)
        let user = create_test_user("overflow@company-a.com");
        let response = server
            .post("/scim/v2/company-a/Users")
            .json(&amp;user)
            .await;
        assert_eq!(response.status_code(), 403);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deployment-strategies"><a class="header" href="#deployment-strategies">Deployment Strategies</a></h2>
<h3 id="shared-infrastructure"><a class="header" href="#shared-infrastructure">Shared Infrastructure</a></h3>
<pre><code class="language-yaml"># docker-compose.yml for shared infrastructure
version: '3.8'

services:
  scim-server:
    image: scim-server:latest
    environment:
      - DATABASE_URL=postgresql://scim:password@postgres:5432/scim
      - REDIS_URL=redis://redis:6379
      - TENANT_CONFIG_URL=file:///config/tenants.json
    volumes:
      - ./tenant-configs:/config
    ports:
      - "3000:3000"
    depends_on:
      - postgres
      - redis

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=scim
      - POSTGRES_USER=scim
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
</code></pre>
<h3 id="kubernetes-multi-tenant-deployment"><a class="header" href="#kubernetes-multi-tenant-deployment">Kubernetes Multi-Tenant Deployment</a></h3>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: scim-server-multitenant
spec:
  replicas: 3
  selector:
    matchLabels:
      app: scim-server
  template:
    metadata:
      labels:
        app: scim-server
    spec:
      containers:
      - name: scim-server
        image: scim-server:latest
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: url
        - name: TENANT_CONFIGS
          valueFrom:
            configMapKeyRef:
              name: tenant-configs
              key: config.json
        ports:
        - containerPort: 3000
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tenant-configs
data:
  config.json: |
    {
      "company-a": {
        "name": "Company A",
        "auth_scheme": {
          "OAuth": {
            "jwks_url": "https://company-a.auth0.com/.well-known/jwks.json",
            "audience": "scim-api"
          }
        },
        "limits": {
          "max_users": 1000,
          "max_requests_per_minute": 1000
        }
      },
      "company-b": {
        "name": "Company B",
        "auth_scheme": {
          "ApiKey": {
            "keys": ["sk_live_abc123"]
          }
        },
        "limits": {
          "max_users": 500,
          "max_requests_per_minute": 500
        }
      }
    }
</code></pre>
<h2 id="monitoring-and-observability-2"><a class="header" href="#monitoring-and-observability-2">Monitoring and Observability</a></h2>
<h3 id="per-tenant-metrics-1"><a class="header" href="#per-tenant-metrics-1">Per-Tenant Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, register_counter_vec, register_histogram_vec};

lazy_static! {
    static ref REQUESTS_TOTAL: Counter = register_counter_vec!(
        "scim_requests_total",
        "Total number of SCIM requests",
        &amp;["tenant_id", "method", "status"]
    ).unwrap();
    
    static ref REQUEST_DURATION: Histogram = register_histogram_vec!(
        "scim_request_duration_seconds",
        "Duration of SCIM requests",
        &amp;["tenant_id", "method"]
    ).unwrap();
}

async fn metrics_middleware(
    Extension(tenant_context): Extension&lt;TenantContext&gt;,
    request: Request,
    next: Next,
) -&gt; Response {
    let method = request.method().to_string();
    let start = std::time::Instant::now();
    
    let response = next.run(request).await;
    
    let duration = start.elapsed().as_secs_f64();
    let status = response.status().as_u16().to_string();
    
    REQUESTS_TOTAL
        .with_label_values(&amp;[&amp;tenant_context.tenant_id, &amp;method, &amp;status])
        .inc();
    
    REQUEST_DURATION
        .with_label_values(&amp;[&amp;tenant_context.tenant_id, &amp;method])
        .observe(duration);
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-health-dashboard"><a class="header" href="#tenant-health-dashboard">Tenant Health Dashboard</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn tenant_health_endpoint(
    State(app): State&lt;MultiTenantApp&gt;,
) -&gt; Json&lt;serde_json::Value&gt; {
    let mut tenant_health = serde_json::Map::new();
    
    for (tenant_id, config) in &amp;app.tenant_configs {
        let user_count = app.scim_server
            .count_users(tenant_id)
            .await
            .unwrap_or(0);
        
        let group_count = app.scim_server
            .count_groups(tenant_id)
            .await
            .unwrap_or(0);
        
        tenant_health.insert(tenant_id.clone(), json!({
            "name": config.name,
            "status": "healthy",
            "user_count": user_count,
            "group_count": group_count,
            "limits": {
                "max_users": config.limits.max_users,
                "user_utilization": config.limits.max_users.map(|max| (user_count as f64 / max as f64) * 100.0)
            }
        }));
    }
    
    Json(json!({
        "tenant_count": tenant_health.len(),
        "tenants": tenant_health
    }))
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive guide covers all aspects of deploying SCIM Server in multi-tenant environments, from basic setup to advanced production patterns with complete isolation and monitoring.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-framework-integration"><a class="header" href="#web-framework-integration">Web Framework Integration</a></h1>
<p>This tutorial shows how to integrate SCIM Server with popular Rust web frameworks. SCIM Server is framework-agnostic, meaning it works with any HTTP library while providing consistent SCIM functionality.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>SCIM Server follows a layered architecture that separates HTTP handling from SCIM logic:</p>
<pre><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   HTTP Layer    │    │ Resource Provider│    │   Storage       │
│                 │    │                  │    │                 │
│  • Axum         │───▶│  • Validation    │───▶│  • In-Memory    │
│  • Warp         │    │  • Operations    │    │  • Database     │
│  • Actix        │    │  • Type Safety   │    │  • Custom       │
│  • Custom       │    │  • Multi-tenant  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
</code></pre>
<p>This design allows you to use your preferred web framework while leveraging SCIM Server's enterprise-grade capabilities.</p>
<h2 id="integration-patterns-1"><a class="header" href="#integration-patterns-1">Integration Patterns</a></h2>
<h3 id="common-integration-pattern"><a class="header" href="#common-integration-pattern">Common Integration Pattern</a></h3>
<p>All framework integrations follow a similar pattern:</p>
<ol>
<li><strong>Create RequestContext</strong> from request metadata</li>
<li><strong>Parse JSON body</strong> for create/update operations</li>
<li><strong>Handle ETags</strong> for concurrency control</li>
<li><strong>Call StandardResourceProvider</strong> with the extracted data</li>
<li><strong>Return SCIM-compliant responses</strong> with proper headers</li>
</ol>
<h2 id="axum-integration"><a class="header" href="#axum-integration">Axum Integration</a></h2>
<p>Axum is a modern, ergonomic web framework built on tokio and hyper.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }
serde_json = "1.0"
</code></pre>
<h3 id="basic-server-setup"><a class="header" href="#basic-server-setup">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use axum::{
    extract::{Path, Query, State},
    http::{StatusCode, HeaderMap, HeaderValue},
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::collections::HashMap;
use tower_http::cors::CorsLayer;
use uuid::Uuid;

type AppState = StandardResourceProvider&lt;InMemoryStorage&gt;;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);

    // Build application with routes
    let app = Router::new()
        // SCIM v2 endpoints
        .route("/scim/v2/Users", post(create_user).get(list_users))
        .route("/scim/v2/Users/:id", 
            get(get_user).put(update_user).delete(delete_user))
        .route("/scim/v2/Groups", post(create_group).get(list_groups))
        .route("/scim/v2/Groups/:id", 
            get(get_group).put(update_group).delete(delete_group))
        // Multi-tenant endpoints
        .route("/tenants/:tenant_id/scim/v2/Users", post(create_user_mt).get(list_users_mt))
        .route("/tenants/:tenant_id/scim/v2/Users/:id", 
            get(get_user_mt).put(update_user_mt).delete(delete_user_mt))
        .with_state(provider)
        .layer(CorsLayer::permissive());

    // Start server
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    println!("SCIM Server running on http://127.0.0.1:3000");
    axum::serve(listener, app).await?;

    Ok(())
}</code></pre></pre>
<h3 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Helper to create RequestContext from HTTP request
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

// Create User
async fn create_user(
    State(provider): State&lt;AppState&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let user = provider.create_resource("User", user_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", format!("/scim/v2/Users/{}", 
        user.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(user.data)))
}

// Get User
async fn get_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(user.data)))
}

// List Users with Filtering
async fn list_users(
    State(provider): State&lt;AppState&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = create_request_context();
    
    // Get all users (provider handles this internally)
    let users = provider.list_resources("User", None, &amp;context).await?;
    
    // Apply client-side filtering if filter parameter provided
    let filtered_users = if let Some(filter_str) = params.get("filter") {
        // Simple filtering example - extend for full SCIM filter syntax
        users.into_iter()
            .filter(|user| {
                if filter_str.contains("active eq true") {
                    user.get_active().unwrap_or(true)
                } else {
                    true
                }
            })
            .collect::&lt;Vec&lt;_&gt;&gt;()
    } else {
        users
    };
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(filtered_users.len());
    let end = (start + count).min(filtered_users.len());
    let page_users = &amp;filtered_users[start..end];
    
    // Create SCIM list response
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": filtered_users.len(),
        "startIndex": start_index,
        "itemsPerPage": page_users.len(),
        "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Update User with ETag support
async fn update_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
    headers: HeaderMap,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    
    // Extract If-Match header for conditional updates
    let if_match = headers.get("if-match")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.trim_matches('"'));
    
    // For ETag support, you could verify the version matches current resource
    if let Some(_expected_version) = if_match {
        // Get current user to check version
        let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
        if let Some(meta) = current_user.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != _expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let user = provider.update_resource("User", &amp;user_id, user_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(user.data)))
}

// Delete User
async fn delete_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = create_request_context();
    provider.delete_resource("User", &amp;user_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-tenant-endpoints"><a class="header" href="#multi-tenant-endpoints">Multi-Tenant Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multi-tenant user creation
async fn create_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    // Create context with tenant information
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let user = provider.create_resource("User", user_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", 
        format!("/tenants/{}/scim/v2/Users/{}", tenant_id, 
        user.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(user.data)))
}

// Multi-tenant user retrieval
async fn get_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(user.data)))
}

// Multi-tenant user listing
async fn list_users_mt(
    State(provider): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let users = provider.list_resources("User", None, &amp;context).await?;
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(users.len());
    let end = (start + count).min(users.len());
    let page_users = &amp;users[start..end];
    
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": users.len(),
        "startIndex": start_index,
        "itemsPerPage": page_users.len(),
        "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Multi-tenant user update
async fn update_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
    headers: HeaderMap,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    
    // Handle ETag if present
    if let Some(if_match) = headers.get("if-match").and_then(|v| v.to_str().ok()) {
        let expected_version = if_match.trim_matches('"');
        let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
        if let Some(meta) = current_user.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let user = provider.update_resource("User", &amp;user_id, user_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(user.data)))
}

// Multi-tenant user deletion
async fn delete_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    provider.delete_resource("User", &amp;user_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::{Response, IntoResponse}, http::StatusCode};
use serde_json::json;

#[derive(Debug)]
enum AppError {
    NotFound,
    VersionMismatch,
    ValidationError(String),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&gt; Response {
        let (status, error_code, message) = match self {
            AppError::NotFound =&gt; (
                StatusCode::NOT_FOUND,
                "resourceNotFound",
                "The specified resource was not found",
            ),
            AppError::VersionMismatch =&gt; (
                StatusCode::PRECONDITION_FAILED,
                "versionMismatch", 
                "The resource version does not match",
            ),
            AppError::ValidationError(msg) =&gt; (
                StatusCode::BAD_REQUEST,
                "invalidData",
                &amp;msg,
            ),
            AppError::InternalError(msg) =&gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                "internalError",
                &amp;msg,
            ),
        };

        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": status.as_u16().to_string(),
            "scimType": error_code,
            "detail": message
        });

        (status, axum::Json(body)).into_response()
    }
}

impl&lt;E&gt; From&lt;E&gt; for AppError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -&gt; Self {
        let error_str = err.to_string();
        if error_str.contains("not found") {
            AppError::NotFound
        } else if error_str.contains("validation") {
            AppError::ValidationError(error_str)
        } else {
            AppError::InternalError(error_str)
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="group-operations-2"><a class="header" href="#group-operations-2">Group Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Group
async fn create_group(
    State(provider): State&lt;AppState&gt;,
    Json(group_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let group = provider.create_resource("Group", group_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", format!("/scim/v2/Groups/{}", 
        group.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(group.data)))
}

// Get Group
async fn get_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(group.data)))
}

// List Groups
async fn list_groups(
    State(provider): State&lt;AppState&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = create_request_context();
    let groups = provider.list_resources("Group", None, &amp;context).await?;
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(groups.len());
    let end = (start + count).min(groups.len());
    let page_groups = &amp;groups[start..end];
    
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": groups.len(),
        "startIndex": start_index,
        "itemsPerPage": page_groups.len(),
        "Resources": page_groups.iter().map(|g| &amp;g.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Update Group
async fn update_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
    headers: HeaderMap,
    Json(group_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    
    // Handle ETag if present
    if let Some(if_match) = headers.get("if-match").and_then(|v| v.to_str().ok()) {
        let expected_version = if_match.trim_matches('"');
        let current_group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;
        if let Some(meta) = current_group.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let group = provider.update_resource("Group", &amp;group_id, group_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(group.data)))
}

// Delete Group
async fn delete_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = create_request_context();
    provider.delete_resource("Group", &amp;group_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="warp-integration"><a class="header" href="#warp-integration">Warp Integration</a></h2>
<p>Warp is a composable web framework focusing on filters and type safety.</p>
<h3 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
warp = "0.3"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
</code></pre>
<h3 id="basic-server-setup-1"><a class="header" href="#basic-server-setup-1">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use warp::{Filter, Reply, Rejection};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::convert::Infallible;
use std::sync::Arc;
use uuid::Uuid;

type SharedProvider = Arc&lt;StandardResourceProvider&lt;InMemoryStorage&gt;&gt;;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = Arc::new(StandardResourceProvider::new(storage));

    // CORS configuration
    let cors = warp::cors()
        .allow_any_origin()
        .allow_headers(vec!["content-type", "authorization", "if-match"])
        .allow_methods(vec!["GET", "POST", "PUT", "DELETE"]);

    // Base path filter
    let scim_v2 = warp::path("scim").and(warp::path("v2"));
    
    // Provider state filter
    let with_provider = warp::any().map(move || provider.clone());

    // User routes
    let users = scim_v2
        .and(warp::path("Users"))
        .and(with_provider.clone())
        .and(
            // POST /scim/v2/Users
            warp::post()
                .and(warp::body::json())
                .and_then(create_user_handler)
            .or(
                // GET /scim/v2/Users
                warp::get()
                    .and(warp::query::query())
                    .and_then(list_users_handler)
            )
        );

    let user_by_id = scim_v2
        .and(warp::path("Users"))
        .and(warp::path::param::&lt;String&gt;())
        .and(with_provider.clone())
        .and(
            // GET /scim/v2/Users/{id}
            warp::get()
                .and_then(get_user_handler)
            .or(
                // PUT /scim/v2/Users/{id}
                warp::put()
                    .and(warp::header::optional::&lt;String&gt;("if-match"))
                    .and(warp::body::json())
                    .and_then(update_user_handler)
            )
            .or(
                // DELETE /scim/v2/Users/{id}
                warp::delete()
                    .and_then(delete_user_handler)
            )
        );

    let routes = users
        .or(user_by_id)
        .with(cors)
        .recover(handle_rejection);
    // Start server
    println!("SCIM Server running on http://127.0.0.1:3030");
    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;

    Ok(())
}

// Helper to create RequestContext
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

// Warp handlers
async fn create_user_handler(
    provider: SharedProvider,
    user_data: Value,
) -&gt; Result&lt;impl Reply, Rejection&gt; {
    let context = create_request_context();
    
    match provider.create_resource("User", user_data, &amp;context).await {
        Ok(user) =&gt; {
            let mut response = warp::reply::with_status(
                warp::reply::json(&amp;user.data), 
                warp::http::StatusCode::CREATED
            );
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response = warp::reply::with_header(
                        response,
                        "ETag",
                        format!("\"{}\"", version)
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Err(warp::reject::custom(WarpError::from(e))),
    }
}

async fn list_users_handler(
    provider: SharedProvider,
    params: std::collections::HashMap&lt;String, String&gt;,
) -&gt; Result&lt;impl Reply, Rejection&gt; {
    let context = create_request_context();
    
    match provider.list_resources("User", None, &amp;context).await {
        Ok(users) =&gt; {
            let start_index = params.get("startIndex")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(1);
            let count = params.get("count")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(20);
            
            let start = (start_index - 1).min(users.len());
            let end = (start + count).min(users.len());
            let page_users = &amp;users[start..end];
            
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": users.len(),
                "startIndex": start_index,
                "itemsPerPage": page_users.len(),
                "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(warp::reply::json(&amp;response))
        },
        Err(e) =&gt; Err(warp::reject::custom(WarpError::from(e))),
    }
}

// Error handling for Warp
#[derive(Debug)]
struct WarpError {
    message: String,
    status: warp::http::StatusCode,
}

impl warp::reject::Reject for WarpError {}

impl&lt;E&gt; From&lt;E&gt; for WarpError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -&gt; Self {
        let error_str = err.to_string();
        let status = if error_str.contains("not found") {
            warp::http::StatusCode::NOT_FOUND
        } else if error_str.contains("validation") {
            warp::http::StatusCode::BAD_REQUEST
        } else {
            warp::http::StatusCode::INTERNAL_SERVER_ERROR
        };
        
        Self { message: error_str, status }
    }
}

async fn handle_rejection(err: Rejection) -&gt; Result&lt;impl Reply, std::convert::Infallible&gt; {
    if let Some(warp_error) = err.find::&lt;WarpError&gt;() {
        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": warp_error.status.as_u16().to_string(),
            "detail": warp_error.message
        });
        
        Ok(warp::reply::with_status(
            warp::reply::json(&amp;body),
            warp_error.status
        ))
    } else {
        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": "500",
            "detail": "Internal server error"
        });
        
        Ok(warp::reply::with_status(
            warp::reply::json(&amp;body),
            warp::http::StatusCode::INTERNAL_SERVER_ERROR
        ))
    }
}</code></pre></pre>
<h2 id="actix-web-integration"><a class="header" href="#actix-web-integration">Actix Web Integration</a></h2>
<p>Actix Web is a powerful, pragmatic web framework for Rust.</p>
<h3 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
actix-web = "4"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
</code></pre>
<h3 id="basic-server-setup-2"><a class="header" href="#basic-server-setup-2">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use actix_web::{
    web, App, HttpServer, HttpRequest, HttpResponse, Result,
    middleware::Logger,
};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::sync::Arc;
use uuid::Uuid;

type AppData = web::Data&lt;StandardResourceProvider&lt;InMemoryStorage&gt;&gt;;

// Helper to create RequestContext
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    env_logger::init();

    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let app_data = web::Data::new(provider);

    HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .wrap(Logger::default())
            .service(
                web::scope("/scim/v2")
                    .service(
                        web::resource("/Users")
                            .route(web::post().to(create_user))
                            .route(web::get().to(list_users))
                    )
                    .service(
                        web::resource("/Users/{id}")
                            .route(web::get().to(get_user))
                            .route(web::put().to(update_user))
                            .route(web::delete().to(delete_user))
                    )
                    .service(
                        web::resource("/Groups")
                            .route(web::post().to(create_group))
                            .route(web::get().to(list_groups))
                    )
            )
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre></pre>
<h3 id="handler-functions"><a class="header" href="#handler-functions">Handler Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web::Path, web::Json, web::Query, HttpRequest};
use std::collections::HashMap;

async fn create_user(
    provider: AppData,
    user_data: Json&lt;Value&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.create_resource("User", user_data.into_inner(), &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Created().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn get_user(
    provider: AppData,
    path: Path&lt;String&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    match provider.get_resource("User", &amp;user_id, &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Ok().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::NotFound().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "404"
        }))),
    }
}

async fn list_users(
    provider: AppData,
    query: Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.list_resources("User", None, &amp;context).await {
        Ok(users) =&gt; {
            let start_index = query.get("startIndex")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(1);
            let count = query.get("count")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(20);
            
            let start = (start_index - 1).min(users.len());
            let end = (start + count).min(users.len());
            let page_users = &amp;users[start..end];
            
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": users.len(),
                "startIndex": start_index,
                "itemsPerPage": page_users.len(),
                "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(HttpResponse::Ok().json(response))
        },
        Err(e) =&gt; Ok(HttpResponse::InternalServerError().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "500"
        }))),
    }
}

async fn update_user(
    provider: AppData,
    path: Path&lt;String&gt;,
    user_data: Json&lt;Value&gt;,
    req: HttpRequest,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    // Handle ETag if present
    if let Some(if_match) = req.headers().get("if-match") {
        if let Ok(expected_version) = if_match.to_str() {
            let expected_version = expected_version.trim_matches('"');
            
            match provider.get_resource("User", &amp;user_id, &amp;context).await {
                Ok(current_user) =&gt; {
                    if let Some(meta) = current_user.get_meta() {
                        if let Some(current_version) = &amp;meta.version {
                            if current_version != expected_version {
                                return Ok(HttpResponse::PreconditionFailed().json(json!({
                                    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
                                    "detail": "Version mismatch",
                                    "status": "412"
                                })));
                            }
                        }
                    }
                },
                Err(_) =&gt; return Ok(HttpResponse::NotFound().json(json!({
                    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
                    "detail": "User not found",
                    "status": "404"
                }))),
            }
        }
    }
    
    match provider.update_resource("User", &amp;user_id, user_data.into_inner(), &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Ok().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn delete_user(
    provider: AppData,
    path: Path&lt;String&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    match provider.delete_resource("User", &amp;user_id, &amp;context).await {
        Ok(_) =&gt; Ok(HttpResponse::NoContent().finish()),
        Err(e) =&gt; Ok(HttpResponse::NotFound().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "404"
        }))),
    }
}

// Group handlers follow the same pattern
async fn create_group(
    provider: AppData,
    group_data: Json&lt;Value&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.create_resource("Group", group_data.into_inner(), &amp;context).await {
        Ok(group) =&gt; Ok(HttpResponse::Created().json(&amp;group.data)),
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn list_groups(
    provider: AppData,
    query: Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.list_resources("Group", None, &amp;context).await {
        Ok(groups) =&gt; {
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": groups.len(),
                "startIndex": 1,
                "itemsPerPage": groups.len(),
                "Resources": groups.iter().map(|g| &amp;g.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(HttpResponse::Ok().json(response))
        },
        Err(e) =&gt; Ok(HttpResponse::InternalServerError().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "500"
        }))),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="framework-specific-considerations"><a class="header" href="#framework-specific-considerations">Framework-Specific Considerations</a></h2>
<h3 id="axum"><a class="header" href="#axum">Axum</a></h3>
<ul>
<li><strong>Strengths</strong>: Modern async design, excellent type safety, minimal boilerplate</li>
<li><strong>Best for</strong>: New projects, type-safe APIs, microservices</li>
<li><strong>SCIM Integration</strong>: Clean state management with <code>State&lt;T&gt;</code>, built-in JSON handling</li>
</ul>
<h3 id="warp"><a class="header" href="#warp">Warp</a></h3>
<ul>
<li><strong>Strengths</strong>: Functional approach, composable filters, zero-cost abstractions</li>
<li><strong>Best for</strong>: High-performance APIs, functional programming enthusiasts</li>
<li><strong>SCIM Integration</strong>: Filter composition allows flexible middleware</li>
</ul>
<h3 id="actix-web"><a class="header" href="#actix-web">Actix Web</a></h3>
<ul>
<li><strong>Strengths</strong>: Mature ecosystem, high performance, extensive middleware</li>
<li><strong>Best for</strong>: Production applications, teams familiar with traditional web frameworks</li>
<li><strong>SCIM Integration</strong>: Straightforward handler patterns, robust error handling</li>
</ul>
<h2 id="common-patterns-across-frameworks"><a class="header" href="#common-patterns-across-frameworks">Common Patterns Across Frameworks</a></h2>
<h3 id="request-context-creation"><a class="header" href="#request-context-creation">Request Context Creation</a></h3>
<p>All integrations use the same pattern for creating request contexts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="etag-handling"><a class="header" href="#etag-handling">ETag Handling</a></h3>
<p>Consistent ETag support across frameworks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extract If-Match header
let if_match = headers.get("if-match")
    .and_then(|v| v.to_str().ok())
    .map(|s| s.trim_matches('"'));

// Set ETag in response
if let Some(version) = &amp;meta.version {
    headers.insert("ETag", format!("\"{}\"", version));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-response-format"><a class="header" href="#error-response-format">Error Response Format</a></h3>
<p>Standard SCIM error responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let error_response = json!({
    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
    "status": status_code.to_string(),
    "detail": error_message
});
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenant-url-patterns"><a class="header" href="#multi-tenant-url-patterns">Multi-Tenant URL Patterns</a></h2>
<p>All frameworks support multi-tenant deployments with URL patterns like:</p>
<ul>
<li>Single tenant: <code>/scim/v2/Users</code></li>
<li>Multi-tenant: <code>/tenants/{tenant_id}/scim/v2/Users</code></li>
</ul>
<p>The key is creating request contexts that include tenant information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-consistent-error-handling"><a class="header" href="#1-consistent-error-handling">1. Consistent Error Handling</a></h3>
<ul>
<li>Always return SCIM-compliant error responses</li>
<li>Include proper HTTP status codes</li>
<li>Provide meaningful error messages</li>
</ul>
<h3 id="2-etag-support"><a class="header" href="#2-etag-support">2. ETag Support</a></h3>
<ul>
<li>Implement conditional requests for concurrency control</li>
<li>Return ETags in response headers</li>
<li>Handle If-Match headers for updates</li>
</ul>
<h3 id="3-request-context-management"><a class="header" href="#3-request-context-management">3. Request Context Management</a></h3>
<ul>
<li>Create unique request contexts for operation tracking</li>
<li>Include tenant information for multi-tenant scenarios</li>
<li>Use UUIDs for request correlation</li>
</ul>
<h3 id="4-performance-considerations"><a class="header" href="#4-performance-considerations">4. Performance Considerations</a></h3>
<ul>
<li>Use async/await throughout the request pipeline</li>
<li>Leverage framework-specific optimizations</li>
<li>Consider connection pooling for database storage</li>
</ul>
<h3 id="5-security-1"><a class="header" href="#5-security-1">5. Security</a></h3>
<ul>
<li>Validate all input data</li>
<li>Implement proper authentication middleware</li>
<li>Use HTTPS in production</li>
<li>Sanitize error messages to avoid information leakage</li>
</ul>
<h2 id="testing-your-integration"><a class="header" href="#testing-your-integration">Testing Your Integration</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Test individual handlers with mock data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use scim_server::storage::InMemoryStorage;

    #[tokio::test]
    async fn test_create_user() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::new("test".to_string());
        
        let user_data = json!({
            "userName": "test@example.com",
            "active": true
        });
        
        let result = provider.create_resource("User", user_data, &amp;context).await;
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests-1"><a class="header" href="#integration-tests-1">Integration Tests</a></h3>
<p>Test complete HTTP request/response cycles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_web::test]
async fn test_user_creation_endpoint() {
    let app = test::init_service(
        App::new()
            .app_data(create_test_app_data())
            .service(web::resource("/Users").route(web::post().to(create_user)))
    ).await;

    let req = test::TestRequest::post()
        .uri("/Users")
        .set_json(&amp;json!({"userName": "test@example.com"}))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), 201);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<p>This tutorial demonstrated how to integrate SCIM Server with three popular Rust web frameworks:</p>
<p>✅ <strong>Framework Integration Patterns</strong>:</p>
<ul>
<li>Axum: Modern, type-safe with excellent async support</li>
<li>Warp: Functional, composable filters for flexibility</li>
<li>Actix Web: Mature, high-performance with extensive middleware</li>
</ul>
<p>✅ <strong>Key Implementation Details</strong>:</p>
<ul>
<li>StandardResourceProvider usage across all frameworks</li>
<li>RequestContext creation and management</li>
<li>ETag support for concurrency control</li>
<li>SCIM-compliant error handling</li>
<li>Multi-tenant URL patterns</li>
</ul>
<p>✅ <strong>Production Considerations</strong>:</p>
<ul>
<li>Security best practices</li>
<li>Performance optimization</li>
<li>Testing strategies</li>
<li>Error handling standards</li>
</ul>
<p>Choose the framework that best fits your team's expertise and project requirements. All three provide excellent foundations for building production SCIM servers with the SCIM Server library.</p>
<p><strong>Next Steps</strong>:</p>
<ul>
<li><a href="tutorials/./authentication-setup.html">Authentication Setup</a> - Secure your SCIM endpoints</li>
<li><a href="tutorials/./multi-tenant-deployment.html">Multi-Tenant Deployment</a> - Scale to multiple organizations</li>
<li><a href="tutorials/./custom-resources.html">Custom Resources</a> - Extend beyond Users and Groups
let tenant_id = TenantId::default();</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ai-integration-with-mcp"><a class="header" href="#ai-integration-with-mcp">AI Integration with MCP</a></h1>
<p>This tutorial shows you how to integrate your SCIM Server with AI assistants using the Model Context Protocol (MCP). You'll learn to expose SCIM operations as MCP tools, enabling AI assistants to manage identity resources through natural language.</p>
<h2 id="what-is-mcp"><a class="header" href="#what-is-mcp">What is MCP?</a></h2>
<p>The Model Context Protocol (MCP) is a standardized way for AI applications to connect to external data sources and tools. It enables AI assistants like Claude, ChatGPT, and custom bots to:</p>
<ul>
<li><strong>Execute operations</strong> through defined tools</li>
<li><strong>Access real-time data</strong> from external systems</li>
<li><strong>Maintain context</strong> across conversations</li>
<li><strong>Provide structured responses</strong> based on live data</li>
</ul>
<p>For SCIM servers, MCP integration means AI assistants can:</p>
<ul>
<li>Create, read, update, and delete users and groups</li>
<li>Query identity data with natural language</li>
<li>Automate complex provisioning workflows</li>
<li>Generate reports and insights from identity data</li>
</ul>
<h2 id="quick-start-example-1"><a class="header" href="#quick-start-example-1">Quick Start Example</a></h2>
<p>Here's a simple MCP server that exposes SCIM operations:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, InMemoryProvider, ScimUser, ScimGroup};
use mcp_server::{McpServer, Tool, ToolResult, McpError};
use serde_json::{json, Value};
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create SCIM server
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder()
        .provider(provider)
        .build();
    
    // Create MCP server with SCIM tools
    let mcp_server = McpServer::builder()
        .name("SCIM Identity Manager")
        .version("1.0.0")
        .tool(create_user_tool(scim_server.clone()))
        .tool(get_user_tool(scim_server.clone()))
        .tool(list_users_tool(scim_server.clone()))
        .tool(create_group_tool(scim_server.clone()))
        .build();
    
    // Start MCP server
    let listener = TcpListener::bind("127.0.0.1:3001").await?;
    println!("MCP Server running on localhost:3001");
    mcp_server.serve(listener).await?;
    
    Ok(())
}</code></pre></pre>
<p>With this setup, an AI assistant can perform operations like:</p>
<ul>
<li>"Create a new user named Alice Johnson with email alice@company.com"</li>
<li>"Show me all users in the Engineering department"</li>
<li>"Add Alice to the Administrators group"</li>
</ul>
<h2 id="step-1-define-mcp-tools"><a class="header" href="#step-1-define-mcp-tools">Step 1: Define MCP Tools</a></h2>
<p>MCP tools are functions that AI assistants can call. Let's define tools for common SCIM operations:</p>
<h3 id="create-user-tool"><a class="header" href="#create-user-tool">Create User Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use mcp_server::{Tool, ToolInput, ToolResult};
use serde_json::{json, Value};

fn create_user_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("create_user")
        .description("Create a new user in the SCIM system")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "username": {
                    "type": "string",
                    "description": "User's username/email"
                },
                "given_name": {
                    "type": "string",
                    "description": "User's first name"
                },
                "family_name": {
                    "type": "string",
                    "description": "User's last name"
                },
                "email": {
                    "type": "string",
                    "description": "User's email address"
                },
                "active": {
                    "type": "boolean",
                    "description": "Whether the user is active",
                    "default": true
                },
                "department": {
                    "type": "string",
                    "description": "User's department"
                }
            },
            "required": ["tenant_id", "username", "given_name", "family_name", "email"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let username = input.get_string("username")?;
                let given_name = input.get_string("given_name")?;
                let family_name = input.get_string("family_name")?;
                let email = input.get_string("email")?;
                let active = input.get_bool("active").unwrap_or(true);
                let department = input.get_optional_string("department");
                
                // Build the user
                let mut user_builder = ScimUser::builder()
                    .username(&amp;username)
                    .given_name(&amp;given_name)
                    .family_name(&amp;family_name)
                    .email(&amp;email)
                    .active(active);
                
                if let Some(dept) = department {
                    user_builder = user_builder.department(&amp;dept);
                }
                
                let user = user_builder.build()?;
                
                // Create the user
                let created_user = scim_server.create_user(&amp;tenant_id, user).await?;
                
                ToolResult::success(json!({
                    "message": format!("Successfully created user {} ({})", created_user.username(), created_user.id()),
                    "user": {
                        "id": created_user.id(),
                        "username": created_user.username(),
                        "name": {
                            "givenName": created_user.given_name(),
                            "familyName": created_user.family_name()
                        },
                        "email": created_user.primary_email(),
                        "active": created_user.active(),
                        "department": created_user.department()
                    }
                }))
            }
        })
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="get-user-tool"><a class="header" href="#get-user-tool">Get User Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_user_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("get_user")
        .description("Retrieve a user by ID or username")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "identifier": {
                    "type": "string",
                    "description": "User ID or username"
                }
            },
            "required": ["tenant_id", "identifier"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let identifier = input.get_string("identifier")?;
                
                // Try to get user by ID first, then by username
                let user = if identifier.contains('@') {
                    scim_server.find_user_by_username(&amp;tenant_id, &amp;identifier).await?
                } else {
                    scim_server.get_user(&amp;tenant_id, &amp;identifier).await?
                };
                
                match user {
                    Some(user) =&gt; ToolResult::success(json!({
                        "user": {
                            "id": user.id(),
                            "username": user.username(),
                            "name": {
                                "formatted": user.formatted_name(),
                                "givenName": user.given_name(),
                                "familyName": user.family_name()
                            },
                            "emails": user.emails(),
                            "active": user.active(),
                            "department": user.department(),
                            "title": user.title(),
                            "manager": user.manager().map(|m| m.display_name()),
                            "meta": {
                                "created": user.meta().created,
                                "lastModified": user.meta().last_modified,
                                "version": user.meta().version
                            }
                        }
                    })),
                    None =&gt; ToolResult::error(format!("User '{}' not found", identifier))
                }
            }
        })
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="list-users-tool"><a class="header" href="#list-users-tool">List Users Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_users_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("list_users")
        .description("List users with optional filtering")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "filter": {
                    "type": "string",
                    "description": "SCIM filter expression (e.g., 'department eq \"Engineering\"')"
                },
                "count": {
                    "type": "integer",
                    "description": "Maximum number of results",
                    "default": 50,
                    "maximum": 200
                },
                "sort_by": {
                    "type": "string",
                    "description": "Attribute to sort by",
                    "default": "meta.lastModified"
                }
            },
            "required": ["tenant_id"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let filter = input.get_optional_string("filter");
                let count = input.get_optional_int("count").unwrap_or(50).min(200);
                let sort_by = input.get_optional_string("sort_by").unwrap_or_else(|| "meta.lastModified".to_string());
                
                let mut options = ListOptions::builder()
                    .count(count as usize)
                    .sort_by(&amp;sort_by);
                
                // Note: Filter expressions are not yet implemented
                // For now, we'll load all users and filter in memory if needed
                
                let response = scim_server.list_users(&amp;tenant_id, &amp;options.build()).await?;
                
                let users: Vec&lt;Value&gt; = response.resources.into_iter().map(|user| {
                    json!({
                        "id": user.id(),
                        "username": user.username(),
                        "name": {
                            "formatted": user.formatted_name(),
                            "givenName": user.given_name(),
                            "familyName": user.family_name()
                        },
                        "email": user.primary_email(),
                        "active": user.active(),
                        "department": user.department(),
                        "title": user.title(),
                        "lastModified": user.meta().last_modified
                    })
                }).collect();
                
                ToolResult::success(json!({
                    "totalResults": response.total_results,
                    "startIndex": response.start_index,
                    "itemsPerPage": response.items_per_page,
                    "users": users
                }))
            }
        })
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-2-group-management-tools"><a class="header" href="#step-2-group-management-tools">Step 2: Group Management Tools</a></h2>
<p>Add tools for group operations:</p>
<h3 id="create-group-tool"><a class="header" href="#create-group-tool">Create Group Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_group_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("create_group")
        .description("Create a new group")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "display_name": {
                    "type": "string",
                    "description": "Group display name"
                },
                "description": {
                    "type": "string",
                    "description": "Group description"
                },
                "members": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Array of user IDs or usernames to add as members"
                }
            },
            "required": ["tenant_id", "display_name"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let display_name = input.get_string("display_name")?;
                let description = input.get_optional_string("description");
                let member_identifiers = input.get_optional_array("members").unwrap_or_default();
                
                // Resolve member identifiers to user IDs
                let mut members = Vec::new();
                for identifier_value in member_identifiers {
                    if let Some(identifier) = identifier_value.as_str() {
                        let user = if identifier.contains('@') {
                            scim_server.find_user_by_username(&amp;tenant_id, identifier).await?
                        } else {
                            scim_server.get_user(&amp;tenant_id, identifier).await?
                        };
                        
                        if let Some(user) = user {
                            members.push(GroupMember {
                                value: user.id().to_string(),
                                ref_: Some(format!("../Users/{}", user.id())),
                                type_: Some("User".to_string()),
                                display: user.formatted_name(),
                            });
                        } else {
                            return ToolResult::error(format!("User '{}' not found", identifier));
                        }
                    }
                }
                
                // Build the group
                let mut group_builder = ScimGroup::builder()
                    .display_name(&amp;display_name)
                    .members(members);
                
                if let Some(desc) = description {
                    group_builder = group_builder.description(&amp;desc);
                }
                
                let group = group_builder.build()?;
                
                // Create the group
                let created_group = scim_server.create_group(&amp;tenant_id, group).await?;
                
                ToolResult::success(json!({
                    "message": format!("Successfully created group '{}' with {} members", 
                                     created_group.display_name(), 
                                     created_group.members().len()),
                    "group": {
                        "id": created_group.id(),
                        "displayName": created_group.display_name(),
                        "description": created_group.description(),
                        "memberCount": created_group.members().len(),
                        "members": created_group.members().iter().map(|m| json!({
                            "id": m.value,
                            "display": m.display
                        })).collect::&lt;Vec&lt;_&gt;&gt;()
                    }
                }))
            }
        })
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add-user-to-group-tool"><a class="header" href="#add-user-to-group-tool">Add User to Group Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_user_to_group_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("add_user_to_group")
        .description("Add a user to a group")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "group_identifier": {
                    "type": "string", 
                    "description": "Group ID or display name"
                },
                "user_identifier": {
                    "type": "string",
                    "description": "User ID or username"
                }
            },
            "required": ["tenant_id", "group_identifier", "user_identifier"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let group_identifier = input.get_string("group_identifier")?;
                let user_identifier = input.get_string("user_identifier")?;
                
                // Find the group
                let group = scim_server.find_group(&amp;tenant_id, &amp;group_identifier).await?
                    .ok_or_else(|| format!("Group '{}' not found", group_identifier))?;
                
                // Find the user
                let user = if user_identifier.contains('@') {
                    scim_server.find_user_by_username(&amp;tenant_id, &amp;user_identifier).await?
                } else {
                    scim_server.get_user(&amp;tenant_id, &amp;user_identifier).await?
                }.ok_or_else(|| format!("User '{}' not found", user_identifier))?;
                
                // Add user to group using PATCH operation
                let patch_op = PatchOperation {
                    op: PatchOp::Add,
                    path: Some("members".to_string()),
                    value: Some(json!([{
                        "value": user.id(),
                        "$ref": format!("../Users/{}", user.id()),
                        "type": "User",
                        "display": user.formatted_name()
                    }])),
                };
                
                let updated_group = scim_server.patch_group(&amp;tenant_id, group.id(), vec![patch_op]).await?;
                
                ToolResult::success(json!({
                    "message": format!("Successfully added {} to group '{}'", 
                                     user.formatted_name(), 
                                     updated_group.display_name()),
                    "group": {
                        "id": updated_group.id(),
                        "displayName": updated_group.display_name(),
                        "memberCount": updated_group.members().len()
                    },
                    "user": {
                        "id": user.id(),
                        "username": user.username(),
                        "name": user.formatted_name()
                    }
                }))
            }
        })
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-3-advanced-query-tools"><a class="header" href="#step-3-advanced-query-tools">Step 3: Advanced Query Tools</a></h2>
<p>Create intelligent tools that can understand natural language queries:</p>
<h3 id="search-tool"><a class="header" href="#search-tool">Search Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn search_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("search")
        .description("Search for users or groups using natural language")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "query": {
                    "type": "string",
                    "description": "Natural language search query"
                },
                "resource_type": {
                    "type": "string",
                    "enum": ["users", "groups", "both"],
                    "default": "both",
                    "description": "Type of resources to search"
                }
            },
            "required": ["tenant_id", "query"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let query = input.get_string("query")?;
                let resource_type = input.get_optional_string("resource_type").unwrap_or_else(|| "both".to_string());
                
                let mut results = json!({
                    "query": query,
                    "results": {}
                });
                
                // Load users and apply in-memory filtering based on query
                let options = ListOptions::builder()
                    .count(200)  // Load more to filter in memory
                    .build();
                
                // Search users
                if resource_type == "users" || resource_type == "both" {
                    let user_response = scim_server.list_users(&amp;tenant_id, &amp;options).await?;
                    
                    // Filter users in memory based on query
                    let filtered_users: Vec&lt;_&gt; = user_response.resources.into_iter()
                        .filter(|user| matches_query(user, &amp;query))
                        .collect();
                    
                    let users: Vec&lt;Value&gt; = filtered_users.into_iter().map(|user| {
                        json!({
                            "id": user.id(),
                            "username": user.username(),
                            "name": user.formatted_name(),
                            "email": user.primary_email(),
                            "department": user.department(),
                            "active": user.active()
                        })
                    }).collect();
                    
                    results["results"]["users"] = json!({
                        "count": users.len(),
                        "items": users
                    });
                }
                
                // Search groups
                if resource_type == "groups" || resource_type == "both" {
                    let group_response = scim_server.list_groups(&amp;tenant_id, &amp;options).await?;
                    let groups: Vec&lt;Value&gt; = group_response.resources.into_iter().map(|group| {
                        json!({
                            "id": group.id(),
                            "displayName": group.display_name(),
                            "description": group.description(),
                            "memberCount": group.members().len()
                        })
                    }).collect();
                    
                    results["results"]["groups"] = json!({
                        "count": groups.len(),
                        "items": groups
                    });
                }
                
                ToolResult::success(results)
            }
        })
        .build()
}

// Helper function to match users against natural language queries
fn matches_query(user: &amp;ScimUser, query: &amp;str) -&gt; bool {
    let query_lower = query.to_lowercase();
    
    // Check various user fields for matches
    if let Some(username) = user.username() {
        if username.to_lowercase().contains(&amp;query_lower) {
            return true;
        }
    }
    
    if let Some(email) = user.primary_email() {
        if email.to_lowercase().contains(&amp;query_lower) {
            return true;
        }
    }
    
    if let Some(name) = user.formatted_name() {
        if name.to_lowercase().contains(&amp;query_lower) {
            return true;
        }
    }
    
    if let Some(department) = user.department() {
        if department.to_lowercase().contains(&amp;query_lower) {
            return true;
        }
    }
    
    // Specific keyword matching
    if query_lower.contains("engineer") || query_lower.contains("engineering") {
        return user.department().map_or(false, |d| d.to_lowercase().contains("engineer"));
    }
    
    if query_lower.contains("active") {
        return user.active();
    }
    
    if query_lower.contains("inactive") || query_lower.contains("disabled") {
        return !user.active();
    }
    
    false
}

fn extract_email(query: &amp;str) -&gt; Option&lt;String&gt; {
    // Simple email extraction
    let email_regex = regex::Regex::new(r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}").ok()?;
    email_regex.find(query).map(|m| m.as_str().to_string())
}

fn extract_name(query: &amp;str) -&gt; Option&lt;String&gt; {
    // Extract quoted names or capitalize first word
    if let Some(start) = query.find('"') {
        if let Some(end) = query[start + 1..].find('"') {
            return Some(query[start + 1..start + 1 + end].to_string());
        }
    }
    
    // Take first word as potential name
    query.split_whitespace().next().map(|s| s.to_string())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-4-analytics-and-reporting-tools"><a class="header" href="#step-4-analytics-and-reporting-tools">Step 4: Analytics and Reporting Tools</a></h2>
<p>Add tools for generating insights:</p>
<h3 id="user-analytics-tool"><a class="header" href="#user-analytics-tool">User Analytics Tool</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn user_analytics_tool(scim_server: ScimServer) -&gt; Tool {
    Tool::builder()
        .name("user_analytics")
        .description("Generate analytics and insights about users")
        .input_schema(json!({
            "type": "object",
            "properties": {
                "tenant_id": {
                    "type": "string",
                    "description": "Tenant identifier"
                },
                "report_type": {
                    "type": "string",
                    "enum": ["summary", "department_breakdown", "activity_report", "growth_trends"],
                    "default": "summary",
                    "description": "Type of analytics report to generate"
                },
                "date_range": {
                    "type": "string",
                    "description": "Date range for the report (e.g., 'last_30_days', 'last_quarter')",
                    "default": "last_30_days"
                }
            },
            "required": ["tenant_id"]
        }))
        .handler(move |input: ToolInput| {
            let scim_server = scim_server.clone();
            async move {
                let tenant_id = input.get_string("tenant_id")?;
                let report_type = input.get_optional_string("report_type").unwrap_or_else(|| "summary".to_string());
                let date_range = input.get_optional_string("date_range").unwrap_or_else(|| "last_30_days".to_string());
                
                match report_type.as_str() {
                    "summary" =&gt; generate_user_summary(&amp;scim_server, &amp;tenant_id).await,
                    "department_breakdown" =&gt; generate_department_breakdown(&amp;scim_server, &amp;tenant_id).await,
                    "activity_report" =&gt; generate_activity_report(&amp;scim_server, &amp;tenant_id, &amp;date_range).await,
                    "growth_trends" =&gt; generate_growth_trends(&amp;scim_server, &amp;tenant_id, &amp;date_range).await,
                    _ =&gt; ToolResult::error("Unknown report type".to_string())
                }
            }
        })
        .build()
}

async fn generate_user_summary(scim_server: &amp;ScimServer, tenant_id: &amp;str) -&gt; ToolResult {
    let all_users = scim_server.list_users(tenant_id, &amp;ListOptions::default()).await?;
    
    let total_users = all_users.total_results;
    let active_users = all_users.resources.iter().filter(|u| u.active()).count();
    let inactive_users = total_users - active_users;
    
    // Department breakdown
    let mut departments = std::collections::HashMap::new();
    for user in &amp;all_users.resources {
        if let Some(dept) = user.department() {
            *departments.entry(dept.to_string()).or_insert(0) += 1;
        } else {
            *departments.entry("Unassigned".to_string()).or_insert(0) += 1;
        }
    }
    
    // Recent activity (last 7 days)
    let week_ago = chrono::Utc::now() - chrono::Duration::days(7);
    let recent_users = all_users.resources.iter()
        .filter(|u| u.meta().created &gt; week_ago)
        .count();
    
    ToolResult::success(json!({
        "report": "User Summary",
        "generated_at": chrono::Utc::now(),
        "total_users": total_users,
        "active_users": active_users,
        "inactive_users": inactive_users,
        "activity_rate": format!("{:.1}%", (active_users as f64 / total_users as f64) * 100.0),
        "new_users_last_7_days": recent_users,
        "department_breakdown": departments,
        "top_departments": {
            let mut dept_vec: Vec&lt;_&gt; = departments.iter().collect();
            dept_vec.sort_by(|a, b| b.1.cmp(a.1));
            dept_vec.into_iter().take(5).map(|(k, v)| json!({"department": k, "count": v})).collect::&lt;Vec&lt;_&gt;&gt;()
        }
    }))
}

async fn generate_department_breakdown(scim_server: &amp;ScimServer, tenant_id: &amp;str) -&gt; ToolResult {
    let all_users = scim_server.list_users(tenant_id, &amp;ListOptions::default()).await?;
    
    let mut department_stats = std::collections::HashMap::new();
    
    for user in &amp;all_users.resources {
        let dept = user.department().unwrap_or("Unassigned");
        let entry = department_stats.entry(dept.to_string()).or_insert_with(|| json!({
            "name": dept,
            "total_users": 0,
            "active_users": 0,
            "managers": 0,
            "recent_additions": 0
        }));
        
        entry["total_users"] = json!(entry["total_users"].as_u64().unwrap() + 1);
        
        if user.active() {
            entry["active_users"] = json!(entry["active_users"].as_u64().unwrap() + 1);
        }
        
        if user.title().map_or(false, |t| t.to_lowercase().contains("manager")) {
            entry["managers"] = json!(entry["managers"].as_u64().unwrap() + 1);
        }
        
        let week_ago = chrono::Utc::now() - chrono::Duration::days(7);
        if user.meta().created &gt; week_ago {
            entry["recent_additions"] = json!(entry["recent_additions"].as_u64().unwrap() + 1);
        }
    }
    
    let departments: Vec&lt;_&gt; = department_stats.into_values().collect();
    
    ToolResult::success(json!({
        "report": "Department Breakdown",
        "generated_at": chrono::Utc::now(),
        "total_departments": departments.len(),
        "departments": departments
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="step-5-complete-mcp-server-setup"><a class="header" href="#step-5-complete-mcp-server-setup">Step 5: Complete MCP Server Setup</a></h2>
<p>Put it all together in a complete MCP server:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{ScimServer, InMemoryProvider, DatabaseProvider};
use mcp_server::{McpServer, ServerInfo};
use serde_json::json;
use std::sync::Arc;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize logging
    tracing_subscriber::init();
    
    // Create SCIM server with your choice of provider
    let provider = if std::env::var("DATABASE_URL").is_ok() {
        let db_url = std::env::var("DATABASE_URL")?;
        Box::new(DatabaseProvider::new(&amp;db_url).await?) as Box&lt;dyn Provider&gt;
    } else {
        Box::new(InMemoryProvider::new()) as Box&lt;dyn Provider&gt;
    };
    
    let scim_server = Arc::new(ScimServer::builder()
        .provider(provider)
        .build());
    
    // Create MCP server with comprehensive tool set
    let mcp_server = McpServer::builder()
        .server_info(ServerInfo {
            name: "SCIM Identity Manager".to_string(),
            version: "1.0.0".to_string(),
            description: Some("AI-powered identity management through SCIM protocol".to_string()),
            author: Some("Your Organization".to_string()),
            license: Some("MIT".to_string()),
        })
        // User management tools
        .tool(create_user_tool(scim_server.clone()))
        .tool(get_user_tool(scim_server.clone()))
        .tool(list_users_tool(scim_server.clone()))
        .tool(update_user_tool(scim_server.clone()))
        .tool(delete_user_tool(scim_server.clone()))
        // Group management tools
        .tool(create_group_tool(scim_server.clone()))
        .tool(get_group_tool(scim_server.</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h1>
<p>This tutorial covers techniques for optimizing SCIM Server performance, including database optimization, caching strategies, connection pooling, and monitoring performance bottlenecks.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>Performance optimization in SCIM Server involves several layers:</p>
<ul>
<li><strong>Database Performance</strong>: Query optimization, indexing, and connection pooling</li>
<li><strong>Application Performance</strong>: Efficient data structures and algorithms</li>
<li><strong>Caching</strong>: Strategic caching of frequently accessed data</li>
<li><strong>Network Performance</strong>: Connection reuse and payload optimization</li>
<li><strong>Monitoring</strong>: Identifying and resolving bottlenecks</li>
</ul>
<h2 id="database-optimization"><a class="header" href="#database-optimization">Database Optimization</a></h2>
<h3 id="query-performance"><a class="header" href="#query-performance">Query Performance</a></h3>
<p><strong>Efficient data loading patterns:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ListOptions};

// Inefficient: Load all users then filter in memory
async fn get_active_users_slow(provider: &amp;impl Provider, tenant_id: &amp;str) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Error&gt; {
    let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
    let active_users: Vec&lt;_&gt; = all_users.resources.into_iter()
        .filter(|user| user.active())
        .collect();
    Ok(active_users)
}

// Better: Use pagination to limit memory usage
async fn get_users_paginated(provider: &amp;impl Provider, tenant_id: &amp;str) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Error&gt; {
    let options = ListOptions::builder()
        .count(Some(100))        // Limit to 100 users per request
        .start_index(Some(1))    // Start from first user
        .build();
    
    let response = provider.list_users(tenant_id, &amp;options).await?;
    
    // Filter in memory for now (database filtering not yet implemented)
    let active_users: Vec&lt;_&gt; = response.resources.into_iter()
        .filter(|user| user.active())
        .collect();
    
    Ok(active_users)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize complex queries:</strong></p>
<pre><code class="language-sql">-- Add indexes for common filter patterns
CREATE INDEX CONCURRENTLY idx_users_active_dept ON users(tenant_id, active, department) 
WHERE active = true;

CREATE INDEX CONCURRENTLY idx_users_email_lookup ON users(tenant_id, (data-&gt;&gt;'primaryEmail'));

CREATE INDEX CONCURRENTLY idx_users_last_modified ON users(tenant_id, updated_at) 
WHERE updated_at &gt; NOW() - INTERVAL '30 days';

-- Use partial indexes for common conditions
CREATE INDEX CONCURRENTLY idx_groups_with_members ON groups(tenant_id, display_name) 
WHERE jsonb_array_length(data-&gt;'members') &gt; 0;
</code></pre>
<h3 id="connection-pooling"><a class="header" href="#connection-pooling">Connection Pooling</a></h3>
<p><strong>Optimize database connections:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_optimized_pool(database_url: &amp;str) -&gt; Result&lt;sqlx::PgPool, sqlx::Error&gt; {
    PgPoolOptions::new()
        .max_connections(20)                    // Adjust based on your load
        .min_connections(5)                     // Keep minimum connections warm
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Some(Duration::from_secs(600)))
        .max_lifetime(Some(Duration::from_secs(1800)))
        .test_before_acquire(true)              // Test connections before use
        .after_connect(|conn, _meta| {
            Box::pin(async move {
                // Optimize connection settings
                sqlx::query("SET statement_timeout = '30s'")
                    .execute(conn)
                    .await?;
                sqlx::query("SET lock_timeout = '10s'")
                    .execute(conn)
                    .await?;
                Ok(())
            })
        })
        .connect(database_url)
        .await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p><strong>Use transactions for related operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{Transaction, Postgres};

async fn create_user_with_groups_optimized(
    provider: &amp;DatabaseProvider,
    tenant_id: &amp;str,
    user: ScimUser,
    group_ids: Vec&lt;String&gt;,
) -&gt; Result&lt;ScimUser, ProviderError&gt; {
    let mut tx = provider.begin_transaction().await?;
    
    // Create user
    let created_user = tx.create_user(tenant_id, user).await?;
    
    // Add to groups in batch
    if !group_ids.is_empty() {
        let query = format!(
            "INSERT INTO group_memberships (group_id, user_id) VALUES {}",
            group_ids.iter()
                .map(|_| "($1, $2)")
                .collect::&lt;Vec&lt;_&gt;&gt;()
                .join(", ")
        );
        
        let mut query_builder = sqlx::query(&amp;query);
        for group_id in &amp;group_ids {
            query_builder = query_builder.bind(group_id).bind(created_user.id());
        }
        
        query_builder.execute(&amp;mut *tx).await?;
    }
    
    tx.commit().await?;
    Ok(created_user)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h2>
<h3 id="redis-caching"><a class="header" href="#redis-caching">Redis Caching</a></h3>
<p><strong>Implement multi-layer caching:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use redis::{AsyncCommands, Client};
use serde::{Serialize, Deserialize};
use std::time::Duration;

#[derive(Clone)]
pub struct CachedProvider {
    inner: DatabaseProvider,
    redis: Client,
    cache_ttl: Duration,
}

impl CachedProvider {
    pub fn new(inner: DatabaseProvider, redis_url: &amp;str, cache_ttl: Duration) -&gt; Result&lt;Self, redis::RedisError&gt; {
        let redis = Client::open(redis_url)?;
        Ok(Self { inner, redis, cache_ttl })
    }
    
    async fn get_user_cached(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        let cache_key = format!("user:{}:{}", tenant_id, user_id);
        
        // Try L1 cache (Redis)
        if let Ok(mut conn) = self.redis.get_async_connection().await {
            if let Ok(cached_data) = conn.get::&lt;_, String&gt;(&amp;cache_key).await {
                if let Ok(user) = serde_json::from_str::&lt;ScimUser&gt;(&amp;cached_data) {
                    return Ok(Some(user));
                }
            }
        }
        
        // L2 cache miss - fetch from database
        let user = self.inner.get_user(tenant_id, user_id).await?;
        
        // Cache the result
        if let (Some(ref user), Ok(mut conn)) = (&amp;user, self.redis.get_async_connection().await) {
            if let Ok(serialized) = serde_json::to_string(user) {
                let _: Result&lt;(), _&gt; = conn.setex(&amp;cache_key, self.cache_ttl.as_secs(), serialized).await;
            }
        }
        
        Ok(user)
    }
    
    async fn invalidate_user_cache(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;(), redis::RedisError&gt; {
        let cache_key = format!("user:{}:{}", tenant_id, user_id);
        let mut conn = self.redis.get_async_connection().await?;
        conn.del(&amp;cache_key).await?;
        
        // Also invalidate related caches
        let pattern = format!("users:{}:*", tenant_id);
        self.invalidate_pattern(&amp;pattern).await?;
        
        Ok(())
    }
    
    async fn invalidate_pattern(&amp;self, pattern: &amp;str) -&gt; Result&lt;(), redis::RedisError&gt; {
        let mut conn = self.redis.get_async_connection().await?;
        let keys: Vec&lt;String&gt; = conn.keys(pattern).await?;
        
        if !keys.is_empty() {
            conn.del(&amp;keys).await?;
        }
        
        Ok(())
    }
}

// Implement cache-aware operations
#[async_trait]
impl Provider for CachedProvider {
    async fn get_user(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        self.get_user_cached(tenant_id, user_id).await
    }
    
    async fn update_user(&amp;self, tenant_id: &amp;str, user: ScimUser) -&gt; Result&lt;ScimUser, ProviderError&gt; {
        let updated_user = self.inner.update_user(tenant_id, user).await?;
        
        // Invalidate cache
        if let Err(e) = self.invalidate_user_cache(tenant_id, updated_user.id()).await {
            tracing::warn!("Failed to invalidate user cache: {}", e);
        }
        
        Ok(updated_user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="in-memory-caching"><a class="header" href="#in-memory-caching">In-Memory Caching</a></h3>
<p><strong>Application-level caching for frequently accessed data:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::sync::RwLock;
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Clone)]
struct CacheEntry&lt;T&gt; {
    value: T,
    expires_at: Instant,
}

#[derive(Clone)]
pub struct MemoryCache&lt;T&gt; {
    data: Arc&lt;RwLock&lt;HashMap&lt;String, CacheEntry&lt;T&gt;&gt;&gt;&gt;,
    ttl: Duration,
}

impl&lt;T: Clone&gt; MemoryCache&lt;T&gt; {
    pub fn new(ttl: Duration) -&gt; Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            ttl,
        }
    }
    
    pub async fn get(&amp;self, key: &amp;str) -&gt; Option&lt;T&gt; {
        let data = self.data.read().await;
        
        if let Some(entry) = data.get(key) {
            if entry.expires_at &gt; Instant::now() {
                return Some(entry.value.clone());
            }
        }
        
        None
    }
    
    pub async fn set(&amp;self, key: String, value: T) {
        let mut data = self.data.write().await;
        data.insert(key, CacheEntry {
            value,
            expires_at: Instant::now() + self.ttl,
        });
    }
    
    pub async fn invalidate(&amp;self, key: &amp;str) {
        let mut data = self.data.write().await;
        data.remove(key);
    }
    
    // Background cleanup task
    pub async fn cleanup_expired(&amp;self) {
        let mut data = self.data.write().await;
        let now = Instant::now();
        data.retain(|_, entry| entry.expires_at &gt; now);
    }
}

// Usage in provider
#[derive(Clone)]
pub struct MemoryCachedProvider {
    inner: DatabaseProvider,
    user_cache: MemoryCache&lt;ScimUser&gt;,
    schema_cache: MemoryCache&lt;Schema&gt;,
}

impl MemoryCachedProvider {
    pub fn new(inner: DatabaseProvider) -&gt; Self {
        let provider = Self {
            inner,
            user_cache: MemoryCache::new(Duration::from_secs(300)), // 5 minutes
            schema_cache: MemoryCache::new(Duration::from_secs(3600)), // 1 hour
        };
        
        // Start cleanup task
        let cache = provider.user_cache.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(60));
            loop {
                interval.tick().await;
                cache.cleanup_expired().await;
            }
        });
        
        provider
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="connection-and-resource-management"><a class="header" href="#connection-and-resource-management">Connection and Resource Management</a></h2>
<h3 id="http-client-optimization"><a class="header" href="#http-client-optimization">HTTP Client Optimization</a></h3>
<p><strong>Reuse HTTP connections:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use reqwest::Client;
use std::time::Duration;

lazy_static! {
    static ref HTTP_CLIENT: Client = Client::builder()
        .timeout(Duration::from_secs(30))
        .connect_timeout(Duration::from_secs(10))
        .pool_max_idle_per_host(10)
        .pool_idle_timeout(Duration::from_secs(90))
        .build()
        .expect("Failed to create HTTP client");
}

// Use the shared client for external API calls
async fn validate_oauth_token(token: &amp;str) -&gt; Result&lt;Claims, Error&gt; {
    let response = HTTP_CLIENT
        .post("https://oauth.provider.com/introspect")
        .form(&amp;[("token", token)])
        .send()
        .await?;
    
    let claims: Claims = response.json().await?;
    Ok(claims)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-pooling"><a class="header" href="#resource-pooling">Resource Pooling</a></h3>
<p><strong>Implement object pooling for expensive operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use deadpool::managed::{Manager, Object, Pool, PoolError};
use async_trait::async_trait;

#[derive(Clone)]
pub struct ExpensiveResource {
    // Some expensive-to-create resource
    id: uuid::Uuid,
    data: Vec&lt;u8&gt;,
}

pub struct ResourceManager;

#[async_trait]
impl Manager for ResourceManager {
    type Type = ExpensiveResource;
    type Error = Box&lt;dyn std::error::Error + Send + Sync&gt;;
    
    async fn create(&amp;self) -&gt; Result&lt;Self::Type, Self::Error&gt; {
        // Expensive resource creation
        tokio::time::sleep(Duration::from_millis(100)).await;
        
        Ok(ExpensiveResource {
            id: uuid::Uuid::new_v4(),
            data: vec![0u8; 1024 * 1024], // 1MB
        })
    }
    
    async fn recycle(&amp;self, _obj: &amp;mut Self::Type) -&gt; Result&lt;(), Self::Error&gt; {
        // Reset/cleanup resource for reuse
        Ok(())
    }
}

// Usage
pub async fn create_resource_pool() -&gt; Pool&lt;ResourceManager&gt; {
    Pool::builder(ResourceManager)
        .max_size(10)
        .build()
        .expect("Failed to create resource pool")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="algorithm-and-data-structure-optimization"><a class="header" href="#algorithm-and-data-structure-optimization">Algorithm and Data Structure Optimization</a></h2>
<h3 id="efficient-data-structures"><a class="header" href="#efficient-data-structures">Efficient Data Structures</a></h3>
<p><strong>Use appropriate data structures for different access patterns:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::{HashMap, BTreeMap, HashSet};
use indexmap::IndexMap;

#[derive(Clone)]
pub struct OptimizedUserStore {
    // Fast lookup by ID
    users_by_id: HashMap&lt;String, ScimUser&gt;,
    
    // Fast lookup by username (unique)
    users_by_username: HashMap&lt;String, String&gt;, // username -&gt; id
    
    // Fast lookup by email
    users_by_email: HashMap&lt;String, String&gt;, // email -&gt; id
    
    // Ordered access for pagination
    users_ordered: IndexMap&lt;String, ScimUser&gt;, // maintains insertion order
    
    // Fast membership testing
    active_user_ids: HashSet&lt;String&gt;,
}

impl OptimizedUserStore {
    pub fn new() -&gt; Self {
        Self {
            users_by_id: HashMap::new(),
            users_by_username: HashMap::new(),
            users_by_email: HashMap::new(),
            users_ordered: IndexMap::new(),
            active_user_ids: HashSet::new(),
        }
    }
    
    pub fn add_user(&amp;mut self, user: ScimUser) {
        let id = user.id().to_string();
        let username = user.username().to_string();
        
        // Update all indexes
        self.users_by_username.insert(username, id.clone());
        
        if let Some(email) = user.primary_email() {
            self.users_by_email.insert(email.to_string(), id.clone());
        }
        
        if user.active() {
            self.active_user_ids.insert(id.clone());
        }
        
        self.users_by_id.insert(id.clone(), user.clone());
        self.users_ordered.insert(id, user);
    }
    
    pub fn get_by_username(&amp;self, username: &amp;str) -&gt; Option&lt;&amp;ScimUser&gt; {
        self.users_by_username
            .get(username)
            .and_then(|id| self.users_by_id.get(id))
    }
    
    pub fn get_active_users(&amp;self) -&gt; impl Iterator&lt;Item = &amp;ScimUser&gt; {
        self.active_user_ids
            .iter()
            .filter_map(|id| self.users_by_id.get(id))
    }
    
    pub fn paginate(&amp;self, start: usize, count: usize) -&gt; impl Iterator&lt;Item = &amp;ScimUser&gt; {
        self.users_ordered
            .values()
            .skip(start)
            .take(count)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="bulk-processing"><a class="header" href="#bulk-processing">Bulk Processing</a></h3>
<p><strong>Optimize bulk operations:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use futures::stream::{self, StreamExt};
use std::sync::atomic::{AtomicUsize, Ordering};

pub struct BulkProcessor {
    concurrency_limit: usize,
    batch_size: usize,
}

impl BulkProcessor {
    pub fn new(concurrency_limit: usize, batch_size: usize) -&gt; Self {
        Self {
            concurrency_limit,
            batch_size,
        }
    }
    
    pub async fn process_users_bulk&lt;F, Fut&gt;(
        &amp;self,
        users: Vec&lt;ScimUser&gt;,
        processor: F,
    ) -&gt; Result&lt;Vec&lt;ProcessResult&gt;, Error&gt;
    where
        F: Fn(ScimUser) -&gt; Fut + Clone + Send + 'static,
        Fut: Future&lt;Output = Result&lt;ScimUser, Error&gt;&gt; + Send,
    {
        let processed_count = AtomicUsize::new(0);
        let total_count = users.len();
        
        let results = stream::iter(users)
            .map(move |user| {
                let processor = processor.clone();
                let processed_count = &amp;processed_count;
                
                async move {
                    let result = processor(user).await;
                    let count = processed_count.fetch_add(1, Ordering::Relaxed) + 1;
                    
                    if count % 100 == 0 {
                        tracing::info!("Processed {}/{} users", count, total_count);
                    }
                    
                    result
                }
            })
            .buffer_unordered(self.concurrency_limit)
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .await;
        
        Ok(results.into_iter().collect())
    }
    
    pub async fn process_in_batches&lt;T, F, Fut&gt;(
        &amp;self,
        items: Vec&lt;T&gt;,
        processor: F,
    ) -&gt; Result&lt;Vec&lt;T&gt;, Error&gt;
    where
        T: Send + 'static,
        F: Fn(Vec&lt;T&gt;) -&gt; Fut + Send + 'static,
        Fut: Future&lt;Output = Result&lt;Vec&lt;T&gt;, Error&gt;&gt; + Send,
    {
        let mut results = Vec::new();
        
        for batch in items.chunks(self.batch_size) {
            let batch_result = processor(batch.to_vec()).await?;
            results.extend(batch_result);
        }
        
        Ok(results)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h2>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<p><strong>Track key performance indicators:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Gauge, register_counter, register_histogram, register_gauge};
use std::time::Instant;

lazy_static! {
    static ref OPERATION_DURATION: Histogram = register_histogram!(
        "scim_operation_duration_seconds",
        "Duration of SCIM operations",
        vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
    ).unwrap();
    
    static ref CACHE_HITS: Counter = register_counter!(
        "scim_cache_hits_total",
        "Total cache hits"
    ).unwrap();
    
    static ref CACHE_MISSES: Counter = register_counter!(
        "scim_cache_misses_total",
        "Total cache misses"
    ).unwrap();
    
    static ref ACTIVE_CONNECTIONS: Gauge = register_gauge!(
        "scim_active_db_connections",
        "Number of active database connections"
    ).unwrap();
}

pub struct PerformanceTracker;

impl PerformanceTracker {
    pub fn time_operation&lt;F, T&gt;(operation_name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let _timer = OPERATION_DURATION
            .with_label_values(&amp;[operation_name])
            .start_timer();
        
        f()
    }
    
    pub async fn time_async_operation&lt;F, Fut, T&gt;(operation_name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; Fut,
        Fut: Future&lt;Output = T&gt;,
    {
        let _timer = OPERATION_DURATION
            .with_label_values(&amp;[operation_name])
            .start_timer();
        
        f().await
    }
    
    pub fn record_cache_hit() {
        CACHE_HITS.inc();
    }
    
    pub fn record_cache_miss() {
        CACHE_MISSES.inc();
    }
    
    pub fn set_active_connections(count: i64) {
        ACTIVE_CONNECTIONS.set(count as f64);
    }
}

// Usage in provider
impl CachedProvider {
    async fn get_user(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        PerformanceTracker::time_async_operation("get_user", async {
            if let Some(user) = self.get_from_cache(tenant_id, user_id).await {
                PerformanceTracker::record_cache_hit();
                return Ok(Some(user));
            }
            
            PerformanceTracker::record_cache_miss();
            let user = self.inner.get_user(tenant_id, user_id).await?;
            
            if let Some(ref user) = user {
                self.cache_user(tenant_id, user).await;
            }
            
            Ok(user)
        }).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-profiling"><a class="header" href="#performance-profiling">Performance Profiling</a></h3>
<p><strong>Add profiling capabilities:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::{Duration, Instant};
use std::collections::HashMap;
use tokio::sync::RwLock;

#[derive(Clone)]
pub struct ProfileData {
    pub calls: u64,
    pub total_duration: Duration,
    pub min_duration: Duration,
    pub max_duration: Duration,
    pub avg_duration: Duration,
}

#[derive(Clone)]
pub struct Profiler {
    data: Arc&lt;RwLock&lt;HashMap&lt;String, ProfileData&gt;&gt;&gt;,
}

impl Profiler {
    pub fn new() -&gt; Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    pub async fn profile&lt;F, T&gt;(&amp;self, name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let start = Instant::now();
        let result = f();
        let duration = start.elapsed();
        
        self.record(name, duration).await;
        result
    }
    
    pub async fn profile_async&lt;F, Fut, T&gt;(&amp;self, name: &amp;str, f: F) -&gt; T
    where
        F: FnOnce() -&gt; Fut,
        Fut: Future&lt;Output = T&gt;,
    {
        let start = Instant::now();
        let result = f().await;
        let duration = start.elapsed();
        
        self.record(name, duration).await;
        result
    }
    
    async fn record(&amp;self, name: &amp;str, duration: Duration) {
        let mut data = self.data.write().await;
        
        let entry = data.entry(name.to_string()).or_insert(ProfileData {
            calls: 0,
            total_duration: Duration::ZERO,
            min_duration: Duration::MAX,
            max_duration: Duration::ZERO,
            avg_duration: Duration::ZERO,
        });
        
        entry.calls += 1;
        entry.total_duration += duration;
        entry.min_duration = entry.min_duration.min(duration);
        entry.max_duration = entry.max_duration.max(duration);
        entry.avg_duration = entry.total_duration / entry.calls as u32;
    }
    
    pub async fn get_report(&amp;self) -&gt; HashMap&lt;String, ProfileData&gt; {
        self.data.read().await.clone()
    }
    
    pub async fn reset(&amp;self) {
        self.data.write().await.clear();
    }
}

// Usage
lazy_static! {
    static ref GLOBAL_PROFILER: Profiler = Profiler::new();
}

// Endpoint to get profiling data
async fn profiling_report() -&gt; Json&lt;serde_json::Value&gt; {
    let report = GLOBAL_PROFILER.get_report().await;
    
    let formatted_report: HashMap&lt;String, serde_json::Value&gt; = report
        .into_iter()
        .map(|(name, data)| {
            (name, json!({
                "calls": data.calls,
                "total_duration_ms": data.total_duration.as_millis(),
                "avg_duration_ms": data.avg_duration.as_millis(),
                "min_duration_ms": data.min_duration.as_millis(),
                "max_duration_ms": data.max_duration.as_millis(),
            }))
        })
        .collect();
    
    Json(json!(formatted_report))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="load-testing-and-benchmarking"><a class="header" href="#load-testing-and-benchmarking">Load Testing and Benchmarking</a></h2>
<h3 id="load-testing-setup"><a class="header" href="#load-testing-setup">Load Testing Setup</a></h3>
<p><strong>Create load tests to identify bottlenecks:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod load_tests {
    use super::*;
    use tokio::task::JoinSet;
    use std::sync::Arc;
    use std::time::{Duration, Instant};
    
    #[tokio::test]
    #[ignore] // Run with --ignored flag
    async fn load_test_user_operations() {
        let provider = create_test_provider().await;
        let tenant_id = "load-test-tenant";
        
        let concurrent_operations = 100;
        let operations_per_task = 10;
        
        let start_time = Instant::now();
        let mut tasks = JoinSet::new();
        
        for task_id in 0..concurrent_operations {
            let provider = provider.clone();
            let tenant_id = tenant_id.to_string();
            
            tasks.spawn(async move {
                for i in 0..operations_per_task {
                    let user = ScimUser::builder()
                        .username(&amp;format!("user-{}-{}", task_id, i))
                        .given_name("Load")
                        .family_name("Test")
                        .email(&amp;format!("user-{}-{}@test.com", task_id, i))
                        .build()
                        .unwrap();
                    
                    // Create user
                    let created = provider.create_user(&amp;tenant_id, user).await.unwrap();
                    
                    // Read user
                    let _read = provider.get_user(&amp;tenant_id, created.id()).await.unwrap();
                    
                    // Update user
                    let mut updated = created;
                    updated.set_given_name("Updated");
                    let _updated = provider.update_user(&amp;tenant_id, updated).await.unwrap();
                }
            });
        }
        
        // Wait for all tasks to complete
        while let Some(result) = tasks.join_next().await {
            result.unwrap();
        }
        
        let total_duration = start_time.elapsed();
        let total_operations = concurrent_operations * operations_per_task * 3; // create, read, update
        let ops_per_second = total_operations as f64 / total_duration.as_secs_f64();
        
        println!("Load test completed:");
        println!("  Total operations: {}", total_operations);
        println!("  Total duration: {:?}", total_duration);
        println!("  Operations per second: {:.2}", ops_per_second);
        
        // Assert minimum performance requirements
        assert!(ops_per_second &gt; 100.0, "Performance below threshold: {} ops/sec", ops_per_second);
    }
    
    #[tokio::test]
    #[ignore]
    async fn benchmark_filtering_performance() {
        let provider = create_test_provider().await;
        let tenant_id = "benchmark-tenant";
        
        // Create test data
        for i in 0..1000 {
            let user = ScimUser::builder()
                .username(&amp;format!("user-{}", i))
                .given_name("Benchmark")
                .family_name("User")
                .department(if i % 3 == 0 { "Engineering" } else { "Sales" })
                .active(i % 2 == 0)
                .build()
                .unwrap();
            
            provider.create_user(tenant_id, user).await.unwrap();
        }
        
        // Benchmark different page sizes for pagination performance
        let page_sizes = [10, 50, 100, 500, 1000];
        
        for page_size in page_sizes {
            let start = Instant::now();
            let iterations = 50;
            
            for _ in 0..iterations {
                let options = ListOptions::builder()
                    .count(Some(page_size))
                    .start_index(Some(1))
                    .build();
                
                let results = provider.list_users(tenant_id, &amp;options).await.unwrap();
                
                // Simulate in-memory filtering work
                let _active_users: Vec&lt;_&gt; = results.resources.into_iter()
                    .filter(|user| user.active())
                    .collect();
            }
            
            let duration = start.elapsed();
            let avg_duration = duration / iterations;
            
            println!("Page size {}: avg {}ms", page_size, avg_duration.as_millis());
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive performance optimization guide covers all major aspects of making SCIM Server performant at scale, from database optimization to application-level caching and monitoring.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-overview"><a class="header" href="#validation-overview">Validation Overview</a></h1>
<p>This section covers the validation architecture and concepts in the SCIM Server library. While the library provides comprehensive built-in validation based on SCIM schemas, you can extend it with custom validation for business rules, compliance requirements, and organization-specific constraints.</p>
<h2 id="what-is-custom-validation"><a class="header" href="#what-is-custom-validation">What is Custom Validation?</a></h2>
<p>Custom validation in SCIM Server allows you to:</p>
<ul>
<li><strong>Enforce business rules</strong> - Complex validation logic beyond schema constraints</li>
<li><strong>Implement compliance requirements</strong> - GDPR, HIPAA, or industry-specific rules</li>
<li><strong>Add organization-specific constraints</strong> - Custom attribute validation</li>
<li><strong>Integrate with external systems</strong> - Real-time validation against external APIs</li>
<li><strong>Implement cross-field validation</strong> - Dependencies between multiple attributes</li>
</ul>
<h2 id="validation-architecture"><a class="header" href="#validation-architecture">Validation Architecture</a></h2>
<h3 id="validation-pipeline"><a class="header" href="#validation-pipeline">Validation Pipeline</a></h3>
<p>The SCIM Server validation pipeline processes requests in this order:</p>
<ol>
<li><strong>Schema Validation</strong> - Built-in SCIM schema compliance</li>
<li><strong>Type Validation</strong> - Data type checking and format validation</li>
<li><strong>Custom Validation</strong> - Your business logic</li>
<li><strong>Storage Validation</strong> - Database constraints and uniqueness checks</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{
    ValidationPipeline, 
    ValidatorChain, 
    SchemaValidator,
    CustomValidator,
    ValidationResult
};

let validation_pipeline = ValidationPipeline::builder()
    .add_validator(SchemaValidator::new())
    .add_validator(TypeValidator::new())
    .add_validator(CustomBusinessRuleValidator::new())
    .add_validator(ComplianceValidator::new())
    .build();
<span class="boring">}</span></code></pre></pre>
<h3 id="core-components"><a class="header" href="#core-components">Core Components</a></h3>
<p>The validation system consists of several key components:</p>
<h4 id="validationcontext"><a class="header" href="#validationcontext">ValidationContext</a></h4>
<p>Provides context information during validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidationContext {
    pub tenant_id: String,
    pub operation: Operation,
    pub resource_type: ResourceType,
    pub authenticated_user: Option&lt;String&gt;,
    pub client_info: ClientInfo,
    pub timestamp: DateTime&lt;Utc&gt;,
}

pub enum Operation {
    Create,
    Update,
    Patch,
    Delete,
    BulkCreate,
    BulkUpdate,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="validationerror"><a class="header" href="#validationerror">ValidationError</a></h4>
<p>Represents validation failures with detailed information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidationError {
    pub code: String,
    pub message: String,
    pub field_path: Option&lt;String&gt;,
    pub severity: ValidationSeverity,
    pub details: Option&lt;serde_json::Value&gt;,
}

impl ValidationError {
    pub fn new(code: &amp;str, message: &amp;str) -&gt; Self {
        Self {
            code: code.to_string(),
            message: message.to_string(),
            field_path: None,
            severity: ValidationSeverity::Error,
            details: None,
        }
    }

    pub fn with_field(mut self, field_path: &amp;str) -&gt; Self {
        self.field_path = Some(field_path.to_string());
        self
    }

    pub fn with_severity(mut self, severity: ValidationSeverity) -&gt; Self {
        self.severity = severity;
        self
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-validator-trait"><a class="header" href="#custom-validator-trait">Custom Validator Trait</a></h3>
<p>Implement the <code>CustomValidator</code> trait for your validation logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use scim_server::models::{User, Group};
use async_trait::async_trait;

#[async_trait]
pub trait CustomValidator: Send + Sync {
    /// Validate a user during creation or update
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt;;
    
    /// Validate a group during creation or update
    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt;;
    
    /// Validate patch operations before applying
    async fn validate_patch_operations(
        &amp;self,
        resource_type: &amp;str,
        resource_id: &amp;str,
        operations: &amp;[PatchOperation],
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt;;
    
    /// Custom validation for batch operations (individual operations in sequence)
    async fn validate_batch_operation(
        &amp;self,
        resource_type: &amp;str,
        operation_type: &amp;str,
        data: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Default implementation - override if needed
        // Validate each operation individually since bulk operations aren't implemented
        match operation_type {
            "CREATE" =&gt; self.validate_create(resource_type, data, context).await,
            "UPDATE" =&gt; self.validate_update(resource_type, data, context).await,
            "PATCH" =&gt; {
                // For patch operations, extract patch operations from data
                if let Ok(operations) = serde_json::from_value::&lt;Vec&lt;PatchOperation&gt;&gt;(data.clone()) {
                    self.validate_patch(resource_type, &amp;operations, context).await
                } else {
                    Err(ValidationError::InvalidData("Invalid patch operations".to_string()))
                }
            },
            _ =&gt; Ok(())
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-strategies"><a class="header" href="#validation-strategies">Validation Strategies</a></h2>
<h3 id="1-synchronous-vs-asynchronous"><a class="header" href="#1-synchronous-vs-asynchronous">1. Synchronous vs Asynchronous</a></h3>
<ul>
<li><strong>Synchronous validation</strong> - Fast, local checks (regex, length, format)</li>
<li><strong>Asynchronous validation</strong> - External API calls, database lookups</li>
</ul>
<h3 id="2-fail-fast-vs-collect-all"><a class="header" href="#2-fail-fast-vs-collect-all">2. Fail-Fast vs Collect-All</a></h3>
<ul>
<li><strong>Fail-Fast</strong> - Stop on first validation error</li>
<li><strong>Collect-All</strong> - Gather all validation errors before failing</li>
</ul>
<h3 id="3-severity-levels"><a class="header" href="#3-severity-levels">3. Severity Levels</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ValidationSeverity {
    Error,   // Blocks the operation
    Warning, // Logs but allows operation  
    Info,    // Informational only
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-points"><a class="header" href="#integration-points">Integration Points</a></h2>
<h3 id="server-configuration"><a class="header" href="#server-configuration">Server Configuration</a></h3>
<p>Register validators during server startup:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::ScimServerBuilder;

let server = ScimServerBuilder::new()
    .with_provider(my_provider)
    .add_validator(BusinessRuleValidator::new())
    .add_validator(ComplianceValidator::new())
    .build();
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-specific-validation"><a class="header" href="#tenant-specific-validation">Tenant-Specific Validation</a></h3>
<p>Different validation rules per tenant:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct TenantValidatorRegistry {
    validators: HashMap&lt;String, Vec&lt;Box&lt;dyn CustomValidator&gt;&gt;&gt;,
}

impl TenantValidatorRegistry {
    pub async fn validate_for_tenant(
        &amp;self,
        tenant_id: &amp;str,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(validators) = self.validators.get(tenant_id) {
            for validator in validators {
                validator.validate_user(user, context).await?;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<h3 id="validation-error-aggregation"><a class="header" href="#validation-error-aggregation">Validation Error Aggregation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValidationResult {
    pub errors: Vec&lt;ValidationError&gt;,
    pub warnings: Vec&lt;ValidationError&gt;,
}

impl ValidationResult {
    pub fn is_valid(&amp;self) -&gt; bool {
        self.errors.is_empty()
    }

    pub fn add_error(&amp;mut self, error: ValidationError) {
        match error.severity {
            ValidationSeverity::Error =&gt; self.errors.push(error),
            ValidationSeverity::Warning =&gt; self.warnings.push(error),
            ValidationSeverity::Info =&gt; { /* Log only */ }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="client-error-response"><a class="header" href="#client-error-response">Client Error Response</a></h3>
<p>Validation errors are returned as SCIM-compliant error responses:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidValue",
  "detail": "Validation failed",
  "errors": [
    {
      "code": "INVALID_EMAIL_DOMAIN",
      "message": "Email domain 'example.com' is not allowed",
      "field": "emails[0].value"
    }
  ]
}
</code></pre>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="validation/./basic.html">Basic Validation</a> - Simple business rule validators</li>
<li><a href="validation/./advanced.html">Advanced Validation</a> - External integrations and complex logic</li>
<li><a href="validation/./field-level.html">Field-Level Validation</a> - Custom attribute validators</li>
<li><a href="validation/./configuration.html">Configuration</a> - Configurable validation rules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-validation"><a class="header" href="#basic-validation">Basic Validation</a></h1>
<p>This guide covers implementing simple, synchronous validation rules for common business requirements. These validators typically perform local checks without external dependencies.</p>
<h2 id="simple-business-rule-validator"><a class="header" href="#simple-business-rule-validator">Simple Business Rule Validator</a></h2>
<p>Here's a comprehensive example of a basic validator that enforces common organizational policies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use scim_server::models::{User, Group};
use regex::Regex;
use async_trait::async_trait;

pub struct BusinessRuleValidator {
    employee_id_pattern: Regex,
    allowed_domains: Vec&lt;String&gt;,
    password_policy: PasswordPolicy,
}

#[derive(Clone)]
pub struct PasswordPolicy {
    pub min_length: usize,
    pub require_uppercase: bool,
    pub require_lowercase: bool,
    pub require_numbers: bool,
    pub require_special_chars: bool,
    pub forbidden_patterns: Vec&lt;Regex&gt;,
}

impl BusinessRuleValidator {
    pub fn new() -&gt; Self {
        Self {
            employee_id_pattern: Regex::new(r"^EMP\d{6}$").unwrap(),
            allowed_domains: vec![
                "company.com".to_string(),
                "subsidiary.com".to_string(),
            ],
            password_policy: PasswordPolicy {
                min_length: 12,
                require_uppercase: true,
                require_lowercase: true,
                require_numbers: true,
                require_special_chars: true,
                forbidden_patterns: vec![
                    Regex::new(r"password").unwrap(),
                    Regex::new(r"123456").unwrap(),
                    Regex::new(r"qwerty").unwrap(),
                ],
            },
        }
    }
}

#[async_trait]
impl CustomValidator for BusinessRuleValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate employee ID format
        if let Some(employee_id) = user.external_id.as_ref() {
            if !self.employee_id_pattern.is_match(employee_id) {
                return Err(ValidationError::new(
                    "INVALID_EMPLOYEE_ID",
                    "Employee ID must follow format EMP123456",
                ).with_field("externalId"));
            }
        }

        // Validate email domain
        if let Some(emails) = &amp;user.emails {
            for (index, email) in emails.iter().enumerate() {
                if let Some(domain) = email.value.split('@').nth(1) {
                    if !self.allowed_domains.contains(&amp;domain.to_lowercase()) {
                        return Err(ValidationError::new(
                            "INVALID_EMAIL_DOMAIN",
                            &amp;format!("Email domain '{}' is not allowed", domain),
                        ).with_field(&amp;format!("emails[{}].value", index)));
                    }
                }
            }
        }

        // Validate password policy (if password is being set)
        if let Some(password) = user.password.as_ref() {
            self.validate_password_policy(password)?;
        }

        // Validate name requirements
        if user.name.is_none() {
            return Err(ValidationError::new(
                "MISSING_NAME",
                "User must have a name",
            ).with_field("name"));
        }

        // Validate username format
        if let Some(username) = &amp;user.username {
            if username.len() &lt; 3 {
                return Err(ValidationError::new(
                    "USERNAME_TOO_SHORT",
                    "Username must be at least 3 characters",
                ).with_field("userName"));
            }
            
            if username.contains(' ') {
                return Err(ValidationError::new(
                    "USERNAME_INVALID_CHARS",
                    "Username cannot contain spaces",
                ).with_field("userName"));
            }
        }

        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate group display name
        if group.display_name.is_empty() {
            return Err(ValidationError::new(
                "EMPTY_GROUP_NAME",
                "Group display name cannot be empty",
            ).with_field("displayName"));
        }

        // Validate group name format
        if group.display_name.len() &gt; 64 {
            return Err(ValidationError::new(
                "GROUP_NAME_TOO_LONG",
                "Group display name cannot exceed 64 characters",
            ).with_field("displayName"));
        }

        // Check for reserved group names
        let reserved_names = vec!["admin", "root", "system", "administrator"];
        if reserved_names.contains(&amp;group.display_name.to_lowercase().as_str()) {
            return Err(ValidationError::new(
                "RESERVED_GROUP_NAME",
                &amp;format!("'{}' is a reserved group name", group.display_name),
            ).with_field("displayName"));
        }

        // Validate member limit
        if let Some(members) = &amp;group.members {
            if members.len() &gt; 1000 {
                return Err(ValidationError::new(
                    "TOO_MANY_MEMBERS",
                    "Group cannot have more than 1000 members",
                ).with_field("members"));
            }
        }

        Ok(())
    }
}

impl BusinessRuleValidator {
    fn validate_password_policy(&amp;self, password: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let policy = &amp;self.password_policy;

        // Check minimum length
        if password.len() &lt; policy.min_length {
            return Err(ValidationError::new(
                "PASSWORD_TOO_SHORT",
                &amp;format!("Password must be at least {} characters", policy.min_length),
            ).with_field("password"));
        }

        // Check character requirements
        if policy.require_uppercase &amp;&amp; !password.chars().any(|c| c.is_uppercase()) {
            return Err(ValidationError::new(
                "PASSWORD_MISSING_UPPERCASE",
                "Password must contain at least one uppercase letter",
            ).with_field("password"));
        }

        if policy.require_lowercase &amp;&amp; !password.chars().any(|c| c.is_lowercase()) {
            return Err(ValidationError::new(
                "PASSWORD_MISSING_LOWERCASE",
                "Password must contain at least one lowercase letter",
            ).with_field("password"));
        }

        if policy.require_numbers &amp;&amp; !password.chars().any(|c| c.is_numeric()) {
            return Err(ValidationError::new(
                "PASSWORD_MISSING_NUMBER",
                "Password must contain at least one number",
            ).with_field("password"));
        }

        if policy.require_special_chars &amp;&amp; !password.chars().any(|c| "!@#$%^&amp;*()".contains(c)) {
            return Err(ValidationError::new(
                "PASSWORD_MISSING_SPECIAL",
                "Password must contain at least one special character",
            ).with_field("password"));
        }

        // Check forbidden patterns
        for pattern in &amp;policy.forbidden_patterns {
            if pattern.is_match(&amp;password.to_lowercase()) {
                return Err(ValidationError::new(
                    "PASSWORD_FORBIDDEN_PATTERN",
                    "Password contains forbidden pattern",
                ).with_field("password"));
            }
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="department-based-validation"><a class="header" href="#department-based-validation">Department-Based Validation</a></h2>
<p>Validate users based on their department or role:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use std::collections::HashMap;

pub struct DepartmentValidator {
    department_rules: HashMap&lt;String, DepartmentRules&gt;,
}

#[derive(Clone)]
pub struct DepartmentRules {
    pub required_attributes: Vec&lt;String&gt;,
    pub allowed_email_domains: Vec&lt;String&gt;,
    pub max_group_memberships: usize,
    pub requires_manager: bool,
}

impl DepartmentValidator {
    pub fn new() -&gt; Self {
        let mut department_rules = HashMap::new();
        
        // IT Department rules
        department_rules.insert("IT".to_string(), DepartmentRules {
            required_attributes: vec!["employeeNumber".to_string(), "title".to_string()],
            allowed_email_domains: vec!["company.com".to_string()],
            max_group_memberships: 20,
            requires_manager: true,
        });
        
        // HR Department rules  
        department_rules.insert("HR".to_string(), DepartmentRules {
            required_attributes: vec!["employeeNumber".to_string(), "title".to_string(), "phoneNumber".to_string()],
            allowed_email_domains: vec!["company.com".to_string()],
            max_group_memberships: 10,
            requires_manager: true,
        });
        
        // Contractor rules
        department_rules.insert("CONTRACTOR".to_string(), DepartmentRules {
            required_attributes: vec!["contractEndDate".to_string()],
            allowed_email_domains: vec!["contractor.company.com".to_string()],
            max_group_memberships: 5,
            requires_manager: false,
        });

        Self { department_rules }
    }
}

#[async_trait]
impl CustomValidator for DepartmentValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Get user's department from custom attributes
        let department = user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("department"))
            .and_then(|v| v.as_str())
            .unwrap_or("UNKNOWN");

        if let Some(rules) = self.department_rules.get(department) {
            // Check required attributes
            for required_attr in &amp;rules.required_attributes {
                if !user.extension_attributes
                    .as_ref()
                    .map(|attrs| attrs.contains_key(required_attr))
                    .unwrap_or(false) {
                    return Err(ValidationError::new(
                        "MISSING_REQUIRED_ATTRIBUTE",
                        &amp;format!("Department {} requires attribute '{}'", department, required_attr),
                    ).with_field(&amp;format!("enterpriseUser:{}", required_attr)));
                }
            }

            // Validate email domain for department
            if let Some(emails) = &amp;user.emails {
                for (index, email) in emails.iter().enumerate() {
                    if let Some(domain) = email.value.split('@').nth(1) {
                        if !rules.allowed_email_domains.contains(&amp;domain.to_lowercase()) {
                            return Err(ValidationError::new(
                                "INVALID_DEPARTMENT_EMAIL_DOMAIN",
                                &amp;format!("Department {} does not allow email domain '{}'", department, domain),
                            ).with_field(&amp;format!("emails[{}].value", index)));
                        }
                    }
                }
            }

            // Check manager requirement
            if rules.requires_manager {
                let has_manager = user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("manager"))
                    .is_some();
                    
                if !has_manager {
                    return Err(ValidationError::new(
                        "MISSING_MANAGER",
                        &amp;format!("Department {} requires a manager to be assigned", department),
                    ).with_field("enterpriseUser:manager"));
                }
            }
        }

        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Basic group validation for department-based rules
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="attribute-format-validation"><a class="header" href="#attribute-format-validation">Attribute Format Validation</a></h2>
<p>Validate specific attribute formats beyond basic schema validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AttributeFormatValidator {
    phone_regex: Regex,
    ssn_regex: Regex,
    employee_id_regex: Regex,
}

impl AttributeFormatValidator {
    pub fn new() -&gt; Self {
        Self {
            phone_regex: Regex::new(r"^\+1-\d{3}-\d{3}-\d{4}$").unwrap(),
            ssn_regex: Regex::new(r"^\d{3}-\d{2}-\d{4}$").unwrap(), 
            employee_id_regex: Regex::new(r"^[A-Z]{2}\d{6}$").unwrap(),
        }
    }

    fn validate_phone_number(&amp;self, phone: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        if !self.phone_regex.is_match(phone) {
            return Err(ValidationError::new(
                "INVALID_PHONE_FORMAT",
                "Phone number must be in format +1-XXX-XXX-XXXX",
            ));
        }
        Ok(())
    }

    fn validate_ssn(&amp;self, ssn: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        if !self.ssn_regex.is_match(ssn) {
            return Err(ValidationError::new(
                "INVALID_SSN_FORMAT", 
                "SSN must be in format XXX-XX-XXXX",
            ));
        }

        // Additional SSN validation rules
        let parts: Vec&lt;&amp;str&gt; = ssn.split('-').collect();
        if parts.len() == 3 {
            // Check for invalid area numbers
            if let Ok(area) = parts[0].parse::&lt;u32&gt;() {
                if area == 0 || area == 666 || area &gt;= 900 {
                    return Err(ValidationError::new(
                        "INVALID_SSN_AREA",
                        "Invalid SSN area number",
                    ));
                }
            }
        }
        Ok(())
    }
}

#[async_trait]
impl CustomValidator for AttributeFormatValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate phone numbers
        if let Some(phone_numbers) = &amp;user.phone_numbers {
            for (index, phone) in phone_numbers.iter().enumerate() {
                self.validate_phone_number(&amp;phone.value)
                    .map_err(|mut e| {
                        e.field_path = Some(format!("phoneNumbers[{}].value", index));
                        e
                    })?;
            }
        }

        // Validate custom attributes
        if let Some(attrs) = &amp;user.extension_attributes {
            // Validate SSN if present
            if let Some(ssn_value) = attrs.get("ssn") {
                if let Some(ssn_str) = ssn_value.as_str() {
                    self.validate_ssn(ssn_str)
                        .map_err(|mut e| {
                            e.field_path = Some("enterpriseUser:ssn".to_string());
                            e
                        })?;
                }
            }

            // Validate employee ID
            if let Some(emp_id_value) = attrs.get("employeeNumber") {
                if let Some(emp_id_str) = emp_id_value.as_str() {
                    if !self.employee_id_regex.is_match(emp_id_str) {
                        return Err(ValidationError::new(
                            "INVALID_EMPLOYEE_ID_FORMAT",
                            "Employee ID must be in format XX123456",
                        ).with_field("enterpriseUser:employeeNumber"));
                    }
                }
            }
        }

        Ok(())
    }

    async fn validate_group(
        &amp;self,
        _group: &amp;Group,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-example"><a class="header" href="#usage-example">Usage Example</a></h2>
<p>Here's how to register and use these basic validators:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::ScimServerBuilder;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = ScimServerBuilder::new()
        .with_provider(my_provider)
        .add_validator(BusinessRuleValidator::new())
        .add_validator(DepartmentValidator::new())
        .add_validator(AttributeFormatValidator::new())
        .build();

    // Start server
    server.run().await?;
    Ok(())
}</code></pre></pre>
<h2 id="testing-basic-validators"><a class="header" href="#testing-basic-validators">Testing Basic Validators</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use scim_server::models::{User, Name, Email};

    #[tokio::test]
    async fn test_business_rule_validation() {
        let validator = BusinessRuleValidator::new();
        let context = ValidationContext::default();

        // Test valid user
        let mut user = User::default();
        user.username = Some("john.doe".to_string());
        user.external_id = Some("EMP123456".to_string());
        user.name = Some(Name {
            formatted: Some("John Doe".to_string()),
            family_name: Some("Doe".to_string()),
            given_name: Some("John".to_string()),
            ..Default::default()
        });
        user.emails = Some(vec![Email {
            value: "john.doe@company.com".to_string(),
            primary: Some(true),
            ..Default::default()
        }]);

        assert!(validator.validate_user(&amp;user, &amp;context).await.is_ok());

        // Test invalid employee ID
        user.external_id = Some("INVALID123".to_string());
        let result = validator.validate_user(&amp;user, &amp;context).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code, "INVALID_EMPLOYEE_ID");
    }

    #[tokio::test]
    async fn test_password_policy() {
        let validator = BusinessRuleValidator::new();
        
        // Test weak password
        let weak_password = "password123";
        let result = validator.validate_password_policy(weak_password);
        assert!(result.is_err());

        // Test strong password
        let strong_password = "MySecure123!Password";
        let result = validator.validate_password_policy(strong_password);
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="validation/./advanced.html">Advanced Validation</a> - External system integration and complex logic</li>
<li><a href="validation/./field-level.html">Field-Level Validation</a> - Granular attribute validation</li>
<li><a href="validation/./configuration.html">Configuration</a> - Dynamic validation rules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-validation"><a class="header" href="#advanced-validation">Advanced Validation</a></h1>
<p>This guide covers complex validation scenarios including external system integration, conditional validation, and sophisticated business logic that requires asynchronous operations or external dependencies.</p>
<h2 id="external-system-integration"><a class="header" href="#external-system-integration">External System Integration</a></h2>
<h3 id="hr-system-validation"><a class="header" href="#hr-system-validation">HR System Validation</a></h3>
<p>Validate users against external HR systems to ensure data consistency:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use reqwest::Client;
use serde_json::json;
use std::time::Duration;
use async_trait::async_trait;

pub struct ExternalValidationService {
    http_client: Client,
    hr_system_url: String,
    compliance_service_url: String,
    api_key: String,
}

impl ExternalValidationService {
    pub fn new(hr_system_url: String, compliance_service_url: String, api_key: String) -&gt; Self {
        Self {
            http_client: Client::new(),
            hr_system_url,
            compliance_service_url,
            api_key,
        }
    }
}

#[async_trait]
impl CustomValidator for ExternalValidationService {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate against HR system
        self.validate_against_hr_system(user).await?;
        
        // Validate compliance requirements
        self.validate_compliance_requirements(user, context).await?;
        
        // Validate security clearance if present
        if let Some(security_clearance) = self.extract_security_clearance(user) {
            self.validate_security_clearance(&amp;security_clearance, user).await?;
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate group against organizational structure
        self.validate_group_structure(group, context).await?;
        Ok(())
    }
}

impl ExternalValidationService {
    async fn validate_against_hr_system(&amp;self, user: &amp;User) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(employee_number) = self.extract_employee_number(user) {
            let response = self.http_client
                .get(&amp;format!("{}/employees/{}", self.hr_system_url, employee_number))
                .header("Authorization", format!("Bearer {}", self.api_key))
                .timeout(Duration::from_secs(5))
                .send()
                .await
                .map_err(|e| ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("Failed to validate employee: {}", e),
                ))?;
            
            if response.status() == 404 {
                return Err(ValidationError::new(
                    "EMPLOYEE_NOT_FOUND",
                    "Employee not found in HR system",
                ).with_field("enterpriseUser:employeeNumber"));
            }
            
            if !response.status().is_success() {
                return Err(ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("HR system returned status: {}", response.status()),
                ));
            }
            
            let hr_employee: HrEmployee = response.json().await
                .map_err(|e| ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("Failed to parse HR response: {}", e),
                ))?;
            
            // Validate employee status
            if hr_employee.status != "ACTIVE" {
                return Err(ValidationError::new(
                    "EMPLOYEE_INACTIVE",
                    &amp;format!("Employee status in HR system is: {}", hr_employee.status),
                ).with_field("active"));
            }
            
            // Validate department consistency
            if let Some(department) = self.extract_department(user) {
                if hr_employee.department != department {
                    return Err(ValidationError::new(
                        "DEPARTMENT_MISMATCH",
                        "Department does not match HR system",
                    ).with_field("enterpriseUser:department"));
                }
            }

            // Validate manager hierarchy
            if let Some(manager_id) = self.extract_manager_id(user) {
                if let Some(hr_manager_id) = hr_employee.manager_id {
                    if manager_id != hr_manager_id {
                        return Err(ValidationError::new(
                            "MANAGER_MISMATCH",
                            "Manager does not match HR system",
                        ).with_field("enterpriseUser:manager"));
                    }
                }
            }
        }
        
        Ok(())
    }
    
    async fn validate_compliance_requirements(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let compliance_request = json!({
            "user_data": {
                "name": user.name,
                "emails": user.emails,
                "phone_numbers": user.phone_numbers,
                "addresses": user.addresses,
                "country": self.extract_country(user),
            },
            "tenant_id": context.tenant_id,
            "operation": context.operation,
        });
        
        let response = self.http_client
            .post(&amp;format!("{}/validate", self.compliance_service_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&amp;compliance_request)
            .timeout(Duration::from_secs(10))
            .send()
            .await
            .map_err(|e| ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Failed to validate compliance: {}", e),
            ))?;
        
        if !response.status().is_success() {
            return Err(ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Compliance service returned status: {}", response.status()),
            ));
        }
        
        let compliance_result: ComplianceValidationResult = response.json().await
            .map_err(|e| ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Failed to parse compliance response: {}", e),
            ))?;
        
        if !compliance_result.is_compliant {
            let violations = compliance_result.violations.join(", ");
            return Err(ValidationError::new(
                "COMPLIANCE_VIOLATION",
                &amp;format!("Compliance violations: {}", violations),
            ));
        }
        
        Ok(())
    }
    
    async fn validate_security_clearance(
        &amp;self,
        security_clearance: &amp;str,
        user: &amp;User,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate security clearance levels
        let valid_clearances = ["PUBLIC", "CONFIDENTIAL", "SECRET", "TOP_SECRET"];
        if !valid_clearances.contains(&amp;security_clearance) {
            return Err(ValidationError::new(
                "INVALID_SECURITY_CLEARANCE",
                &amp;format!("Invalid security clearance level: {}", security_clearance),
            ).with_field("enterpriseUser:securityClearance"));
        }
        
        // Validate clearance requirements based on department
        if let Some(department) = self.extract_department(user) {
            match department.as_str() {
                "Defense" | "Intelligence" =&gt; {
                    if security_clearance == "PUBLIC" {
                        return Err(ValidationError::new(
                            "INSUFFICIENT_CLEARANCE",
                            "Department requires minimum CONFIDENTIAL clearance",
                        ).with_field("enterpriseUser:securityClearance"));
                    }
                }
                "Research" =&gt; {
                    if !["CONFIDENTIAL", "SECRET", "TOP_SECRET"].contains(&amp;security_clearance) {
                        return Err(ValidationError::new(
                            "INSUFFICIENT_CLEARANCE",
                            "Research department requires minimum CONFIDENTIAL clearance",
                        ).with_field("enterpriseUser:securityClearance"));
                    }
                }
                _ =&gt; {} // No special requirements
            }
        }
        
        Ok(())
    }

    async fn validate_group_structure(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate against organizational chart
        let org_response = self.http_client
            .get(&amp;format!("{}/organizational-chart/{}", self.hr_system_url, context.tenant_id))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await
            .map_err(|e| ValidationError::new(
                "ORG_CHART_ERROR",
                &amp;format!("Failed to fetch organizational chart: {}", e),
            ))?;

        let org_chart: OrganizationalChart = org_response.json().await
            .map_err(|e| ValidationError::new(
                "ORG_CHART_ERROR", 
                &amp;format!("Failed to parse org chart: {}", e),
            ))?;

        // Validate group exists in org chart
        if !org_chart.groups.iter().any(|g| g.name == group.display_name) {
            return Err(ValidationError::new(
                "GROUP_NOT_IN_ORG_CHART",
                "Group does not exist in organizational chart",
            ).with_field("displayName"));
        }

        Ok(())
    }

    // Helper methods for extracting user attributes
    fn extract_employee_number(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("employeeNumber"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_department(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("department"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_manager_id(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("manager"))
            .and_then(|v| v.get("value"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_security_clearance(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("securityClearance"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_country(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.addresses
            .as_ref()
            .and_then(|addrs| addrs.first())
            .map(|addr| addr.country.clone())
            .unwrap_or_default()
    }
}

// Supporting types
#[derive(serde::Deserialize)]
struct HrEmployee {
    employee_id: String,
    status: String,
    department: String,
    manager_id: Option&lt;String&gt;,
    hire_date: String,
    termination_date: Option&lt;String&gt;,
}

#[derive(serde::Deserialize)]
struct ComplianceValidationResult {
    is_compliant: bool,
    violations: Vec&lt;String&gt;,
    severity: String,
}

#[derive(serde::Deserialize)]
struct OrganizationalChart {
    groups: Vec&lt;OrgGroup&gt;,
}

#[derive(serde::Deserialize)]
struct OrgGroup {
    name: String,
    parent: Option&lt;String&gt;,
    level: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conditional-validation"><a class="header" href="#conditional-validation">Conditional Validation</a></h2>
<p>Implement validation rules that apply only under specific conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use std::collections::HashMap;

pub struct ConditionalValidator {
    rules: Vec&lt;ConditionalRule&gt;,
}

pub struct ConditionalRule {
    pub name: String,
    pub condition: fn(&amp;User, &amp;ValidationContext) -&gt; bool,
    pub validator: fn(&amp;User, &amp;ValidationContext) -&gt; Result&lt;(), ValidationError&gt;,
}

impl ConditionalValidator {
    pub fn new() -&gt; Self {
        let mut rules = Vec::new();
        
        // Rule: Contractors must have end date
        rules.push(ConditionalRule {
            name: "contractor_end_date".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("userType"))
                    .and_then(|v| v.as_str()) == Some("Contractor")
            },
            validator: |user, _| {
                let has_end_date = user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("employmentEndDate"))
                    .is_some();
                    
                if !has_end_date {
                    return Err(ValidationError::new(
                        "MISSING_END_DATE",
                        "Contractors must have an employment end date",
                    ).with_field("enterpriseUser:employmentEndDate"));
                }
                Ok(())
            },
        });
        
        // Rule: VIP users require additional security
        rules.push(ConditionalRule {
            name: "vip_security_requirements".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("vipStatus"))
                    .and_then(|v| v.as_bool())
                    .unwrap_or(false)
            },
            validator: |user, _| {
                // Check for required security attributes
                let security_attrs = ["securityClearance", "backgroundCheckDate", "securityTraining"];
                
                for attr in &amp;security_attrs {
                    if !user.extension_attributes
                        .as_ref()
                        .map(|attrs| attrs.contains_key(*attr))
                        .unwrap_or(false) {
                        return Err(ValidationError::new(
                            "MISSING_VIP_SECURITY_ATTR",
                            &amp;format!("VIP users must have {} attribute", attr),
                        ).with_field(&amp;format!("enterpriseUser:{}", attr)));
                    }
                }
                Ok(())
            },
        });
        
        // Rule: Remote workers require specific equipment
        rules.push(ConditionalRule {
            name: "remote_worker_equipment".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("workLocation"))
                    .and_then(|v| v.as_str()) == Some("Remote")
            },
            validator: |user, _| {
                let required_equipment = ["laptop", "vpnAccess", "phoneStipend"];
                
                for equipment in &amp;required_equipment {
                    if !user.extension_attributes
                        .as_ref()
                        .and_then(|attrs| attrs.get("equipment"))
                        .and_then(|v| v.as_array())
                        .map(|arr| arr.iter().any(|item| 
                            item.as_str().map(|s| s == *equipment).unwrap_or(false)
                        ))
                        .unwrap_or(false) {
                        return Err(ValidationError::new(
                            "MISSING_REMOTE_EQUIPMENT",
                            &amp;format!("Remote workers must have {} assigned", equipment),
                        ).with_field("enterpriseUser:equipment"));
                    }
                }
                Ok(())
            },
        });

        Self { rules }
    }
}

#[async_trait]
impl CustomValidator for ConditionalValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        for rule in &amp;self.rules {
            if (rule.condition)(user, context) {
                (rule.validator)(user, context)?;
            }
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        _group: &amp;Group,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Groups don't typically need conditional validation
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="async-workflow-integration"><a class="header" href="#async-workflow-integration">Async Workflow Integration</a></h2>
<p>Integrate with approval workflows and external processes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use tokio::time::{sleep, Duration};

pub struct WorkflowValidator {
    workflow_client: WorkflowClient,
    approval_timeout: Duration,
}

impl WorkflowValidator {
    pub fn new(workflow_url: String, api_key: String) -&gt; Self {
        Self {
            workflow_client: WorkflowClient::new(workflow_url, api_key),
            approval_timeout: Duration::from_secs(30),
        }
    }
}

#[async_trait]
impl CustomValidator for WorkflowValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        match context.operation {
            Operation::Create =&gt; {
                // Check if user creation requires approval
                if self.requires_approval(user, context).await? {
                    self.validate_approval_exists(user, context).await?;
                }
            }
            Operation::Update =&gt; {
                // Check for sensitive attribute changes
                if self.has_sensitive_changes(user, context).await? {
                    self.validate_change_approval(user, context).await?;
                }
            }
            _ =&gt; {}
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Group creation/modification might require approval for certain types
        if self.is_privileged_group(group) {
            self.validate_group_approval(group, context).await?;
        }
        
        Ok(())
    }
}

impl WorkflowValidator {
    async fn requires_approval(&amp;self, user: &amp;User, context: &amp;ValidationContext) -&gt; Result&lt;bool, ValidationError&gt; {
        // External users always require approval
        if self.is_external_user(user) {
            return Ok(true);
        }
        
        // High-privilege roles require approval
        if let Some(roles) = &amp;user.roles {
            let privileged_roles = ["Admin", "Security", "HR"];
            if roles.iter().any(|role| privileged_roles.contains(&amp;role.value.as_str())) {
                return Ok(true);
            }
        }
        
        // Users with high security clearance require approval
        if let Some(clearance) = user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("securityClearance"))
            .and_then(|v| v.as_str()) {
            if ["SECRET", "TOP_SECRET"].contains(&amp;clearance) {
                return Ok(true);
            }
        }
        
        Ok(false)
    }

    async fn validate_approval_exists(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let approval_request = ApprovalRequest {
            request_type: "user_creation".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: user.username.clone().unwrap_or_default(),
            details: serde_json::to_value(user).unwrap_or_default(),
        };

        let approval_status = self.workflow_client
            .check_approval_status(&amp;approval_request)
            .await
            .map_err(|e| ValidationError::new(
                "WORKFLOW_ERROR",
                &amp;format!("Failed to check approval status: {}", e),
            ))?;

        match approval_status.status.as_str() {
            "approved" =&gt; Ok(()),
            "pending" =&gt; {
                // Wait for approval with timeout
                self.wait_for_approval(&amp;approval_request).await
            }
            "rejected" =&gt; {
                Err(ValidationError::new(
                    "APPROVAL_REJECTED",
                    &amp;format!("User creation was rejected: {}", approval_status.reason.unwrap_or_default()),
                ))
            }
            _ =&gt; {
                // Create new approval request
                self.workflow_client
                    .create_approval_request(&amp;approval_request)
                    .await
                    .map_err(|e| ValidationError::new(
                        "WORKFLOW_ERROR",
                        &amp;format!("Failed to create approval request: {}", e),
                    ))?;
                
                Err(ValidationError::new(
                    "APPROVAL_PENDING",
                    "User creation requires approval. Request has been submitted.",
                ))
            }
        }
    }

    async fn wait_for_approval(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;(), ValidationError&gt; {
        let mut attempts = 0;
        let max_attempts = (self.approval_timeout.as_secs() / 5) as usize; // Check every 5 seconds

        while attempts &lt; max_attempts {
            sleep(Duration::from_secs(5)).await;
            
            let status = self.workflow_client
                .check_approval_status(request)
                .await
                .map_err(|e| ValidationError::new(
                    "WORKFLOW_ERROR",
                    &amp;format!("Failed to check approval status: {}", e),
                ))?;

            match status.status.as_str() {
                "approved" =&gt; return Ok(()),
                "rejected" =&gt; return Err(ValidationError::new(
                    "APPROVAL_REJECTED",
                    &amp;format!("Request was rejected: {}", status.reason.unwrap_or_default()),
                )),
                "pending" =&gt; {
                    attempts += 1;
                    continue;
                }
                _ =&gt; return Err(ValidationError::new(
                    "WORKFLOW_ERROR",
                    "Unexpected approval status",
                )),
            }
        }

        Err(ValidationError::new(
            "APPROVAL_TIMEOUT",
            "Approval request timed out",
        ))
    }

    async fn has_sensitive_changes(&amp;self, user: &amp;User, context: &amp;ValidationContext) -&gt; Result&lt;bool, ValidationError&gt; {
        // This would typically compare with the existing user record
        // For brevity, we'll assume sensitive attributes are being checked
        let sensitive_attributes = [
            "roles", "permissions", "securityClearance", 
            "department", "manager", "salary"
        ];
        
        // In a real implementation, you would fetch the existing user
        // and compare the attributes to detect changes
        Ok(true) // Simplified for example
    }

    async fn validate_change_approval(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Similar to validate_approval_exists but for user changes
        let approval_request = ApprovalRequest {
            request_type: "user_modification".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: user.username.clone().unwrap_or_default(),
            details: serde_json::to_value(user).unwrap_or_default(),
        };

        // Check for existing approval or create new request
        self.validate_approval_exists(user, context).await
    }

    async fn validate_group_approval(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let approval_request = ApprovalRequest {
            request_type: "privileged_group_creation".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: group.display_name.clone(),
            details: serde_json::to_value(group).unwrap_or_default(),
        };

        self.validate_approval_exists_for_group(group, &amp;approval_request).await
    }

    async fn validate_approval_exists_for_group(
        &amp;self,
        group: &amp;Group,
        approval_request: &amp;ApprovalRequest,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Similar logic to user approval validation
        let approval_status = self.workflow_client
            .check_approval_status(approval_request)
            .await
            .map_err(|e| ValidationError::new(
                "WORKFLOW_ERROR",
                &amp;format!("Failed to check group approval status: {}", e),
            ))?;

        match approval_status.status.as_str() {
            "approved" =&gt; Ok(()),
            "pending" =&gt; self.wait_for_approval(approval_request).await,
            "rejected" =&gt; Err(ValidationError::new(
                "GROUP_APPROVAL_REJECTED",
                &amp;format!("Group creation was rejected: {}", approval_status.reason.unwrap_or_default()),
            )),
            _ =&gt; {
                self.workflow_client
                    .create_approval_request(approval_request)
                    .await
                    .map_err(|e| ValidationError::new(
                        "WORKFLOW_ERROR",
                        &amp;format!("Failed to create group approval request: {}", e),
                    ))?;
                
                Err(ValidationError::new(
                    "GROUP_APPROVAL_PENDING",
                    "Privileged group creation requires approval. Request has been submitted.",
                ))
            }
        }
    }

    fn is_external_user(&amp;self, user: &amp;User) -&gt; bool {
        if let Some(emails) = &amp;user.emails {
            return emails.iter().any(|email| {
                !email.value.ends_with("@company.com") &amp;&amp; 
                !email.value.ends_with("@subsidiary.com")
            });
        }
        false
    }

    fn is_privileged_group(&amp;self, group: &amp;Group) -&gt; bool {
        let privileged_patterns = ["admin", "security", "hr", "finance", "executive"];
        privileged_patterns.iter().any(|pattern| {
            group.display_name.to_lowercase().contains(pattern)
        })
    }
}

// Supporting types and client
struct WorkflowClient {
    base_url: String,
    api_key: String,
    client: reqwest::Client,
}

impl WorkflowClient {
    fn new(base_url: String, api_key: String) -&gt; Self {
        Self {
            base_url,
            api_key,
            client: reqwest::Client::new(),
        }
    }

    async fn check_approval_status(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;ApprovalStatus, Box&lt;dyn std::error::Error&gt;&gt; {
        let response = self.client
            .get(&amp;format!("{}/approvals/{}", self.base_url, request.get_id()))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;
        
        Ok(response.json().await?)
    }

    async fn create_approval_request(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;ApprovalStatus, Box&lt;dyn std::error::Error&gt;&gt; {
        let response = self.client
            .post(&amp;format!("{}/approvals", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(request)
            .send()
            .await?;
        
        Ok(response.json().await?)
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
struct ApprovalRequest {
    request_type: String,
    tenant_id: String,
    requester: String,
    subject: String,
    details: serde_json::Value,
}

impl ApprovalRequest {
    fn get_id(&amp;self) -&gt; String {
        // Generate ID based on request content
        format!("{}_{}_{}_{}", 
            self.request_type, 
            self.tenant_id, 
            self.requester, 
            self.subject
        )
    }
}

#[derive(serde::Deserialize)]
struct ApprovalStatus {
    status: String,
    reason: Option&lt;String&gt;,
    approved_by: Option&lt;String&gt;,
    approved_at: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-advanced-validators"><a class="header" href="#testing-advanced-validators">Testing Advanced Validators</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use wiremock::{MockServer, Mock, ResponseTemplate};

    #[tokio::test]
    async fn test_external_validation_service() {
        // Setup mock HR system
        let mock_server = MockServer::start().await;
        
        Mock::given(wiremock::matchers::method("GET"))
            .and(wiremock::matchers::path("/employees/EMP123456"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "employee_id": "EMP123456",
                "status": "ACTIVE",
                "department": "Engineering",
                "manager_id": "MGR789"
            })))
            .mount(&amp;mock_server)
            .await;

        let validator = ExternalValidationService::new(
            mock_server.uri(),
            "http://compliance.test".to_string(),
            "test-api-key".to_string(),
        );

        let mut user = User::default();
        user.extension_attributes = Some(serde_json::json!({
            "employeeNumber": "EMP123456",
            "department": "Engineering"
        }).as_object().unwrap().clone());

        let context = ValidationContext::default();
        let result = validator.validate_user(&amp;user, &amp;context).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_conditional_validation() {
        let validator = ConditionalValidator::new();
        
        // Test contractor without end date
        let mut contractor = User::default();
        contractor.extension_attributes = Some(serde_json::json!({
            "userType": "Contractor"
        }).as_object().unwrap().clone());

        let context = ValidationContext::default();
        let result = validator.validate_user(&amp;contractor, &amp;context).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code, "MISSING_END_DATE");

        // Test contractor with end date
        contractor.extension_attributes = Some(serde_json::json!({
            "userType": "Contractor",
            "employmentEndDate": "2024-12-31"
        }).as_object().unwrap().clone());

        let result = validator.validate_user(&amp;contractor, &amp;context).await;
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">use scim_server::ScimServerBuilder;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = ScimServerBuilder::new()
        .with_provider(my_provider)
        .add_validator(ExternalValidationService::new(
            "https://hr.company.com/api".to_string(),
            "https://compliance.company.com/api".to_string(),
            std::env::var("API_KEY")?,
        ))
        .add_validator(ConditionalValidator::new())
        .add_validator(WorkflowValidator::new(
            "https://workflow.company.com/api".to_string(),
            std::env::var("WORKFLOW_API_KEY")?,
        ))
        .build();

    server.run().await?;
    Ok(())
}</code></pre></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li>[Field-</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="field-level-validation"><a class="header" href="#field-level-validation">Field-Level Validation</a></h1>
<p>This guide covers granular validation at the field and attribute level, allowing you to implement custom validation logic for specific user attributes, custom extensions, and complex data types.</p>
<h2 id="custom-attribute-validators"><a class="header" href="#custom-attribute-validators">Custom Attribute Validators</a></h2>
<p>The field-level validation system allows you to register validators for specific attributes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{FieldValidator, ValidationContext, ValidationError};
use std::collections::HashMap;
use regex::Regex;
use async_trait::async_trait;

pub struct CustomAttributeValidator {
    validators: HashMap&lt;String, Box&lt;dyn FieldValidator + Send + Sync&gt;&gt;,
}

#[async_trait]
pub trait FieldValidator {
    async fn validate(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt;;
}

impl CustomAttributeValidator {
    pub fn new() -&gt; Self {
        let mut validators = HashMap::new();
        
        // Phone number validator
        validators.insert(
            "phoneNumbers".to_string(),
            Box::new(PhoneNumberValidator::new()) as Box&lt;dyn FieldValidator + Send + Sync&gt;
        );
        
        // Social Security Number validator
        validators.insert(
            "enterpriseUser:ssn".to_string(),
            Box::new(SsnValidator::new()) as Box&lt;dyn FieldValidator + Send + Sync&gt;
        );
        
        // Employee ID validator
        validators.insert(
            "enterpriseUser:employeeNumber".to_string(),
            Box::new(EmployeeIdValidator::new()) as Box&lt;dyn FieldValidator + Send + Sync&gt;
        );
        
        // Custom business identifier validator
        validators.insert(
            "enterpriseUser:businessId".to_string(),
            Box::new(BusinessIdentifierValidator::new()) as Box&lt;dyn FieldValidator + Send + Sync&gt;
        );
        
        Self { validators }
    }
    
    pub async fn validate_field(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(validator) = self.validators.get(field_name) {
            validator.validate(field_name, value, context).await?;
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="phone-number-validation"><a class="header" href="#phone-number-validation">Phone Number Validation</a></h2>
<p>Comprehensive phone number validation with international format support:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct PhoneNumberValidator {
    allowed_countries: Vec&lt;String&gt;,
    phone_regex: Regex,
    external_validation_enabled: bool,
}

impl PhoneNumberValidator {
    pub fn new() -&gt; Self {
        Self {
            allowed_countries: vec![
                "US".to_string(), 
                "CA".to_string(), 
                "GB".to_string(),
                "DE".to_string(),
                "FR".to_string(),
            ],
            phone_regex: Regex::new(r"^\+[1-9]\d{1,14}$").unwrap(),
            external_validation_enabled: true,
        }
    }
    
    pub fn with_allowed_countries(mut self, countries: Vec&lt;String&gt;) -&gt; Self {
        self.allowed_countries = countries;
        self
    }
    
    pub fn disable_external_validation(mut self) -&gt; Self {
        self.external_validation_enabled = false;
        self
    }
}

#[async_trait]
impl FieldValidator for PhoneNumberValidator {
    async fn validate(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(phone_numbers) = value.as_array() {
            for (index, phone_obj) in phone_numbers.iter().enumerate() {
                if let Some(phone_value) = phone_obj.get("value").and_then(|v| v.as_str()) {
                    self.validate_single_phone(phone_value, field_name, index).await?;
                }
            }
        } else if let Some(phone_value) = value.as_str() {
            // Handle direct string value
            self.validate_single_phone(phone_value, field_name, 0).await?;
        }
        
        Ok(())
    }
}

impl PhoneNumberValidator {
    async fn validate_single_phone(
        &amp;self,
        phone_value: &amp;str,
        field_name: &amp;str,
        index: usize,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let field_path = if field_name.contains("phoneNumbers") {
            format!("{}[{}].value", field_name, index)
        } else {
            field_name.to_string()
        };
        
        // Basic format validation
        if !self.phone_regex.is_match(phone_value) {
            return Err(ValidationError::new(
                "INVALID_PHONE_FORMAT",
                "Phone number must be in international format (+1234567890)",
            ).with_field(&amp;field_path));
        }
        
        // Extract and validate country code
        let country_code = self.extract_country_code(phone_value)?;
        if !self.is_allowed_country_code(&amp;country_code) {
            return Err(ValidationError::new(
                "INVALID_COUNTRY_CODE",
                &amp;format!("Phone number country code '{}' is not allowed", country_code),
            ).with_field(&amp;field_path));
        }
        
        // Validate phone number length for specific countries
        self.validate_country_specific_length(phone_value, &amp;country_code, &amp;field_path)?;
        
        // External validation if enabled
        if self.external_validation_enabled {
            self.validate_with_external_service(phone_value, &amp;field_path).await?;
        }
        
        Ok(())
    }
    
    fn extract_country_code(&amp;self, phone_value: &amp;str) -&gt; Result&lt;String, ValidationError&gt; {
        if phone_value.len() &lt; 2 {
            return Err(ValidationError::new(
                "INVALID_PHONE_LENGTH",
                "Phone number too short",
            ));
        }
        
        // Common country codes
        for length in [1, 2, 3] {
            if phone_value.len() &gt; length {
                let potential_code = &amp;phone_value[1..=length];
                if self.is_valid_country_code(potential_code) {
                    return Ok(potential_code.to_string());
                }
            }
        }
        
        Err(ValidationError::new(
            "UNKNOWN_COUNTRY_CODE",
            "Unable to determine country code",
        ))
    }
    
    fn is_valid_country_code(&amp;self, code: &amp;str) -&gt; bool {
        // Common country codes
        let valid_codes = [
            "1", "7", "20", "27", "30", "31", "32", "33", "34", "36", "39", "40", "41", 
            "43", "44", "45", "46", "47", "48", "49", "51", "52", "53", "54", "55", "56", 
            "57", "58", "60", "61", "62", "63", "64", "65", "66", "81", "82", "84", "86", 
            "90", "91", "92", "93", "94", "95", "98", "212", "213", "216", "218", "220", 
            "221", "222", "223", "224", "225", "226", "227", "228", "229", "230", "231", 
            "232", "233", "234", "235", "236", "237", "238", "239", "240", "241", "242", 
            "243", "244", "245", "246", "247", "248", "249", "250", "251", "252", "253", 
            "254", "255", "256", "257", "258", "260", "261", "262", "263", "264", "265", 
            "266", "267", "268", "269", "290", "291", "297", "298", "299", "350", "351", 
            "352", "353", "354", "355", "356", "357", "358", "359", "370", "371", "372", 
            "373", "374", "375", "376", "377", "378", "380", "381", "382", "383", "385", 
            "386", "387", "389", "420", "421", "423", "500", "501", "502", "503", "504", 
            "505", "506", "507", "508", "509", "590", "591", "592", "593", "594", "595", 
            "596", "597", "598", "599", "670", "672", "673", "674", "675", "676", "677", 
            "678", "679", "680", "681", "682", "683", "684", "685", "686", "687", "688", 
            "689", "690", "691", "692", "850", "852", "853", "855", "856", "880", "886", 
            "960", "961", "962", "963", "964", "965", "966", "967", "968", "970", "971", 
            "972", "973", "974", "975", "976", "977", "992", "993", "994", "995", "996", 
            "998"
        ];
        
        valid_codes.contains(&amp;code)
    }
    
    fn is_allowed_country_code(&amp;self, country_code: &amp;str) -&gt; bool {
        match country_code {
            "1" =&gt; self.allowed_countries.contains(&amp;"US".to_string()) || 
                   self.allowed_countries.contains(&amp;"CA".to_string()),
            "44" =&gt; self.allowed_countries.contains(&amp;"GB".to_string()),
            "49" =&gt; self.allowed_countries.contains(&amp;"DE".to_string()),
            "33" =&gt; self.allowed_countries.contains(&amp;"FR".to_string()),
            _ =&gt; true, // Allow other countries by default
        }
    }
    
    fn validate_country_specific_length(
        &amp;self,
        phone_value: &amp;str,
        country_code: &amp;str,
        field_path: &amp;str,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let expected_lengths = match country_code {
            "1" =&gt; vec![11], // US/Canada: +1 + 10 digits
            "44" =&gt; vec![13], // UK: +44 + 10-11 digits
            "49" =&gt; vec![12, 13], // Germany: +49 + 10-11 digits
            "33" =&gt; vec![12], // France: +33 + 9 digits
            _ =&gt; return Ok(()), // Skip validation for other countries
        };
        
        if !expected_lengths.contains(&amp;phone_value.len()) {
            return Err(ValidationError::new(
                "INVALID_PHONE_LENGTH",
                &amp;format!("Invalid phone number length for country code {}", country_code),
            ).with_field(field_path));
        }
        
        Ok(())
    }
    
    async fn validate_with_external_service(
        &amp;self,
        phone_number: &amp;str,
        field_path: &amp;str,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let client = reqwest::Client::new();
        let response = client
            .get(&amp;format!("https://api.phonevalidation.com/validate/{}", phone_number))
            .timeout(std::time::Duration::from_secs(3))
            .send()
            .await
            .map_err(|_| ValidationError::new(
                "PHONE_VALIDATION_SERVICE_ERROR",
                "Unable to validate phone number with external service",
            ).with_field(field_path))?;
        
        if !response.status().is_success() {
            return Err(ValidationError::new(
                "INVALID_PHONE_NUMBER",
                "Phone number validation failed",
            ).with_field(field_path));
        }
        
        // Parse validation response
        let validation_result: PhoneValidationResult = response.json().await
            .map_err(|_| ValidationError::new(
                "PHONE_VALIDATION_PARSE_ERROR",
                "Failed to parse phone validation response",
            ).with_field(field_path))?;
        
        if !validation_result.is_valid {
            return Err(ValidationError::new(
                "INVALID_PHONE_NUMBER",
                &amp;validation_result.reason.unwrap_or_else(|| "Phone number is invalid".to_string()),
            ).with_field(field_path));
        }
        
        Ok(())
    }
}

#[derive(serde::Deserialize)]
struct PhoneValidationResult {
    is_valid: bool,
    reason: Option&lt;String&gt;,
    carrier: Option&lt;String&gt;,
    line_type: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="social-security-number-validation"><a class="header" href="#social-security-number-validation">Social Security Number Validation</a></h2>
<p>Comprehensive SSN validation with format and uniqueness checks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SsnValidator {
    allow_itin: bool,
    check_uniqueness: bool,
}

impl SsnValidator {
    pub fn new() -&gt; Self {
        Self {
            allow_itin: false,
            check_uniqueness: true,
        }
    }
    
    pub fn allow_itin(mut self, allow: bool) -&gt; Self {
        self.allow_itin = allow;
        self
    }
    
    pub fn check_uniqueness(mut self, check: bool) -&gt; Self {
        self.check_uniqueness = check;
        self
    }
    
    fn validate_ssn_format(&amp;self, ssn: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        // Remove hyphens and spaces
        let cleaned = ssn.replace(['-', ' '], "");
        
        // Must be exactly 9 digits
        if cleaned.len() != 9 || !cleaned.chars().all(|c| c.is_ascii_digit()) {
            return Err(ValidationError::new(
                "INVALID_SSN_FORMAT",
                "SSN must be 9 digits (XXX-XX-XXXX format)",
            ));
        }
        
        // Extract area, group, and serial numbers
        let area = &amp;cleaned[0..3];
        let group = &amp;cleaned[3..5];
        let serial = &amp;cleaned[5..9];
        
        // Validate area number
        self.validate_area_number(area)?;
        
        // Validate group number
        self.validate_group_number(group)?;
        
        // Validate serial number
        self.validate_serial_number(serial)?;
        
        // Check for invalid patterns
        self.validate_patterns(&amp;cleaned)?;
        
        Ok(())
    }
    
    fn validate_area_number(&amp;self, area: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let area_num: u32 = area.parse().unwrap_or(0);
        
        // Invalid area numbers
        if area_num == 0 || area_num == 666 || area_num &gt;= 900 {
            return Err(ValidationError::new(
                "INVALID_SSN_AREA",
                "Invalid SSN area number",
            ));
        }
        
        // Check if it's an ITIN (Individual Taxpayer Identification Number)
        if area_num &gt;= 900 &amp;&amp; area_num &lt;= 999 {
            if !self.allow_itin {
                return Err(ValidationError::new(
                    "ITIN_NOT_ALLOWED",
                    "Individual Taxpayer Identification Numbers (ITIN) are not allowed",
                ));
            }
        }
        
        Ok(())
    }
    
    fn validate_group_number(&amp;self, group: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let group_num: u32 = group.parse().unwrap_or(0);
        
        if group_num == 0 {
            return Err(ValidationError::new(
                "INVALID_SSN_GROUP",
                "Invalid SSN group number (cannot be 00)",
            ));
        }
        
        Ok(())
    }
    
    fn validate_serial_number(&amp;self, serial: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let serial_num: u32 = serial.parse().unwrap_or(0);
        
        if serial_num == 0 {
            return Err(ValidationError::new(
                "INVALID_SSN_SERIAL",
                "Invalid SSN serial number (cannot be 0000)",
            ));
        }
        
        Ok(())
    }
    
    fn validate_patterns(&amp;self, ssn: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        // Invalid SSN patterns
        let invalid_patterns = [
            "000000000", "111111111", "222222222", "333333333",
            "444444444", "555555555", "666666666", "777777777",
            "888888888", "999999999", "123456789", "987654321"
        ];
        
        if invalid_patterns.contains(&amp;ssn) {
            return Err(ValidationError::new(
                "INVALID_SSN_PATTERN",
                "SSN contains an invalid pattern",
            ));
        }
        
        // Check for consecutive digits
        if self.has_consecutive_pattern(ssn) {
            return Err(ValidationError::new(
                "INVALID_SSN_PATTERN",
                "SSN cannot contain repetitive patterns",
            ));
        }
        
        Ok(())
    }
    
    fn has_consecutive_pattern(&amp;self, ssn: &amp;str) -&gt; bool {
        let chars: Vec&lt;char&gt; = ssn.chars().collect();
        
        // Check for all same digits
        if chars.iter().all(|&amp;c| c == chars[0]) {
            return true;
        }
        
        // Check for ascending/descending sequences
        for window in chars.windows(3) {
            if window[0] as u8 + 1 == window[1] as u8 &amp;&amp; window[1] as u8 + 1 == window[2] as u8 {
                return true; // Ascending sequence
            }
            if window[0] as u8 == window[1] as u8 + 1 &amp;&amp; window[1] as u8 == window[2] as u8 + 1 {
                return true; // Descending sequence
            }
        }
        
        false
    }
}

#[async_trait]
impl FieldValidator for SsnValidator {
    async fn validate(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(ssn) = value.as_str() {
            // Validate format
            self.validate_ssn_format(ssn)
                .map_err(|mut e| {
                    e.field_path = Some(field_name.to_string());
                    e
                })?;
            
            // Check uniqueness if enabled
            if self.check_uniqueness {
                // Note: This would require access to the storage provider
                // In practice, you'd inject the storage provider into the validator
                if let Some(storage) = context.storage.as_ref() {
                    if storage.ssn_exists(&amp;context.tenant_id, ssn).await.unwrap_or(false) {
                        return Err(ValidationError::new(
                            "SSN_ALREADY_EXISTS",
                            "Social Security Number is already in use",
                        ).with_field(field_name));
                    }
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="employee-id-validation"><a class="header" href="#employee-id-validation">Employee ID Validation</a></h2>
<p>Custom business identifier validation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct EmployeeIdValidator {
    format_regex: Regex,
    department_prefixes: HashMap&lt;String, String&gt;,
    check_uniqueness: bool,
}

impl EmployeeIdValidator {
    pub fn new() -&gt; Self {
        let mut department_prefixes = HashMap::new();
        department_prefixes.insert("Engineering".to_string(), "ENG".to_string());
        department_prefixes.insert("Sales".to_string(), "SAL".to_string());
        department_prefixes.insert("Marketing".to_string(), "MKT".to_string());
        department_prefixes.insert("HR".to_string(), "HRS".to_string());
        department_prefixes.insert("Finance".to_string(), "FIN".to_string());
        
        Self {
            format_regex: Regex::new(r"^[A-Z]{3}\d{5}$").unwrap(),
            department_prefixes,
            check_uniqueness: true,
        }
    }
    
    pub fn with_custom_format(mut self, regex: &amp;str) -&gt; Result&lt;Self, regex::Error&gt; {
        self.format_regex = Regex::new(regex)?;
        Ok(self)
    }
    
    fn validate_format(&amp;self, employee_id: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        if !self.format_regex.is_match(employee_id) {
            return Err(ValidationError::new(
                "INVALID_EMPLOYEE_ID_FORMAT",
                "Employee ID must follow format: 3 letters + 5 digits (e.g., ENG12345)",
            ));
        }
        
        Ok(())
    }
    
    fn validate_department_prefix(
        &amp;self,
        employee_id: &amp;str,
        user_department: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(department) = user_department {
            if let Some(expected_prefix) = self.department_prefixes.get(department) {
                let prefix = &amp;employee_id[0..3];
                if prefix != expected_prefix {
                    return Err(ValidationError::new(
                        "EMPLOYEE_ID_DEPARTMENT_MISMATCH",
                        &amp;format!(
                            "Employee ID prefix '{}' does not match department '{}' (expected '{}')",
                            prefix, department, expected_prefix
                        ),
                    ));
                }
            }
        }
        
        Ok(())
    }
    
    fn validate_sequence_number(&amp;self, employee_id: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let sequence = &amp;employee_id[3..8];
        let sequence_num: u32 = sequence.parse().unwrap_or(0);
        
        // Sequence number cannot be 00000
        if sequence_num == 0 {
            return Err(ValidationError::new(
                "INVALID_EMPLOYEE_ID_SEQUENCE",
                "Employee ID sequence number cannot be 00000",
            ));
        }
        
        // Validate reasonable range (e.g., 00001-99999)
        if sequence_num &gt; 99999 {
            return Err(ValidationError::new(
                "INVALID_EMPLOYEE_ID_SEQUENCE",
                "Employee ID sequence number must be between 00001 and 99999",
            ));
        }
        
        Ok(())
    }
}

#[async_trait]
impl FieldValidator for EmployeeIdValidator {
    async fn validate(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(employee_id) = value.as_str() {
            // Validate format
            self.validate_format(employee_id)
                .map_err(|mut e| {
                    e.field_path = Some(field_name.to_string());
                    e
                })?;
            
            // Validate sequence number
            self.validate_sequence_number(employee_id)
                .map_err(|mut e| {
                    e.field_path = Some(field_name.to_string());
                    e
                })?;
            
            // Validate department prefix if user has department info
            if let Some(user_data) = context.additional_data.get("user") {
                if let Some(department) = user_data.get("department").and_then(|v| v.as_str()) {
                    self.validate_department_prefix(employee_id, Some(department))
                        .map_err(|mut e| {
                            e.field_path = Some(field_name.to_string());
                            e
                        })?;
                }
            }
            
            // Check uniqueness
            if self.check_uniqueness {
                if let Some(storage) = context.storage.as_ref() {
                    if storage.employee_id_exists(&amp;context.tenant_id, employee_id).await.unwrap_or(false) {
                        return Err(ValidationError::new(
                            "EMPLOYEE_ID_ALREADY_EXISTS",
                            "Employee ID is already in use",
                        ).with_field(field_name));
                    }
                }
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="credit-card-validation-for-financial-applications"><a class="header" href="#credit-card-validation-for-financial-applications">Credit Card Validation (for Financial Applications)</a></h2>
<p>If your application handles financial data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CreditCardValidator {
    allowed_types: Vec&lt;CreditCardType&gt;,
    validate_luhn: bool,
}

#[derive(Debug, Clone, PartialEq)]
pub enum CreditCardType {
    Visa,
    MasterCard,
    AmericanExpress,
    Discover,
    DinersClub,
    JCB,
}

impl CreditCardValidator {
    pub fn new() -&gt; Self {
        Self {
            allowed_types: vec![
                CreditCardType::Visa,
                CreditCardType::MasterCard,
                CreditCardType::AmericanExpress,
            ],
            validate_luhn: true,
        }
    }
    
    pub fn with_allowed_types(mut self, types: Vec&lt;CreditCardType&gt;) -&gt; Self {
        self.allowed_types = types;
        self
    }
    
    fn detect_card_type(&amp;self, number: &amp;str) -&gt; Option&lt;CreditCardType&gt; {
        match number {
            n if n.starts_with('4') =&gt; Some(CreditCardType::Visa),
            n if n.starts_with("51") || n.starts_with("52") || n.starts_with("53") || 
                 n.starts_with("54") || n.starts_with("55") =&gt; Some(CreditCardType::MasterCard),
            n if n.starts_with("34") || n.starts_with("37") =&gt; Some(CreditCardType::AmericanExpress),
            n if n.starts_with("6011") || n.starts_with("65") =&gt; Some(CreditCardType::Discover),
            n if n.starts_with("300") || n.starts_with("301") || n.starts_with("302") ||
                 n.starts_with("303") || n.starts_with("36") || n.starts_with("38") =&gt; Some(CreditCardType::DinersClub),
            n if n.starts_with("35") =&gt; Some(CreditCardType::JCB),
            _ =&gt; None,
        }
    }
    
    fn validate_luhn_algorithm(&amp;self, number: &amp;str) -&gt; bool {
        let digits: Vec&lt;u32&gt; = number.chars()
            .filter_map(|c| c.to_digit(10))
            .collect();
        
        if digits.is_empty() {
            return false;
        }
        
        let checksum = digits.iter()
            .rev()
            .enumerate()
            .map(|(i, &amp;digit)| {
                if i % 2 == 1 {
                    let doubled = digit * 2;
                    if doubled &gt; 9 { doubled - 9 } else { doubled }
                } else {
                    digit
                }
            })
            .sum::&lt;u32&gt;();
        
        checksum % 10 == 0
    }
    
    fn validate_length(&amp;self, number: &amp;str, card_type: &amp;CreditCardType) -&gt; bool {
        match card_type {
            CreditCardType::Visa =&gt; number.len() == 13 || number.len() == 16 || number.len() == 19,
            CreditCardType::MasterCard =&gt; number.len() == 16,
            CreditCardType::AmericanExpress =&gt; number.len() == 15,
            CreditCardType::Discover =&gt; number.len() == 16,
            CreditCardType::DinersClub =&gt; number.len() == 14,
            CreditCardType::JCB =&gt; number.len() == 15 || number.len() == 16,
        }
    }
}

#[async_trait]
impl FieldValidator for CreditCardValidator {
    async fn validate(
        &amp;self,
        field_name: &amp;str,
        value: &amp;serde_json::Value,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(card_number) = value.as_str() {
            // Remove spaces and hyphens
            let cleaned_number = card_number.replace([' ', '-'], "");
            
            // Validate format (digits only)
            if !cleaned_number.chars().all(|c| c.is_ascii_digit()) {
                return Err(ValidationError::new(
                    "INVALID_CREDIT_CARD_FORMAT",
                    "Credit card number must contain only digits",
                ).with_field(field_name));
            }
            
            // Detect card type
            let card_type = self.detect_card_type(&amp;cleaned_number)
                .ok_or_else(|| ValidationError::new(
                    "UNSUPPORTED_CREDIT_CARD_TYPE",
                    "Unsupported credit card type",
                ).with_field(field_name))?;
            
            // Check if card type is allowed
            if !self.allowed_types.contains(&amp;card_type) {
                return Err(ValidationError::new(
                    "CREDIT_CARD_TYPE_NOT_ALLOWED",
                    &amp;format!("Credit card type {:?} is not allowed", card_type),
                ).with_field(field_name));
            }
            
            // Validate length for card type
            if !self.validate_length(&amp;cleaned_number, &amp;card_type) {
                return Err(ValidationError::new(
                    "INVALID_CREDIT_CARD_LENGTH",
                    &amp;format!("Invalid length for {:?} credit card", card_type),
                ).with_field(field_name));
            }
            
            // Validate using Luhn algorithm
            if self.validate_luhn &amp;&amp; !self.validate_luhn_algorithm(&amp;cleaned_number) {
                return Err(ValidationError::new(
                    "INVALID_CREDIT_CARD_CHECKSUM",
                    "Credit card number failed checksum validation",
                ).with_field(field_name));
            }
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-custom-validators"><a class="header" href="#integration-with-custom-validators">Integration with Custom Validators</a></h2>
<p>Use field-level validators within your main custom validators:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};

pub struct ComprehensiveUserValidator {
    field_validator: CustomAttributeValidator,
}

impl ComprehensiveUserValidator {
    pub fn new() -&gt; Self {
        Self {
            field_validator: CustomAttributeValidator::new(),
        }
    }
}

#[async_trait]
impl CustomValidator for ComprehensiveUserValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate phone numbers
        if let Some(phone_numbers) = &amp;user.phone_numbers {
            let phone_value = serde_json::to_value(phone_numbers).unwrap();
            self.field_validator
                .validate_field("phoneNumbers", &amp;phone_value, context)
                .await?;
        }
        
        // Validate enterprise extensions
        if let Some(enterprise_ext) = &amp;user.extension_attributes {
            for (key, value) in enterprise_ext {
                let field_name = format!("enterpriseUser:{}", key);
                self.field_validator
                    .validate_field(&amp;field_name, value, context)
                    .await?;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-configuration"><a class="header" href="#validation-configuration">Validation Configuration</a></h1>
<p>This guide covers configurable validation rules that can be dynamically managed and applied at runtime. Instead of hardcoding validation logic, you can define rules through configuration that can be updated without code changes.</p>
<h2 id="configuration-driven-validation"><a class="header" href="#configuration-driven-validation">Configuration-Driven Validation</a></h2>
<h3 id="validation-configuration-structure"><a class="header" href="#validation-configuration-structure">Validation Configuration Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{ValidationConfig, ValidationRule, RuleEngine};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationConfig {
    pub tenant_id: String,
    pub rules: Vec&lt;ValidationRule&gt;,
    pub external_validators: Vec&lt;ExternalValidatorConfig&gt;,
    pub field_validators: HashMap&lt;String, FieldValidatorConfig&gt;,
    pub global_settings: GlobalValidationSettings,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValidationRule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub enabled: bool,
    pub severity: ValidationSeverity,
    pub resource_types: Vec&lt;String&gt;, // ["User", "Group"]
    pub operations: Vec&lt;String&gt;,     // ["create", "update", "patch"]
    pub conditions: Vec&lt;RuleCondition&gt;,
    pub actions: Vec&lt;ValidationAction&gt;,
    pub priority: u32,
    pub tags: Vec&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationSeverity {
    Error,   // Blocks the operation
    Warning, // Logs but allows operation
    Info,    // Informational only
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleCondition {
    pub field: String,
    pub operator: ConditionOperator,
    pub value: serde_json::Value,
    pub case_sensitive: bool,
    pub negate: bool, // NOT condition
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConditionOperator {
    Equals,
    NotEquals,
    Contains,
    StartsWith,
    EndsWith,
    Regex,
    Length,
    GreaterThan,
    LessThan,
    In,
    NotIn,
    Exists,
    NotExists,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ValidationAction {
    Block { message: String },
    Warn { message: String },
    Log { level: String, message: String },
    Transform { field: String, transformation: String },
    Notify { recipients: Vec&lt;String&gt;, template: String },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GlobalValidationSettings {
    pub max_validation_time_ms: u64,
    pub fail_fast: bool,
    pub enable_external_validation: bool,
    pub cache_validation_results: bool,
    pub cache_ttl_seconds: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExternalValidatorConfig {
    pub name: String,
    pub url: String,
    pub timeout_ms: u64,
    pub retry_count: u32,
    pub headers: HashMap&lt;String, String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FieldValidatorConfig {
    pub validator_type: String,
    pub config: serde_json::Value,
    pub enabled: bool,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rule-engine-implementation"><a class="header" href="#rule-engine-implementation">Rule Engine Implementation</a></h2>
<h3 id="core-rule-engine"><a class="header" href="#core-rule-engine">Core Rule Engine</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use async_trait::async_trait;
use std::time::{Duration, Instant};
use tokio::time::timeout;

pub struct RuleEngine {
    config: ValidationConfig,
    cache: Option&lt;ValidationCache&gt;,
}

impl RuleEngine {
    pub fn new(config: ValidationConfig) -&gt; Self {
        let cache = if config.global_settings.cache_validation_results {
            Some(ValidationCache::new(
                Duration::from_secs(config.global_settings.cache_ttl_seconds)
            ))
        } else {
            None
        };

        Self { config, cache }
    }

    pub async fn validate_resource(
        &amp;self,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;ValidationResult, ValidationError&gt; {
        let start_time = Instant::now();
        let max_duration = Duration::from_millis(self.config.global_settings.max_validation_time_ms);

        // Check cache first
        if let Some(cache) = &amp;self.cache {
            if let Some(cached_result) = cache.get(resource, context).await {
                return Ok(cached_result);
            }
        }

        // Run validation with timeout
        let validation_future = self.validate_internal(resource, context);
        let result = timeout(max_duration, validation_future)
            .await
            .map_err(|_| ValidationError::new(
                "VALIDATION_TIMEOUT",
                "Validation exceeded maximum allowed time",
            ))??;

        // Cache successful results
        if let Some(cache) = &amp;self.cache {
            if result.is_valid() {
                cache.put(resource, context, &amp;result).await;
            }
        }

        Ok(result)
    }

    async fn validate_internal(
        &amp;self,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;ValidationResult, ValidationError&gt; {
        let mut validation_result = ValidationResult::new();
        let applicable_rules = self.get_applicable_rules(resource, context);

        for rule in applicable_rules {
            if !rule.enabled {
                continue;
            }

            match self.evaluate_rule(rule, resource, context).await {
                Ok(rule_result) =&gt; {
                    validation_result.merge(rule_result);
                    
                    // Fail fast if enabled and we have errors
                    if self.config.global_settings.fail_fast &amp;&amp; !validation_result.errors.is_empty() {
                        break;
                    }
                }
                Err(e) =&gt; {
                    validation_result.add_error(e);
                    if self.config.global_settings.fail_fast {
                        break;
                    }
                }
            }
        }

        Ok(validation_result)
    }

    fn get_applicable_rules(
        &amp;self,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) -&gt; Vec&lt;&amp;ValidationRule&gt; {
        let mut applicable_rules: Vec&lt;&amp;ValidationRule&gt; = self.config.rules
            .iter()
            .filter(|rule| {
                // Filter by resource type
                rule.resource_types.is_empty() || 
                rule.resource_types.contains(&amp;resource.resource_type())
            })
            .filter(|rule| {
                // Filter by operation
                rule.operations.is_empty() || 
                rule.operations.contains(&amp;context.operation.to_string())
            })
            .collect();

        // Sort by priority (higher priority first)
        applicable_rules.sort_by(|a, b| b.priority.cmp(&amp;a.priority));
        applicable_rules
    }

    async fn evaluate_rule(
        &amp;self,
        rule: &amp;ValidationRule,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;ValidationResult, ValidationError&gt; {
        let mut rule_result = ValidationResult::new();

        // Evaluate all conditions (AND logic)
        let conditions_met = self.evaluate_conditions(&amp;rule.conditions, resource, context).await?;

        if conditions_met {
            // Execute actions
            for action in &amp;rule.actions {
                self.execute_action(action, rule, resource, context, &amp;mut rule_result).await?;
            }
        }

        Ok(rule_result)
    }

    async fn evaluate_conditions(
        &amp;self,
        conditions: &amp;[RuleCondition],
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        for condition in conditions {
            let condition_met = self.evaluate_condition(condition, resource, context).await?;
            let final_result = if condition.negate { !condition_met } else { condition_met };
            
            if !final_result {
                return Ok(false); // AND logic - all conditions must be true
            }
        }
        
        Ok(true)
    }

    async fn evaluate_condition(
        &amp;self,
        condition: &amp;RuleCondition,
        resource: &amp;dyn ScimResource,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        let field_value = self.extract_field_value(&amp;condition.field, resource)?;

        match &amp;condition.operator {
            ConditionOperator::Equals =&gt; {
                Ok(self.compare_values(&amp;field_value, &amp;condition.value, condition.case_sensitive))
            }
            ConditionOperator::NotEquals =&gt; {
                Ok(!self.compare_values(&amp;field_value, &amp;condition.value, condition.case_sensitive))
            }
            ConditionOperator::Contains =&gt; {
                self.evaluate_contains(&amp;field_value, &amp;condition.value, condition.case_sensitive)
            }
            ConditionOperator::StartsWith =&gt; {
                self.evaluate_starts_with(&amp;field_value, &amp;condition.value, condition.case_sensitive)
            }
            ConditionOperator::EndsWith =&gt; {
                self.evaluate_ends_with(&amp;field_value, &amp;condition.value, condition.case_sensitive)
            }
            ConditionOperator::Regex =&gt; {
                self.evaluate_regex(&amp;field_value, &amp;condition.value)
            }
            ConditionOperator::Length =&gt; {
                self.evaluate_length(&amp;field_value, &amp;condition.value)
            }
            ConditionOperator::GreaterThan =&gt; {
                self.evaluate_greater_than(&amp;field_value, &amp;condition.value)
            }
            ConditionOperator::LessThan =&gt; {
                self.evaluate_less_than(&amp;field_value, &amp;condition.value)
            }
            ConditionOperator::In =&gt; {
                self.evaluate_in(&amp;field_value, &amp;condition.value, condition.case_sensitive)
            }
            ConditionOperator::NotIn =&gt; {
                Ok(!self.evaluate_in(&amp;field_value, &amp;condition.value, condition.case_sensitive)?)
            }
            ConditionOperator::Exists =&gt; {
                Ok(!field_value.is_null())
            }
            ConditionOperator::NotExists =&gt; {
                Ok(field_value.is_null())
            }
        }
    }

    fn extract_field_value(
        &amp;self,
        field_path: &amp;str,
        resource: &amp;dyn ScimResource,
    ) -&gt; Result&lt;serde_json::Value, ValidationError&gt; {
        let resource_json = serde_json::to_value(resource)
            .map_err(|e| ValidationError::new(
                "FIELD_EXTRACTION_ERROR",
                &amp;format!("Failed to serialize resource: {}", e),
            ))?;

        self.extract_nested_value(&amp;resource_json, field_path)
    }

    fn extract_nested_value(
        &amp;self,
        value: &amp;serde_json::Value,
        path: &amp;str,
    ) -&gt; Result&lt;serde_json::Value, ValidationError&gt; {
        let parts: Vec&lt;&amp;str&gt; = path.split('.').collect();
        let mut current = value;

        for part in parts {
            // Handle array access like "emails[0].value"
            if let Some(bracket_pos) = part.find('[') {
                let field_name = &amp;part[..bracket_pos];
                let index_part = &amp;part[bracket_pos + 1..part.len() - 1];
                let index: usize = index_part.parse()
                    .map_err(|_| ValidationError::new(
                        "INVALID_ARRAY_INDEX",
                        &amp;format!("Invalid array index: {}", index_part),
                    ))?;

                current = current.get(field_name)
                    .and_then(|v| v.as_array())
                    .and_then(|arr| arr.get(index))
                    .unwrap_or(&amp;serde_json::Value::Null);
            } else {
                current = current.get(part).unwrap_or(&amp;serde_json::Value::Null);
            }
        }

        Ok(current.clone())
    }

    // Condition evaluation helper methods
    fn compare_values(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
        case_sensitive: bool,
    ) -&gt; bool {
        if !case_sensitive {
            if let (Some(field_str), Some(condition_str)) = (field_value.as_str(), condition_value.as_str()) {
                return field_str.to_lowercase() == condition_str.to_lowercase();
            }
        }
        field_value == condition_value
    }

    fn evaluate_contains(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
        case_sensitive: bool,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        if let (Some(field_str), Some(condition_str)) = (field_value.as_str(), condition_value.as_str()) {
            if case_sensitive {
                Ok(field_str.contains(condition_str))
            } else {
                Ok(field_str.to_lowercase().contains(&amp;condition_str.to_lowercase()))
            }
        } else {
            Ok(false)
        }
    }

    fn evaluate_starts_with(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
        case_sensitive: bool,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        if let (Some(field_str), Some(condition_str)) = (field_value.as_str(), condition_value.as_str()) {
            if case_sensitive {
                Ok(field_str.starts_with(condition_str))
            } else {
                Ok(field_str.to_lowercase().starts_with(&amp;condition_str.to_lowercase()))
            }
        } else {
            Ok(false)
        }
    }

    fn evaluate_ends_with(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
        case_sensitive: bool,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        if let (Some(field_str), Some(condition_str)) = (field_value.as_str(), condition_value.as_str()) {
            if case_sensitive {
                Ok(field_str.ends_with(condition_str))
            } else {
                Ok(field_str.to_lowercase().ends_with(&amp;condition_str.to_lowercase()))
            }
        } else {
            Ok(false)
        }
    }

    fn evaluate_regex(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        if let (Some(field_str), Some(pattern_str)) = (field_value.as_str(), condition_value.as_str()) {
            let regex = regex::Regex::new(pattern_str)
                .map_err(|e| ValidationError::new(
                    "INVALID_REGEX",
                    &amp;format!("Invalid regex pattern: {}", e),
                ))?;
            Ok(regex.is_match(field_str))
        } else {
            Ok(false)
        }
    }

    fn evaluate_length(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        let field_length = match field_value {
            serde_json::Value::String(s) =&gt; s.len(),
            serde_json::Value::Array(arr) =&gt; arr.len(),
            _ =&gt; return Ok(false),
        };

        if let Some(expected_length) = condition_value.as_u64() {
            Ok(field_length == expected_length as usize)
        } else {
            Ok(false)
        }
    }

    fn evaluate_greater_than(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        match (field_value.as_f64(), condition_value.as_f64()) {
            (Some(field_num), Some(condition_num)) =&gt; Ok(field_num &gt; condition_num),
            _ =&gt; Ok(false),
        }
    }

    fn evaluate_less_than(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        match (field_value.as_f64(), condition_value.as_f64()) {
            (Some(field_num), Some(condition_num)) =&gt; Ok(field_num &lt; condition_num),
            _ =&gt; Ok(false),
        }
    }

    fn evaluate_in(
        &amp;self,
        field_value: &amp;serde_json::Value,
        condition_value: &amp;serde_json::Value,
        case_sensitive: bool,
    ) -&gt; Result&lt;bool, ValidationError&gt; {
        if let Some(values_array) = condition_value.as_array() {
            for value in values_array {
                if self.compare_values(field_value, value, case_sensitive) {
                    return Ok(true);
                }
            }
        }
        Ok(false)
    }

    async fn execute_action(
        &amp;self,
        action: &amp;ValidationAction,
        rule: &amp;ValidationRule,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
        result: &amp;mut ValidationResult,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        match action {
            ValidationAction::Block { message } =&gt; {
                let error = ValidationError::new(
                    &amp;format!("RULE_VIOLATION_{}", rule.id.to_uppercase()),
                    message,
                ).with_severity(ValidationSeverity::Error);
                result.add_error(error);
            }
            ValidationAction::Warn { message } =&gt; {
                let warning = ValidationError::new(
                    &amp;format!("RULE_WARNING_{}", rule.id.to_uppercase()),
                    message,
                ).with_severity(ValidationSeverity::Warning);
                result.add_warning(warning);
            }
            ValidationAction::Log { level, message } =&gt; {
                self.log_validation_event(level, message, rule, resource, context).await;
            }
            ValidationAction::Transform { field, transformation } =&gt; {
                // Transform actions would modify the resource
                // This is advanced functionality that requires careful implementation
                self.apply_transformation(field, transformation, resource, result).await?;
            }
            ValidationAction::Notify { recipients, template } =&gt; {
                self.send_notification(recipients, template, rule, resource, context).await?;
            }
        }
        Ok(())
    }

    async fn log_validation_event(
        &amp;self,
        level: &amp;str,
        message: &amp;str,
        rule: &amp;ValidationRule,
        resource: &amp;dyn ScimResource,
        context: &amp;ValidationContext,
    ) {
        // Implementation would depend on your logging system
        match level {
            "error" =&gt; log::error!("Validation rule '{}': {} (resource: {}, tenant: {})", 
                rule.name, message, resource.id().unwrap_or("unknown"), context.tenant_id),
            "warn" =&gt; log::warn!("Validation rule '{}': {} (resource: {}, tenant: {})", 
                rule.name, message, resource.id().unwrap_or("unknown"), context.tenant_id),
            "info" =&gt; log::info!("Validation rule '{}': {} (resource: {}, tenant: {})", 
                rule.name, message, resource.id().unwrap_or("unknown"), context.tenant_id),
            _ =&gt; log::debug!("Validation rule '{}': {} (resource: {}, tenant: {})", 
                rule.name, message, resource.id().unwrap_or("unknown"), context.tenant_id),
        }
    }

    async fn apply_transformation(
        &amp;self,
        _field: &amp;str,
        _transformation: &amp;str,
        _resource: &amp;dyn ScimResource,
        _result: &amp;mut ValidationResult,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Transformation implementation would be complex and resource-specific
        // For now, we'll just log that a transformation was requested
        log::info!("Transformation requested but not implemented");
        Ok(())
    }

    async fn send_notification(
        &amp;self,
        _recipients: &amp;[String],
        _template: &amp;str,
        _rule: &amp;ValidationRule,
        _resource: &amp;dyn ScimResource,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Notification implementation would depend on your notification system
        log::info!("Notification requested but not implemented");
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<h3 id="sample-validation-configuration"><a class="header" href="#sample-validation-configuration">Sample Validation Configuration</a></h3>
<pre><code class="language-yaml"># validation-config.yaml
tenant_id: "company-123"

global_settings:
  max_validation_time_ms: 5000
  fail_fast: false
  enable_external_validation: true
  cache_validation_results: true
  cache_ttl_seconds: 300

rules:
  - id: "email_domain_check"
    name: "Email Domain Validation"
    description: "Ensure users have company email domains"
    enabled: true
    severity: "Error"
    resource_types: ["User"]
    operations: ["create", "update"]
    priority: 100
    conditions:
      - field: "emails[0].value"
        operator: "Regex"
        value: ".*@(company\\.com|subsidiary\\.com)$"
        case_sensitive: false
        negate: false
    actions:
      - Block:
          message: "Users must have a company email address (@company.com or @subsidiary.com)"

  - id: "manager_hierarchy_check"
    name: "Manager Hierarchy Validation"
    description: "Prevent circular manager relationships"
    enabled: true
    severity: "Error"
    resource_types: ["User"]
    operations: ["update", "patch"]
    priority: 90
    conditions:
      - field: "enterpriseUser.manager.value"
        operator: "Exists"
        value: null
        case_sensitive: false
        negate: false
    actions:
      - Block:
          message: "Manager assignment would create a circular reference"
      - Log:
          level: "warn"
          message: "Attempted circular manager assignment detected"

  - id: "contractor_end_date"
    name: "Contractor End Date Required"
    description: "Contractors must have employment end date"
    enabled: true
    severity: "Error"
    resource_types: ["User"]
    operations: ["create", "update"]
    priority: 80
    conditions:
      - field: "enterpriseUser.employeeType"
        operator: "Equals"
        value: "Contractor"
        case_sensitive: false
        negate: false
      - field: "enterpriseUser.employmentEndDate"
        operator: "NotExists"
        value: null
        case_sensitive: false
        negate: false
    actions:
      - Block:
          message: "Contractors must have an employment end date specified"

  - id: "vip_user_notification"
    name: "VIP User Notification"
    description: "Notify security team when VIP users are modified"
    enabled: true
    severity: "Info"
    resource_types: ["User"]
    operations: ["create", "update", "delete"]
    priority: 50
    conditions:
      - field: "enterpriseUser.vipStatus"
        operator: "Equals"
        value: true
        case_sensitive: false
        negate: false
    actions:
      - Log:
          level: "info"
          message: "VIP user account modified"
      - Notify:
          recipients: ["security@company.com", "compliance@company.com"]
          template: "vip_user_modification"

  - id: "username_format"
    name: "Username Format Validation"
    description: "Enforce username format standards"
    enabled: true
    severity: "Warning"
    resource_types: ["User"]
    operations: ["create", "update"]
    priority: 70
    conditions:
      - field: "userName"
        operator: "Regex"
        value: "^[a-z]+\\.[a-z]+$"
        case_sensitive: false
        negate: true
    actions:
      - Warn:
          message: "Username should follow format: firstname.lastname (lowercase, no numbers or special characters)"

field_validators:
  phoneNumbers:
    validator_type: "PhoneNumberValidator"
    enabled: true
    config:
      allowed_countries: ["US", "CA", "GB"]
      external_validation: true

  "enterpriseUser:ssn":
    validator_type: "SsnValidator"
    enabled: true
    config:
      allow_itin: false
      check_uniqueness: true

external_validators:
  - name: "hr_system"
    url: "https://hr.company.com/api/validate"
    timeout_ms: 3000
    retry_count: 2
    headers:
      Authorization: "Bearer ${HR_API_TOKEN}"
      Content-Type: "application/json"
</code></pre>
<h3 id="loading-configuration"><a class="header" href="#loading-configuration">Loading Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_yaml;
use std::fs;

pub struct ConfigurationLoader;

impl ConfigurationLoader {
    pub fn load_from_file(file_path: &amp;str) -&gt; Result&lt;ValidationConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        let config_content = fs::read_to_string(file_path)?;
        let config: ValidationConfig = serde_yaml::from_str(&amp;config_content)?;
        Ok(config)
    }

    pub fn load_from_env() -&gt; Result&lt;ValidationConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        let config_path = std::env::var("VALIDATION_CONFIG_PATH")
            .unwrap_or_else(|_| "validation-config.yaml".to_string());
        Self::load_from_file(&amp;config_path)
    }

    pub async fn load_from_database(
        tenant_id: &amp;str,
        storage: &amp;dyn StorageProvider,
    ) -&gt; Result&lt;ValidationConfig, Box&lt;dyn std::error::Error&gt;&gt; {
        // Load configuration from database
        let config_json = storage.get_tenant_config(tenant_id, "validation").await?;
        let config: ValidationConfig = serde_json::from_str(&amp;config_json)?;
        Ok(config)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dynamic-rule-management"><a class="header" href="#dynamic-rule-management">Dynamic Rule Management</a></h2>
<h3 id="rule-management-api"><a class="header" href="#rule-management-api">Rule Management API</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{ValidationConfig, ValidationRule, RuleEngine};

pub struct ValidationRuleManager {
    storage: Box&lt;dyn StorageProvider&gt;,
    rule_engines: std::sync::RwLock&lt;HashMap&lt;String, RuleEngine&gt;&gt;, // tenant_id -&gt; RuleEngine
}

impl ValidationRuleManager {
    pub fn new(storage: Box&lt;dyn StorageProvider&gt;) -&gt; Self {
        Self {
            storage,
            rule_engines: std::sync::RwLock::new(HashMap::new()),
        }
    }

    pub async fn add_rule(
        &amp;self,
        tenant_id: &amp;str,
        rule: ValidationRule,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate rule configuration
        self.validate_rule_config(&amp;rule)?;

        // Save to storage
        self.storage.save_validation_rule(tenant_id, &amp;rule).await?;

        // Reload configuration for tenant
        self.reload_tenant_config(tenant_id).await?;

        Ok(())
    }

    pub async fn update_rule(
        &amp;self,
        tenant_id: &amp;str,
        rule_id: &amp;str,
        updated_rule: ValidationRule,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        if updated_rule.id != rule_id {
            return Err(ValidationError::new(
                "RULE_ID_MISMATCH",
                "Rule ID in path does not match rule ID in body",
            ));
        }

        self.validate_rule_config(&amp;updated_rule)?;
        self.storage.update_validation_rule(tenant_id, &amp;updated_rule).await?;
        self.reload_tenant_config(tenant_id).await?;

        Ok(())
    }

    pub async fn delete_rule(
        &amp;self,
        tenant_id: &amp;str,
        rule_id: &amp;str,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        self.storage.delete_validation_rule(tenant_id, rule_id).await?;
        self.reload_tenant_config(tenant_id).await?;
        Ok(())
    }

    pub async fn toggle_rule(
        &amp;self,
        tenant_id: &amp;str,
        rule_id: &amp;str,
        enabled: bool,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        self.storage.toggle_validation_rule(tenant_id, rule_id, enabled).await?;
        self.reload_tenant_config(tenant_id).await?;
        Ok(())
    }

    pub async fn get_rule_engine(&amp;self, tenant_id: &amp;str) -&gt; Result&lt;RuleEngine, ValidationError&gt; {
        // Check if we have a cached rule engine
        {
            let engines = self.rule_engines.read().unwrap();
            if let Some(engine) = engines.get(tenant_id) {
                return Ok(engine.clone());
            }
        }

        // Load configuration and create new engine
        let config = self.load_tenant_config(tenant_id).await?;
        let engine = RuleEngine::new(config);

        // Cache the engine
        {
            let mut engines = self.rule_engines.write().unwrap();
            engines.insert(tenant_id.to_string(), engine.clone());
        }

        Ok(engine)
    }

    async fn reload_tenant_config(&amp;self, tenant_id: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        let config = self.load_tenant_config(tenant_id).await?;
        let engine = RuleEngine::new(config);

        let mut engines = self.rule_engines.write().unwrap();
        engines.insert(tenant_id.to_string(), engine);

        Ok(())
    }

    async fn load_tenant_config(&amp;self, tenant_id: &amp;str) -&gt; Result&lt;ValidationConfig, ValidationError&gt; {
        self.storage.get_validation_config(tenant_id).await
            .map_err(|e| ValidationError::new(
                "CONFIG_LOAD_ERROR",
                &amp;format!("Failed to load validation config: {}", e),
            ))
    }

    fn validate_rule_config(&amp;self, rule: &amp;ValidationRule) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate rule ID
        if rule.id.is_empty() {
            return Err(ValidationError::new(
                "INVALID_RULE_ID",
                "Rule ID cannot be empty",
            ));
        }

        // Validate conditions
        for condition in &amp;rule.conditions {
            if condition.field.is_empty() {
                return Err(ValidationError::new(
                    "INVALID_CONDITION_FIELD",
                    "Condition field cannot be empty",
                ));
            }

            // Validate regex patterns
            if matches!(condition.operator, ConditionOperator::Regex) {
                if let Some(pattern) = condition.value.as_str() {
                    regex::Regex::new(pattern).map_err(|e| ValidationError::new(
                        "INVALID_REGEX_PATTERN",
                        &amp;format!("Invalid regex pattern: {}", e),
                    ))?;
                }
            }
        }

        // Validate actions
        if rule.actions.is_empty() {
            return Err(ValidationError::new(
                "NO_ACTIONS_DEFINED",
                "Rule must have at least one action",
            ));
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples-1"><a class="header" href="#usage-examples-1">Usage Examples</a></h2>
<h3 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h3>
<pre><pre class="playground"><code class="language-rust">use scim_server::validation::{ValidationRuleManager, RuleEngine};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provider-architecture"><a class="header" href="#provider-architecture">Provider Architecture</a></h1>
<p>This document explains the two-layer architecture of the SCIM Server library and how storage and resource providers work together.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>The SCIM Server uses a clean separation between storage concerns and SCIM protocol logic through two main abstractions:</p>
<pre><code>┌─────────────────────────────────────────────┐
│                SCIM Server                  │
├─────────────────────────────────────────────┤
│           ResourceProvider Layer            │
│  (SCIM protocol logic, validation, etc.)   │
├─────────────────────────────────────────────┤
│           StorageProvider Layer             │
│    (Pure data persistence operations)      │
└─────────────────────────────────────────────┘
</code></pre>
<h2 id="two-layer-architecture"><a class="header" href="#two-layer-architecture">Two-Layer Architecture</a></h2>
<h3 id="storageprovider-layer-low-level"><a class="header" href="#storageprovider-layer-low-level">StorageProvider Layer (Low-Level)</a></h3>
<p>The <code>StorageProvider</code> trait defines pure data persistence operations that are protocol-agnostic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait StorageProvider: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;

    // Core operations
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt;;
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt;;
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt;;
    
    // Query operations
    async fn list(&amp;self, prefix: StoragePrefix, offset: usize, limit: usize) 
        -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt;;
    async fn find_by_attribute(&amp;self, prefix: StoragePrefix, attribute: &amp;str, value: &amp;str) 
        -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt;;
    async fn exists(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt;;
    async fn count(&amp;self, prefix: StoragePrefix) -&gt; Result&lt;usize, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>Pure PUT/GET/DELETE operations on JSON data</li>
<li>Tenant isolation through hierarchical keys</li>
<li>Basic querying and filtering</li>
<li>Data persistence and retrieval</li>
</ul>
<p><strong>Not Responsible For:</strong></p>
<ul>
<li>SCIM metadata generation (timestamps, versions, etc.)</li>
<li>SCIM validation rules</li>
<li>Business logic (limits, permissions, etc.)</li>
<li>Protocol-specific transformations</li>
</ul>
<h3 id="resourceprovider-layer-high-level"><a class="header" href="#resourceprovider-layer-high-level">ResourceProvider Layer (High-Level)</a></h3>
<p>The <code>ResourceProvider</code> trait defines SCIM-aware operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ResourceProvider: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;

    // SCIM operations
    async fn create_resource(&amp;self, resource_type: &amp;str, data: Value, context: &amp;RequestContext) 
        -&gt; Result&lt;Resource, Self::Error&gt;;
    async fn get_resource(&amp;self, resource_type: &amp;str, id: &amp;str, context: &amp;RequestContext) 
        -&gt; Result&lt;Option&lt;Resource&gt;, Self::Error&gt;;
    async fn update_resource(&amp;self, resource_type: &amp;str, id: &amp;str, data: Value, context: &amp;RequestContext) 
        -&gt; Result&lt;Resource, Self::Error&gt;;
    async fn delete_resource(&amp;self, resource_type: &amp;str, id: &amp;str, context: &amp;RequestContext) 
        -&gt; Result&lt;bool, Self::Error&gt;;
    async fn list_resources(&amp;self, resource_type: &amp;str, query: Option&lt;ListQuery&gt;, context: &amp;RequestContext) 
        -&gt; Result&lt;Vec&lt;Resource&gt;, Self::Error&gt;;
    async fn find_resource_by_attribute(&amp;self, resource_type: &amp;str, attribute: &amp;str, value: &amp;Value, context: &amp;RequestContext) 
        -&gt; Result&lt;Option&lt;Resource&gt;, Self::Error&gt;;
    async fn patch_resource(&amp;self, resource_type: &amp;str, id: &amp;str, patch: Value, context: &amp;RequestContext) 
        -&gt; Result&lt;Resource, Self::Error&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>SCIM metadata generation (timestamps, ETags, versions)</li>
<li>SCIM validation and business rules</li>
<li>Request context handling (tenant isolation)</li>
<li>Resource type management</li>
<li>Patch operation processing</li>
<li>Error translation from storage to SCIM errors</li>
</ul>
<h2 id="key-design-principles"><a class="header" href="#key-design-principles">Key Design Principles</a></h2>
<h3 id="1-separation-of-concerns"><a class="header" href="#1-separation-of-concerns">1. Separation of Concerns</a></h3>
<p><strong>Storage Layer</strong> handles "where" and "how" data is stored:</p>
<ul>
<li>Database connections</li>
<li>File systems</li>
<li>Memory structures</li>
<li>Indexing and optimization</li>
</ul>
<p><strong>Resource Layer</strong> handles "what" the data means:</p>
<ul>
<li>SCIM protocol compliance</li>
<li>Resource validation</li>
<li>Metadata management</li>
<li>Business logic</li>
</ul>
<h3 id="2-putgetdelete-model"><a class="header" href="#2-putgetdelete-model">2. PUT/GET/DELETE Model</a></h3>
<p>The storage layer uses a simple model where CREATE and UPDATE are both PUT operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Both create and update use the same operation
let stored = storage.put(key, data).await?;
<span class="boring">}</span></code></pre></pre>
<p>The distinction between "create" vs "update" is business logic that belongs in the ResourceProvider layer.</p>
<h3 id="3-tenant-isolation"><a class="header" href="#3-tenant-isolation">3. Tenant Isolation</a></h3>
<p>All storage operations are scoped by tenant through the <code>StorageKey</code> structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct StorageKey {
    tenant_id: String,      // "tenant-1" or "default"
    resource_type: String,  // "User", "Group", etc.
    resource_id: String,    // "user-123"
}
<span class="boring">}</span></code></pre></pre>
<p>This provides natural tenant isolation without requiring complex tenant management systems.</p>
<h3 id="4-context-driven-operations"><a class="header" href="#4-context-driven-operations">4. Context-Driven Operations</a></h3>
<p>The ResourceProvider uses <code>RequestContext</code> to determine operational mode:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Single-tenant operation
let context = RequestContext::with_generated_id();

// Multi-tenant operation  
let tenant_context = TenantContext::new("tenant-1".to_string(), "client-1".to_string());
let context = RequestContext::with_tenant_generated_id(tenant_context);
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-patterns-1"><a class="header" href="#implementation-patterns-1">Implementation Patterns</a></h2>
<h3 id="standard-provider-pattern"><a class="header" href="#standard-provider-pattern">Standard Provider Pattern</a></h3>
<p>The most common pattern is using <code>StandardResourceProvider</code> with a pluggable storage backend:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
};

// Create storage backend
let storage = InMemoryStorage::new();

// Create resource provider with storage
let provider = StandardResourceProvider::new(storage);
<span class="boring">}</span></code></pre></pre>
<h3 id="direct-implementation-pattern"><a class="header" href="#direct-implementation-pattern">Direct Implementation Pattern</a></h3>
<p>For simple use cases, you can implement <code>ResourceProvider</code> directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::InMemoryProvider,
    resource::ResourceProvider,
};

// Direct implementation (deprecated in favor of StandardResourceProvider)
let provider = InMemoryProvider::new();
<span class="boring">}</span></code></pre></pre>
<h2 id="available-implementations"><a class="header" href="#available-implementations">Available Implementations</a></h2>
<h3 id="storage-providers-1"><a class="header" href="#storage-providers-1">Storage Providers</a></h3>
<ol>
<li>
<p><strong>InMemoryStorage</strong></p>
<ul>
<li>Thread-safe in-memory storage using <code>HashMap</code></li>
<li>Suitable for testing and development</li>
<li>No persistence across restarts</li>
</ul>
</li>
<li>
<p><strong>Custom Storage</strong> (implement <code>StorageProvider</code>)</p>
<ul>
<li>Database backends (PostgreSQL, MySQL, etc.)</li>
<li>File-based storage</li>
<li>Cloud storage systems</li>
<li>Distributed storage systems</li>
</ul>
</li>
</ol>
<h3 id="resource-providers"><a class="header" href="#resource-providers">Resource Providers</a></h3>
<ol>
<li>
<p><strong>StandardResourceProvider<S></strong></p>
<ul>
<li>Production-ready implementation</li>
<li>Works with any <code>StorageProvider</code></li>
<li>Full SCIM protocol support</li>
<li>Automatic tenant isolation</li>
</ul>
</li>
<li>
<p><strong>InMemoryProvider</strong> (Legacy)</p>
<ul>
<li>Direct in-memory implementation</li>
<li>Deprecated in favor of <code>StandardResourceProvider + InMemoryStorage</code></li>
<li>Maintained for backward compatibility</li>
</ul>
</li>
</ol>
<h2 id="data-flow"><a class="header" href="#data-flow">Data Flow</a></h2>
<p>Here's how a typical request flows through the architecture:</p>
<pre><code>1. HTTP Request → SCIM Server
2. SCIM Server → ResourceProvider.create_resource()
3. ResourceProvider:
   - Validates SCIM data
   - Generates metadata (timestamps, ETag)
   - Determines tenant from RequestContext
   - Creates StorageKey
4. ResourceProvider → StorageProvider.put()
5. StorageProvider:
   - Stores JSON data at key
   - Returns stored data
6. ResourceProvider:
   - Creates Resource from stored data
   - Returns Resource to SCIM Server
7. SCIM Server → HTTP Response
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<p>The architecture uses layered error handling:</p>
<h3 id="storage-errors"><a class="header" href="#storage-errors">Storage Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum StorageError {
    NotFound(String),
    Conflict(String),
    Internal(String),
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-provider-errors"><a class="header" href="#resource-provider-errors">Resource Provider Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each provider defines its own error type
impl From&lt;StorageError&gt; for MyProviderError {
    fn from(storage_error: StorageError) -&gt; Self {
        // Transform storage errors to provider errors
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenancy-architecture"><a class="header" href="#multi-tenancy-architecture">Multi-Tenancy Architecture</a></h2>
<h3 id="automatic-tenant-isolation"><a class="header" href="#automatic-tenant-isolation">Automatic Tenant Isolation</a></h3>
<p>The architecture provides automatic tenant isolation through the key hierarchy:</p>
<pre><code>Storage Layout:
├── tenant-1/
│   ├── User/
│   │   ├── user-123 → {user data}
│   │   └── user-456 → {user data}
│   └── Group/
│       └── group-789 → {group data}
├── tenant-2/
│   ├── User/
│   │   └── user-123 → {different user data}
│   └── Group/
└── default/  (single-tenant mode)
    ├── User/
    └── Group/
</code></pre>
<h3 id="context-based-routing"><a class="header" href="#context-based-routing">Context-Based Routing</a></h3>
<p>The <code>RequestContext</code> determines which tenant namespace to use:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn effective_tenant_id(context: &amp;RequestContext) -&gt; &amp;str {
    context.tenant_context
        .as_ref()
        .map(|tc| tc.tenant_id.as_str())
        .unwrap_or("default")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-3"><a class="header" href="#performance-considerations-3">Performance Considerations</a></h2>
<h3 id="storage-layer-optimizations-1"><a class="header" href="#storage-layer-optimizations-1">Storage Layer Optimizations</a></h3>
<ul>
<li><strong>Connection Pooling</strong>: Implement at the storage layer</li>
<li><strong>Caching</strong>: Can be added as a storage layer decorator</li>
<li><strong>Indexing</strong>: Handle in the storage implementation</li>
<li><strong>Batching</strong>: Implement batch operations in storage</li>
</ul>
<h3 id="resource-layer-optimizations-1"><a class="header" href="#resource-layer-optimizations-1">Resource Layer Optimizations</a></h3>
<ul>
<li><strong>Resource Caching</strong>: Cache parsed Resource objects</li>
<li><strong>Metadata Caching</strong>: Cache computed metadata</li>
<li><strong>Validation Caching</strong>: Cache validation results</li>
</ul>
<h2 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h2>
<h3 id="unit-testing-storage-1"><a class="header" href="#unit-testing-storage-1">Unit Testing Storage</a></h3>
<p>Test storage providers independently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_storage_operations() {
    let storage = MyStorage::new();
    let key = StorageKey::new("tenant1", "User", "123");
    let data = json!({"userName": "test"});
    
    // Test put/get/delete cycle
    storage.put(key.clone(), data.clone()).await.unwrap();
    let retrieved = storage.get(key.clone()).await.unwrap();
    assert_eq!(retrieved, Some(data));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-testing-1"><a class="header" href="#integration-testing-1">Integration Testing</a></h3>
<p>Test the full stack with both layers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_full_stack() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::with_generated_id();
    
    let user = provider.create_resource(
        "User",
        json!({"userName": "test"}),
        &amp;context,
    ).await.unwrap();
    
    assert!(user.get_id().is_some());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="extension-points"><a class="header" href="#extension-points">Extension Points</a></h2>
<h3 id="custom-storage-backends"><a class="header" href="#custom-storage-backends">Custom Storage Backends</a></h3>
<p>Implement <code>StorageProvider</code> for custom backends:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct MyDatabaseStorage {
    pool: ConnectionPool,
}

impl StorageProvider for MyDatabaseStorage {
    type Error = MyStorageError;
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        // Database-specific implementation
    }
    
    // ... implement other methods
}
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-resource-logic"><a class="header" href="#custom-resource-logic">Custom Resource Logic</a></h3>
<p>Extend <code>StandardResourceProvider</code> or implement <code>ResourceProvider</code> directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct CustomResourceProvider&lt;S&gt; {
    storage: S,
    validator: CustomValidator,
}

impl&lt;S: StorageProvider&gt; ResourceProvider for CustomResourceProvider&lt;S&gt; {
    type Error = CustomProviderError;
    
    async fn create_resource(&amp;self, resource_type: &amp;str, data: Value, context: &amp;RequestContext) -&gt; Result&lt;Resource, Self::Error&gt; {
        // Custom validation and processing
        self.validator.validate(&amp;data)?;
        
        // Delegate to storage
        let key = self.build_key(resource_type, context);
        let stored = self.storage.put(key, data).await?;
        
        // Custom post-processing
        Ok(Resource::from_json(resource_type.to_string(), stored)?)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="providers/./basic.html">Basic Implementation</a> - Learn how to implement storage providers</li>
<li><a href="providers/./advanced.html">Advanced Features</a> - Explore advanced provider capabilities</li>
<li><a href="providers/./testing.html">Testing</a> - Comprehensive testing strategies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-provider-implementation"><a class="header" href="#basic-provider-implementation">Basic Provider Implementation</a></h1>
<p>This guide walks you through implementing storage providers for the SCIM Server library. The SCIM Server uses a two-layer architecture that separates storage concerns from SCIM protocol logic.</p>
<h2 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h2>
<p>The SCIM Server uses two main abstractions:</p>
<ul>
<li><strong>StorageProvider</strong>: Low-level trait for pure data persistence (PUT/GET/DELETE operations on JSON)</li>
<li><strong>ResourceProvider</strong>: High-level trait for SCIM-aware operations (handles SCIM metadata, validation, etc.)</li>
</ul>
<p>The library provides <code>StandardResourceProvider</code> which implements <code>ResourceProvider</code> using any <code>StorageProvider</code> backend.</p>
<h2 id="using-the-standard-provider"><a class="header" href="#using-the-standard-provider">Using the Standard Provider</a></h2>
<p>The simplest approach is to use <code>StandardResourceProvider</code> with the built-in <code>InMemoryStorage</code>:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, ResourceProvider},
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Create storage backend
    let storage = InMemoryStorage::new();
    
    // Create provider with storage
    let provider = StandardResourceProvider::new(storage);
    
    // Create a user
    let context = RequestContext::with_generated_id();
    let user = provider.create_resource(
        "User",
        json!({
            "userName": "john.doe",
            "displayName": "John Doe",
            "emails": [{
                "value": "john@example.com",
                "primary": true
            }]
        }),
        &amp;context,
    ).await?;
    
    println!("Created user: {}", user.get_id().unwrap());
    Ok(())
}</code></pre></pre>
<h2 id="multi-tenant-operations"><a class="header" href="#multi-tenant-operations">Multi-Tenant Operations</a></h2>
<p>The same provider works for multi-tenant scenarios using <code>TenantContext</code>:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, TenantContext, ResourceProvider},
};
use serde_json::json;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    
    // Create tenant context
    let tenant_context = TenantContext::new(
        "tenant-1".to_string(),
        "client-1".to_string(),
    );
    let context = RequestContext::with_tenant_generated_id(tenant_context);
    
    // Create user in specific tenant
    let user = provider.create_resource(
        "User",
        json!({
            "userName": "alice@tenant1.com",
            "displayName": "Alice"
        }),
        &amp;context,
    ).await?;
    
    // Users are automatically isolated by tenant
    println!("Created user in tenant-1: {}", user.get_id().unwrap());
    Ok(())
}</code></pre></pre>
<h2 id="implementing-custom-storage"><a class="header" href="#implementing-custom-storage">Implementing Custom Storage</a></h2>
<p>To implement custom storage, create a type that implements <code>StorageProvider</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{StorageProvider, StorageKey, StoragePrefix, StorageError};
use serde_json::Value;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Clone)]
pub struct CustomStorage {
    data: Arc&lt;RwLock&lt;HashMap&lt;String, Value&gt;&gt;&gt;,
}

impl CustomStorage {
    pub fn new() -&gt; Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    fn key_string(key: &amp;StorageKey) -&gt; String {
        format!("{}/{}/{}", key.tenant_id(), key.resource_type(), key.resource_id())
    }
}

impl StorageProvider for CustomStorage {
    type Error = StorageError;
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        let key_str = Self::key_string(&amp;key);
        let mut store = self.data.write().await;
        store.insert(key_str, data.clone());
        Ok(data)
    }
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        let key_str = Self::key_string(&amp;key);
        let store = self.data.read().await;
        Ok(store.get(&amp;key_str).cloned())
    }
    
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        let key_str = Self::key_string(&amp;key);
        let mut store = self.data.write().await;
        Ok(store.remove(&amp;key_str).is_some())
    }
    
    async fn list(
        &amp;self,
        prefix: StoragePrefix,
        offset: usize,
        limit: usize,
    ) -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt; {
        let prefix_str = format!("{}/{}/", prefix.tenant_id(), prefix.resource_type());
        let store = self.data.read().await;
        
        let mut results: Vec&lt;_&gt; = store
            .iter()
            .filter(|(k, _)| k.starts_with(&amp;prefix_str))
            .skip(offset)
            .take(limit)
            .map(|(k, v)| {
                let parts: Vec&lt;&amp;str&gt; = k.split('/').collect();
                let key = StorageKey::new(&amp;parts[0], &amp;parts[1], &amp;parts[2]);
                (key, v.clone())
            })
            .collect();
            
        // Sort for consistent ordering
        results.sort_by(|a, b| a.0.resource_id().cmp(b.0.resource_id()));
        Ok(results)
    }
    
    async fn find_by_attribute(
        &amp;self,
        prefix: StoragePrefix,
        attribute: &amp;str,
        value: &amp;str,
    ) -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt; {
        let prefix_str = format!("{}/{}/", prefix.tenant_id(), prefix.resource_type());
        let store = self.data.read().await;
        
        let results: Vec&lt;_&gt; = store
            .iter()
            .filter(|(k, v)| {
                k.starts_with(&amp;prefix_str) &amp;&amp; 
                self.matches_attribute(v, attribute, value)
            })
            .map(|(k, v)| {
                let parts: Vec&lt;&amp;str&gt; = k.split('/').collect();
                let key = StorageKey::new(&amp;parts[0], &amp;parts[1], &amp;parts[2]);
                (key, v.clone())
            })
            .collect();
            
        Ok(results)
    }
    
    async fn exists(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        let key_str = Self::key_string(&amp;key);
        let store = self.data.read().await;
        Ok(store.contains_key(&amp;key_str))
    }
    
    async fn count(&amp;self, prefix: StoragePrefix) -&gt; Result&lt;usize, Self::Error&gt; {
        let prefix_str = format!("{}/{}/", prefix.tenant_id(), prefix.resource_type());
        let store = self.data.read().await;
        let count = store.keys().filter(|k| k.starts_with(&amp;prefix_str)).count();
        Ok(count)
    }
}

impl CustomStorage {
    fn matches_attribute(&amp;self, data: &amp;Value, attribute: &amp;str, value: &amp;str) -&gt; bool {
        // Simple attribute matching - you can extend this for nested attributes
        if let Some(attr_value) = data.get(attribute) {
            if let Some(string_value) = attr_value.as_str() {
                return string_value == value;
            }
        }
        false
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="using-your-custom-storage"><a class="header" href="#using-your-custom-storage">Using Your Custom Storage</a></h2>
<p>Once you have a <code>StorageProvider</code> implementation, use it with <code>StandardResourceProvider</code>:</p>
<pre><pre class="playground"><code class="language-rust">use scim_server::providers::StandardResourceProvider;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Use your custom storage
    let storage = CustomStorage::new();
    let provider = StandardResourceProvider::new(storage);
    
    // Now you can use the provider normally
    let context = RequestContext::with_generated_id();
    let user = provider.create_resource(
        "User",
        json!({"userName": "test@example.com"}),
        &amp;context,
    ).await?;
    
    println!("User created with custom storage!");
    Ok(())
}</code></pre></pre>
<h2 id="storage-provider-design-principles"><a class="header" href="#storage-provider-design-principles">Storage Provider Design Principles</a></h2>
<p>When implementing <code>StorageProvider</code>, follow these principles:</p>
<h3 id="1-protocol-agnostic"><a class="header" href="#1-protocol-agnostic">1. Protocol Agnostic</a></h3>
<p>Storage providers handle pure data operations and don't know about SCIM:</p>
<ul>
<li>Store/retrieve JSON values</li>
<li>No SCIM validation or metadata generation</li>
<li>No business logic</li>
</ul>
<h3 id="2-tenant-isolation"><a class="header" href="#2-tenant-isolation">2. Tenant Isolation</a></h3>
<p>All operations are scoped by tenant through <code>StorageKey</code>:</p>
<ul>
<li>Tenant information is built into every key</li>
<li>No cross-tenant data access</li>
<li>Natural tenant isolation</li>
</ul>
<h3 id="3-simple-operations"><a class="header" href="#3-simple-operations">3. Simple Operations</a></h3>
<p>Core operations are PUT/GET/DELETE:</p>
<ul>
<li><code>put()</code> works for both create and update</li>
<li><code>get()</code> returns <code>Option&lt;Value&gt;</code></li>
<li><code>delete()</code> returns boolean (existed or not)</li>
</ul>
<h3 id="4-consistent-ordering"><a class="header" href="#4-consistent-ordering">4. Consistent Ordering</a></h3>
<p>List operations should return consistent results:</p>
<ul>
<li>Sort by resource ID for predictable pagination</li>
<li>Implement proper offset/limit handling</li>
</ul>
<h3 id="5-attribute-search"><a class="header" href="#5-attribute-search">5. Attribute Search</a></h3>
<p><code>find_by_attribute()</code> enables SCIM filtering:</p>
<ul>
<li>Support exact string matching</li>
<li>Handle nested attributes with dot notation</li>
<li>Return all matching resources</li>
</ul>
<h2 id="database-storage-example"><a class="header" href="#database-storage-example">Database Storage Example</a></h2>
<p>Here's an example using a database (with SQLx):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{PgPool, Row};
use scim_server::storage::{StorageProvider, StorageKey, StoragePrefix, StorageError};
use serde_json::Value;

#[derive(Clone)]
pub struct PostgresStorage {
    pool: PgPool,
}

impl PostgresStorage {
    pub fn new(pool: PgPool) -&gt; Self {
        Self { pool }
    }
}

impl StorageProvider for PostgresStorage {
    type Error = StorageError;
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        sqlx::query!(
            r#"
            INSERT INTO scim_resources (tenant_id, resource_type, resource_id, data)
            VALUES ($1, $2, $3, $4)
            ON CONFLICT (tenant_id, resource_type, resource_id)
            DO UPDATE SET data = $4, updated_at = NOW()
            "#,
            key.tenant_id(),
            key.resource_type(),
            key.resource_id(),
            data
        )
        .execute(&amp;self.pool)
        .await
        .map_err(|e| StorageError::Internal(e.to_string()))?;
        
        Ok(data)
    }
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        let row = sqlx::query!(
            "SELECT data FROM scim_resources WHERE tenant_id = $1 AND resource_type = $2 AND resource_id = $3",
            key.tenant_id(),
            key.resource_type(),
            key.resource_id()
        )
        .fetch_optional(&amp;self.pool)
        .await
        .map_err(|e| StorageError::Internal(e.to_string()))?;
        
        Ok(row.map(|r| r.data))
    }
    
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        let result = sqlx::query!(
            "DELETE FROM scim_resources WHERE tenant_id = $1 AND resource_type = $2 AND resource_id = $3",
            key.tenant_id(),
            key.resource_type(),
            key.resource_id()
        )
        .execute(&amp;self.pool)
        .await
        .map_err(|e| StorageError::Internal(e.to_string()))?;
        
        Ok(result.rows_affected() &gt; 0)
    }
    
    // ... implement other methods
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h2>
<p>Storage providers should use <code>StorageError</code> for consistent error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::StorageError;

// For not found errors
return Err(StorageError::NotFound("Resource not found".to_string()));

// For constraint violations
return Err(StorageError::Conflict("Duplicate key".to_string()));

// For internal errors
return Err(StorageError::Internal(database_error.to_string()));
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-your-storage-provider"><a class="header" href="#testing-your-storage-provider">Testing Your Storage Provider</a></h2>
<p>Test your storage provider with the built-in test utilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use scim_server::storage::{StorageKey, StoragePrefix};
    use serde_json::json;
    
    #[tokio::test]
    async fn test_basic_operations() {
        let storage = CustomStorage::new();
        let key = StorageKey::new("tenant1", "User", "123");
        let data = json!({"userName": "test"});
        
        // Test put
        let stored = storage.put(key.clone(), data.clone()).await.unwrap();
        assert_eq!(stored, data);
        
        // Test get
        let retrieved = storage.get(key.clone()).await.unwrap();
        assert_eq!(retrieved, Some(data));
        
        // Test exists
        let exists = storage.exists(key.clone()).await.unwrap();
        assert!(exists);
        
        // Test delete
        let deleted = storage.delete(key.clone()).await.unwrap();
        assert!(deleted);
        
        // Verify deletion
        let after_delete = storage.get(key).await.unwrap();
        assert_eq!(after_delete, None);
    }
    
    #[tokio::test]
    async fn test_tenant_isolation() {
        let storage = CustomStorage::new();
        
        let tenant1_key = StorageKey::new("tenant1", "User", "123");
        let tenant2_key = StorageKey::new("tenant2", "User", "123");
        
        let data1 = json!({"userName": "user1"});
        let data2 = json!({"userName": "user2"});
        
        storage.put(tenant1_key.clone(), data1.clone()).await.unwrap();
        storage.put(tenant2_key.clone(), data2.clone()).await.unwrap();
        
        // Verify isolation
        let retrieved1 = storage.get(tenant1_key).await.unwrap();
        let retrieved2 = storage.get(tenant2_key).await.unwrap();
        
        assert_eq!(retrieved1, Some(data1));
        assert_eq!(retrieved2, Some(data2));
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li><a href="providers/./advanced.html">Advanced Provider Features</a> - Learn about conditional operations and versioning</li>
<li><a href="providers/./testing.html">Provider Testing</a> - Comprehensive testing strategies</li>
<li><a href="providers/./architecture.html">Architecture Overview</a> - Deep dive into the provider architecture</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-provider-features"><a class="header" href="#advanced-provider-features">Advanced Provider Features</a></h1>
<p>This guide covers advanced features and patterns for working with storage and resource providers in the SCIM Server library, including conditional operations, versioning, multi-operation patterns, and performance optimization.</p>
<h2 id="conditional-operations-and-etags"><a class="header" href="#conditional-operations-and-etags">Conditional Operations and ETags</a></h2>
<p>The SCIM Server provides built-in support for ETag-based optimistic concurrency control through conditional operations.</p>
<h3 id="etag-generation"><a class="header" href="#etag-generation">ETag Generation</a></h3>
<p>ETags are automatically generated for all resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    resource::{RequestContext, ResourceProvider},
};

let storage = InMemoryStorage::new();
let provider = StandardResourceProvider::new(storage);
let context = RequestContext::with_generated_id();

// Create a resource - ETag is automatically generated
let user = provider.create_resource(
    "User",
    json!({
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    }),
    &amp;context,
).await?;

// The resource now has an ETag in its metadata
println!("ETag: {}", user.get_version().unwrap());
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-updates-2"><a class="header" href="#conditional-updates-2">Conditional Updates</a></h3>
<p>Use ETags to prevent lost updates in concurrent scenarios:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::version::{ConditionalResult, ScimVersion};

// Get the current resource with its ETag
let current_user = provider.get_resource("User", "user-123", &amp;context)
    .await?
    .ok_or("User not found")?;

let current_etag = current_user.get_version().unwrap();

// Attempt conditional update
let updated_data = json!({
    "id": "user-123",
    "userName": "alice@example.com",
    "displayName": "Alice Updated"
});

match provider.conditional_update(
    "User",
    "user-123", 
    updated_data,
    &amp;ScimVersion::from_etag(current_etag),
    &amp;context,
).await? {
    ConditionalResult::Success(updated_user) =&gt; {
        println!("Update successful: {}", updated_user.get_version().unwrap());
    }
    ConditionalResult::Conflict(conflict) =&gt; {
        println!("Version conflict: expected {}, got {}", 
                 conflict.expected_version, 
                 conflict.current_version);
        // Handle conflict - retry, merge, or report error
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-deletes"><a class="header" href="#conditional-deletes">Conditional Deletes</a></h3>
<p>Safely delete resources with version checking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Delete only if the version matches
match provider.conditional_delete(
    "User",
    "user-123",
    &amp;ScimVersion::from_etag("W/\"abc123\""),
    &amp;context,
).await? {
    ConditionalResult::Success(was_deleted) =&gt; {
        if was_deleted {
            println!("User deleted successfully");
        } else {
            println!("User was already deleted");
        }
    }
    ConditionalResult::Conflict(conflict) =&gt; {
        println!("Cannot delete: version mismatch");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="if-match-and-if-none-match-headers"><a class="header" href="#if-match-and-if-none-match-headers">If-Match and If-None-Match Headers</a></h3>
<p>Handle HTTP conditional headers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::version::VersionCondition;

// If-Match: update only if ETag matches
let condition = VersionCondition::IfMatch(ScimVersion::from_etag("W/\"abc123\""));

// If-None-Match: update only if ETag doesn't match  
let condition = VersionCondition::IfNoneMatch(ScimVersion::from_etag("W/\"xyz789\""));

// Apply condition to update
let result = provider.conditional_update_with_condition(
    "User",
    "user-123",
    updated_data,
    condition,
    &amp;context,
).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-versioning"><a class="header" href="#resource-versioning">Resource Versioning</a></h2>
<h3 id="version-management"><a class="header" href="#version-management">Version Management</a></h3>
<p>Resources automatically track version information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::version::VersionedResource;

// Create versioned resource
let versioned_user = provider.create_versioned_resource(
    "User",
    user_data,
    &amp;context,
).await?;

println!("Resource version: {}", versioned_user.version);
println!("Created at: {}", versioned_user.resource.get_created().unwrap());
println!("Last modified: {}", versioned_user.resource.get_last_modified().unwrap());

// Get resource with version info
let versioned = provider.get_versioned_resource("User", "user-123", &amp;context).await?;
if let Some(v) = versioned {
    println!("Current version: {}", v.version);
    println!("Resource data: {}", serde_json::to_string_pretty(&amp;v.resource)?);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="version-history"><a class="header" href="#version-history">Version History</a></h3>
<p>Track changes over time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::version::VersionHistory;

// Providers can optionally implement version history
pub struct VersionedStorageProvider&lt;S&gt; {
    inner: S,
    version_store: VersionHistory,
}

impl&lt;S: StorageProvider&gt; VersionedStorageProvider&lt;S&gt; {
    async fn get_resource_history(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Vec&lt;VersionedResource&gt;, Self::Error&gt; {
        // Return all versions of the resource
        self.version_store.get_history(resource_type, id, context).await
    }
    
    async fn get_resource_at_version(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        version: &amp;ScimVersion,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Option&lt;Resource&gt;, Self::Error&gt; {
        // Get resource at specific version
        self.version_store.get_at_version(resource_type, id, version, context).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-operation-patterns"><a class="header" href="#multi-operation-patterns">Multi-Operation Patterns</a></h2>
<blockquote>
<p><strong>⚠️ Note</strong>: Bulk operations are not yet implemented. Use these patterns for efficient multi-resource operations.</p>
</blockquote>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<p>Process multiple operations efficiently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ResourceProvider, RequestContext, ConditionalResult};
use futures::future::try_join_all;
use serde_json::json;

// Process multiple user creations
async fn create_multiple_users(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    users_data: Vec&lt;serde_json::Value&gt;
) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("batch-create", None);
    let mut results = Vec::new();
    
    // Sequential processing (safest approach)
    for user_data in users_data {
        let user = provider.create_resource("User", user_data, &amp;context).await?;
        results.push(user);
    }
    
    Ok(results)
}

// Parallel processing (for independent operations)
async fn create_users_parallel(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    users_data: Vec&lt;serde_json::Value&gt;
) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("parallel-create", None);
    
    let futures: Vec&lt;_&gt; = users_data.into_iter()
        .map(|data| provider.create_resource("User", data, &amp;context))
        .collect();
    
    let results = try_join_all(futures).await?;
    Ok(results)
}

// Mixed operations with error handling
async fn process_mixed_operations(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("mixed-ops", None);
    let mut results = Vec::new();
    
    // Create a new user
    let user_data = json!({
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    });
    
    match provider.create_resource("User", user_data, &amp;context).await {
        Ok(user) =&gt; {
            let user_id = user.id().unwrap().to_string();
            results.push(format!("Created user: {}", user_id));
            
            // Update the user
            let update_data = json!({
                "displayName": "Alice Johnson"
            });
            
            match provider.update_resource("User", &amp;user_id, update_data, &amp;context).await {
                Ok(_) =&gt; results.push(format!("Updated user: {}", user_id)),
                Err(e) =&gt; results.push(format!("Failed to update user {}: {}", user_id, e)),
            }
        }
        Err(e) =&gt; results.push(format!("Failed to create user: {}", e)),
    }
    
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="transaction-like-operations"><a class="header" href="#transaction-like-operations">Transaction-like Operations</a></h3>
<p>While true ACID transactions aren't part of SCIM, you can implement compensating patterns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ResourceProvider, RequestContext};

struct Operation {
    operation_type: String,
    resource_type: String,
    resource_id: Option&lt;String&gt;,
    data: serde_json::Value,
}

struct CompensatingAction {
    action: String,
    resource_type: String,
    resource_id: String,
}

async fn execute_with_compensation(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    operations: Vec&lt;Operation&gt;
) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("compensating-ops", None);
    let mut completed = Vec::new();
    let mut compensations = Vec::new();
    
    for op in operations {
        let result = match op.operation_type.as_str() {
            "CREATE" =&gt; {
                match provider.create_resource(&amp;op.resource_type, op.data, &amp;context).await {
                    Ok(resource) =&gt; {
                        let id = resource.id().unwrap().to_string();
                        compensations.push(CompensatingAction {
                            action: "DELETE".to_string(),
                            resource_type: op.resource_type.clone(),
                            resource_id: id.clone(),
                        });
                        Ok(format!("Created {}: {}", op.resource_type, id))
                    }
                    Err(e) =&gt; Err(e.into())
                }
            }
            "UPDATE" =&gt; {
                let id = op.resource_id.unwrap();
                match provider.update_resource(&amp;op.resource_type, &amp;id, op.data, &amp;context).await {
                    Ok(_) =&gt; Ok(format!("Updated {}: {}", op.resource_type, id)),
                    Err(e) =&gt; Err(e.into())
                }
            }
            _ =&gt; Err("Unsupported operation".into())
        };
        
        match result {
            Ok(msg) =&gt; completed.push(msg),
            Err(e) =&gt; {
                // Rollback completed operations
                for compensation in compensations.iter().rev() {
                    if compensation.action == "DELETE" {
                        let _ = provider.delete_resource(
                            &amp;compensation.resource_type, 
                            &amp;compensation.resource_id, 
                            &amp;context
                        ).await;
                    }
                }
                return Err(e);
            }
        }
    }
    
    Ok(completed)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="efficient-storage-patterns"><a class="header" href="#efficient-storage-patterns">Efficient Storage Patterns</a></h3>
<p>Optimize storage operations for multiple resources:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Batch retrieval pattern
async fn get_multiple_users_by_ids(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    user_ids: Vec&lt;String&gt;
) -&gt; Result&lt;HashMap&lt;String, ScimUser&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("batch-get", None);
    let mut users = HashMap::new();
    
    // For now, individual requests (until batch APIs are implemented)
    for user_id in user_ids {
        match provider.get_resource("User", &amp;user_id, &amp;context).await {
            Ok(Some(user)) =&gt; {
                users.insert(user_id, user);
            }
            Ok(None) =&gt; {
                // User not found, skip
            }
            Err(e) =&gt; {
                eprintln!("Failed to get user {}: {}", user_id, e);
                // Continue with other users
            }
        }
    }
    
    Ok(users)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h2>
<h3 id="connection-pooling-1"><a class="header" href="#connection-pooling-1">Connection Pooling</a></h3>
<p>Optimize database connections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{Pool, Postgres};
use std::time::Duration;

pub struct OptimizedPostgresStorage {
    pool: Pool&lt;Postgres&gt;,
}

impl OptimizedPostgresStorage {
    pub async fn new(database_url: &amp;str) -&gt; Result&lt;Self, sqlx::Error&gt; {
        let pool = sqlx::postgres::PgPoolOptions::new()
            .max_connections(100)
            .min_connections(10)
            .max_lifetime(Duration::from_secs(1800))  // 30 minutes
            .idle_timeout(Duration::from_secs(600))   // 10 minutes
            .acquire_timeout(Duration::from_secs(30))
            .test_before_acquire(true)
            .connect(database_url)
            .await?;
            
        Ok(Self { pool })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-layer"><a class="header" href="#caching-layer">Caching Layer</a></h3>
<p>Add caching to storage providers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tokio::sync::RwLock;
use std::collections::HashMap;
use std::time::{Duration, Instant};

pub struct CachedStorage&lt;S&gt; {
    inner: S,
    cache: Arc&lt;RwLock&lt;HashMap&lt;String, CachedEntry&gt;&gt;&gt;,
    ttl: Duration,
}

struct CachedEntry {
    value: Value,
    inserted_at: Instant,
}

impl&lt;S: StorageProvider&gt; CachedStorage&lt;S&gt; {
    pub fn new(inner: S, ttl: Duration) -&gt; Self {
        Self {
            inner,
            cache: Arc::new(RwLock::new(HashMap::new())),
            ttl,
        }
    }
    
    fn cache_key(&amp;self, key: &amp;StorageKey) -&gt; String {
        format!("{}/{}/{}", key.tenant_id(), key.resource_type(), key.resource_id())
    }
    
    async fn cleanup_expired(&amp;self) {
        let mut cache = self.cache.write().await;
        let now = Instant::now();
        cache.retain(|_, entry| now.duration_since(entry.inserted_at) &lt; self.ttl);
    }
}

impl&lt;S: StorageProvider&gt; StorageProvider for CachedStorage&lt;S&gt; {
    type Error = S::Error;
    
    async fn get(&amp;self, key: StorageKey) -&gt; Result&lt;Option&lt;Value&gt;, Self::Error&gt; {
        let cache_key = self.cache_key(&amp;key);
        
        // Check cache first
        {
            let cache = self.cache.read().await;
            if let Some(entry) = cache.get(&amp;cache_key) {
                let age = Instant::now().duration_since(entry.inserted_at);
                if age &lt; self.ttl {
                    return Ok(Some(entry.value.clone()));
                }
            }
        }
        
        // Cache miss - get from storage
        let result = self.inner.get(key).await?;
        
        // Update cache
        if let Some(ref value) = result {
            let mut cache = self.cache.write().await;
            cache.insert(cache_key, CachedEntry {
                value: value.clone(),
                inserted_at: Instant::now(),
            });
        }
        
        Ok(result)
    }
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        let result = self.inner.put(key.clone(), data).await?;
        
        // Update cache
        let cache_key = self.cache_key(&amp;key);
        let mut cache = self.cache.write().await;
        cache.insert(cache_key, CachedEntry {
            value: result.clone(),
            inserted_at: Instant::now(),
        });
        
        Ok(result)
    }
    
    async fn delete(&amp;self, key: StorageKey) -&gt; Result&lt;bool, Self::Error&gt; {
        let result = self.inner.delete(key.clone()).await?;
        
        // Remove from cache
        let cache_key = self.cache_key(&amp;key);
        let mut cache = self.cache.write().await;
        cache.remove(&amp;cache_key);
        
        Ok(result)
    }
    
    // Implement other methods...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="indexing-for-search"><a class="header" href="#indexing-for-search">Indexing for Search</a></h3>
<p>Optimize attribute searches:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::BTreeMap;

pub struct IndexedStorage&lt;S&gt; {
    inner: S,
    // Index: (tenant, resource_type, attribute) -&gt; (value -&gt; resource_ids)
    attribute_index: Arc&lt;RwLock&lt;BTreeMap&lt;String, BTreeMap&lt;String, HashSet&lt;String&gt;&gt;&gt;&gt;&gt;,
}

impl&lt;S: StorageProvider&gt; IndexedStorage&lt;S&gt; {
    pub fn new(inner: S) -&gt; Self {
        Self {
            inner,
            attribute_index: Arc::new(RwLock::new(BTreeMap::new())),
        }
    }
    
    fn index_key(&amp;self, prefix: &amp;StoragePrefix, attribute: &amp;str) -&gt; String {
        format!("{}/{}#{}", prefix.tenant_id(), prefix.resource_type(), attribute)
    }
    
    async fn update_index(&amp;self, key: &amp;StorageKey, data: &amp;Value) {
        let mut index = self.attribute_index.write().await;
        
        // Index common searchable attributes
        let searchable_attributes = ["userName", "displayName", "email.value"];
        
        for attr in &amp;searchable_attributes {
            if let Some(attr_value) = self.extract_attribute_value(data, attr) {
                let index_key = self.index_key(
                    &amp;StorageKey::prefix(key.tenant_id(), key.resource_type()),
                    attr
                );
                
                let value_index = index.entry(index_key).or_insert_with(BTreeMap::new);
                let resource_set = value_index.entry(attr_value).or_insert_with(HashSet::new);
                resource_set.insert(key.resource_id().to_string());
            }
        }
    }
    
    fn extract_attribute_value(&amp;self, data: &amp;Value, attribute: &amp;str) -&gt; Option&lt;String&gt; {
        // Simple attribute extraction - can be enhanced for nested attributes
        data.get(attribute)?.as_str().map(|s| s.to_string())
    }
}

impl&lt;S: StorageProvider&gt; StorageProvider for IndexedStorage&lt;S&gt; {
    type Error = S::Error;
    
    async fn find_by_attribute(
        &amp;self,
        prefix: StoragePrefix,
        attribute: &amp;str,
        value: &amp;str,
    ) -&gt; Result&lt;Vec&lt;(StorageKey, Value)&gt;, Self::Error&gt; {
        let index_key = self.index_key(&amp;prefix, attribute);
        
        // Try index first
        {
            let index = self.attribute_index.read().await;
            if let Some(value_index) = index.get(&amp;index_key) {
                if let Some(resource_ids) = value_index.get(value) {
                    // Found in index - get the resources
                    let mut results = Vec::new();
                    for resource_id in resource_ids {
                        let key = StorageKey::new(
                            prefix.tenant_id(),
                            prefix.resource_type(),
                            resource_id
                        );
                        if let Some(data) = self.inner.get(key.clone()).await? {
                            results.push((key, data));
                        }
                    }
                    return Ok(results);
                }
            }
        }
        
        // Fallback to full scan
        self.inner.find_by_attribute(prefix, attribute, value).await
    }
    
    async fn put(&amp;self, key: StorageKey, data: Value) -&gt; Result&lt;Value, Self::Error&gt; {
        let result = self.inner.put(key.clone(), data.clone()).await?;
        
        // Update indexes
        self.update_index(&amp;key, &amp;result).await;
        
        Ok(result)
    }
    
    // Implement other methods with index maintenance...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-validation"><a class="header" href="#custom-validation">Custom Validation</a></h2>
<h3 id="schema-validation"><a class="header" href="#schema-validation">Schema Validation</a></h3>
<p>Add custom validation logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::Value;

pub trait ResourceValidator: Send + Sync {
    type Error: std::error::Error + Send + Sync + 'static;
    
    async fn validate_resource(
        &amp;self,
        resource_type: &amp;str,
        data: &amp;Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;(), Self::Error&gt;;
    
    async fn validate_update(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        current: &amp;Value,
        updated: &amp;Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;(), Self::Error&gt;;
}

pub struct SchemaValidator {
    schemas: HashMap&lt;String, ResourceSchema&gt;,
}

impl ResourceValidator for SchemaValidator {
    type Error = ValidationError;
    
    async fn validate_resource(
        &amp;self,
        resource_type: &amp;str,
        data: &amp;Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        let schema = self.schemas.get(resource_type)
            .ok_or_else(|| ValidationError::UnknownResourceType(resource_type.to_string()))?;
        
        // Validate required fields
        for required_field in &amp;schema.required_fields {
            if !data.get(required_field).is_some() {
                return Err(ValidationError::MissingRequiredField(required_field.clone()));
            }
        }
        
        // Validate field types and constraints
        for (field_name, field_schema) in &amp;schema.fields {
            if let Some(field_value) = data.get(field_name) {
                self.validate_field(field_value, field_schema)?;
            }
        }
        
        // Custom business rules
        self.validate_business_rules(resource_type, data, context).await?;
        
        Ok(())
    }
    
    async fn validate_update(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        current: &amp;Value,
        updated: &amp;Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;(), Self::Error&gt; {
        // First validate the updated resource
        self.validate_resource(resource_type, updated, context).await?;
        
        // Check immutable fields
        let schema = self.schemas.get(resource_type).unwrap();
        for immutable_field in &amp;schema.immutable_fields {
            let current_value = current.get(immutable_field);
            let updated_value = updated.get(immutable_field);
            
            if current_value != updated_value {
                return Err(ValidationError::ImmutableFieldModified(immutable_field.clone()));
            }
        }
        
        Ok(())
    }
}

pub struct ValidatingResourceProvider&lt;P, V&gt; {
    inner: P,
    validator: V,
}

impl&lt;P: ResourceProvider, V: ResourceValidator&gt; ResourceProvider for ValidatingResourceProvider&lt;P, V&gt; {
    type Error = CombinedError&lt;P::Error, V::Error&gt;;
    
    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt; {
        // Validate before creation
        self.validator.validate_resource(resource_type, &amp;data, context)
            .await
            .map_err(CombinedError::ValidationError)?;
        
        // Delegate to inner provider
        self.inner.create_resource(resource_type, data, context)
            .await
            .map_err(CombinedError::ProviderError)
    }
    
    async fn update_resource(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt; {
        // Get current resource for validation
        let current = self.inner.get_resource(resource_type, id, context)
            .await
            .map_err(CombinedError::ProviderError)?
            .ok_or_else(|| CombinedError::ProviderError(/* NotFound error */))?;
        
        // Validate the update
        self.validator.validate_update(resource_type, id, current.data(), &amp;data, context)
            .await
            .map_err(CombinedError::ValidationError)?;
        
        // Perform update
        self.inner.update_resource(resource_type, id, data, context)
            .await
            .map_err(CombinedError::ProviderError)
    }
    
    // Implement other methods...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="monitoring-and-metrics"><a class="header" href="#monitoring-and-metrics">Monitoring and Metrics</a></h2>
<h3 id="instrumentation"><a class="header" href="#instrumentation">Instrumentation</a></h3>
<p>Add comprehensive monitoring:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, instrument, Span};
use std::time::Instant;

pub struct InstrumentedProvider&lt;P&gt; {
    inner: P,
    metrics: Arc&lt;ProviderMetrics&gt;,
}

pub struct ProviderMetrics {
    pub operation_counter: metrics::Counter,
    pub operation_duration: metrics::Histogram,
    pub error_counter: metrics::Counter,
    pub active_operations: metrics::Gauge,
}

impl&lt;P: ResourceProvider&gt; InstrumentedProvider&lt;P&gt; {
    pub fn new(inner: P, metrics: Arc&lt;ProviderMetrics&gt;) -&gt; Self {
        Self { inner, metrics }
    }
}

impl&lt;P: ResourceProvider&gt; ResourceProvider for InstrumentedProvider&lt;P&gt; {
    type Error = P::Error;
    
    #[instrument(skip(self, data, context), fields(
        resource_type = resource_type,
        tenant_id = context.tenant_context.as_ref().map(|t| t.tenant_id.as_str()),
        operation = "create"
    ))]
    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;Resource, Self::Error&gt; {
        let start = Instant::now();
        let _guard = self.metrics.active_operations.increment();
        
        info!("Creating resource");
        
        let result = self.inner.create_resource(resource_type, data, context).await;
        
        let duration = start.elapsed();
        
        match &amp;result {
            Ok(resource) =&gt; {
                info!(
                    resource_id = resource.get_id().unwrap_or("unknown"),
                    duration_ms = duration.as_millis(),
                    "Resource created successfully"
                );
                
                self.metrics.operation_counter
                    .with_labels(&amp;[("operation", "create"), ("status", "success")])
                    .increment();
            }
            Err(e) =&gt; {
                error!(
                    error = %e,
                    duration_ms = duration.as_millis(),
                    "Failed to create resource"
                );
                
                self.metrics.operation_counter
                    .with_labels(&amp;[("operation", "create"), ("status", "error")])
                    .increment();
                    
                self.metrics.error_counter
                    .with_labels(&amp;[("operation", "create")])
                    .increment();
            }
        }
        
        self.metrics.operation_duration
            .with_labels(&amp;[("operation", "create")])
            .observe(duration.as_secs_f64());
        
        result
    }
    
    // Similar instrumentation for other methods...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="health-checks"><a class="header" href="#health-checks">Health Checks</a></h3>
<p>Implement comprehensive health monitoring:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};
use std::time::{Duration, SystemTime};

#[derive(Debug, Serialize, Deserialize)]
pub struct HealthStatus {
    pub status: HealthState,
    pub version: String,
    pub uptime: Duration,
    pub checks: Vec&lt;HealthCheck&gt;,
}

#[derive(Debug, Serialize, Deserialize)]
pub enum HealthState {
    Healthy,
    Degraded,
    Unhealthy,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct HealthCheck {
    pub name: String,
    pub status: HealthState,
    pub duration: Duration,
    pub message: Option&lt;String&gt;,
}

pub trait HealthProvider {
    async fn health_check(&amp;self) -&gt; Result&lt;HealthStatus, Box&lt;dyn std::error::Error&gt;&gt;;
}

impl&lt;S: StorageProvider&gt; HealthProvider for StandardResourceProvider&lt;S&gt; {
    async fn health_check(&amp;self) -&gt; Result&lt;HealthStatus, Box&lt;dyn std::error::Error&gt;&gt; {
        let start_time = SystemTime::now();
        let mut checks = Vec::new();
        
        // Check storage connectivity
        let storage_check_start = Instant::now();
        let storage_status = match self.test_storage_connectivity().await {
            Ok(_) =&gt; HealthState::Healthy,
            Err(e) =&gt; {
                checks.push(HealthCheck {
                    name: "storage".to_string(),
                    status: HealthState::Unhealthy,
                    duration: storage_check_start.elapsed(),
                    message: Some(e.to_string()),
                });
                HealthState::Unhealthy
            }
        };
        
        if matches!(storage_status, HealthState::Healthy) {
            checks.push(HealthCheck {
                name: "storage".to_string(),
                status: HealthState::Healthy,
                duration: storage_check_start.elapsed(),
                message: None,
            });
        }
        
        // Check resource operations
        let ops_check_start = Instant::now();
        let ops_status = match self.test_basic_operations().await {
            Ok(_) =&gt; HealthState::Healthy,
            Err(e) =&gt; {
                checks.push(HealthCheck {
                    name: "operations".to_string(),
                    status: HealthState::Unhealthy,
                    duration: ops_check_start.elapsed(),
                    message: Some(e.to_string()),
                });
                HealthState::Unhealthy
            }
        };
        
        if matches!(ops_status, HealthState::Healthy) {
            checks.push(HealthCheck {
                name: "operations".to_string(),
                status: HealthState::Healthy,
                duration: ops_check_start.elapsed(),
                message: None,
            });
        }
        
        // Determine overall status
        let overall_status = if checks.iter().any(|c| matches!(c.status, HealthState::Unhealthy)) {
            HealthState::Unhealthy
        } else if checks.iter().any(|c| matches!(c.status, HealthState::Degraded)) {
            HealthState::Degraded
        } else {
            HealthState::Healthy
        };
        
        Ok(HealthStatus {
            status: overall_status,
            version: env!("CARGO_PKG_VERSION").to_string(),
            uptime: start_time.elapsed().unwrap_or(Duration::ZERO),
            checks,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h3>
<p>Implement comprehensive error handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum AdvancedProviderError {
    #[error("Storage error: {0}")]
    Storage(#[from] StorageError),
    
    #[error("Validation error: {0}")]
    Validation(#[from] ValidationError),
    
    #[error("Version conflict: expected {expected}, got {current}")]
    VersionConflict { expected: String, current: String },
    
    #[error("Rate limit exceeded: {limit} requests per {window:?}")]
    RateLimitExceeded { limit: u32, window: Duration },
    
    #[error("Quota exceeded: {current}/{limit} resources")]
    QuotaExceeded { current: usize, limit: usize },
    
    #[error("Circuit breaker open: {service}")]
    CircuitBreakerOpen { service: String },
}

// Implement recovery strategies
impl AdvancedProviderError {
    pub fn is_retryable(&amp;self) -&gt; bool {
        matches!(self, 
            Self::Storage(StorageError::Internal(_)) |
            Self::CircuitBreakerOpen { .. }
        )
    }
    
    pub fn retry_delay(&amp;self) -&gt; Option&lt;Duration&gt; {
        match self {
            Self::RateLimitExceeded { window, .. } =&gt; Some(*window),
            Self::CircuitBreakerOpen { .. } =&gt; Some(Duration::from_secs(5)),
            _ =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>Use structured configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Deserialize)]
pub struct AdvancedProviderConfig {
    pub storage: StorageConfig,
    pub caching: Option&lt;CacheConfig&gt;,
    pub validation: ValidationConfig,
    pub performance: PerformanceConfig,
    pub monitoring: MonitoringConfig,
}

#[derive(Debug, Deserialize)]
pub struct CacheConfig {
    pub enabled: bool,
    pub ttl_seconds: u64,
    pub max_entries: usize,
}

#[derive(Debug, Deserialize)]
pub struct PerformanceConfig {
    pub bulk_batch_size: usize,
    pub connection_pool_size: u32,
    pub query_timeout_seconds: u64,
}

#[derive(Debug, Deserialize)]
pub struct MonitoringConfig {
    pub enable_metrics: bool,
    pub enable_tracing: bool,
    pub health_check_interval_seconds: u64,
}

// Factory function
pub async fn create_advanced_provider(
    config: AdvancedProviderConfig,
) -&gt; Result&lt;Box&lt;dyn ResourceProvider&lt;Error = AdvancedProviderError&gt;&gt;, ConfigError&gt; {
    // Create storage layer
    let storage = create_storage_provider(&amp;config.storage).await?;
    
    // Add caching if configured
    let storage: Box&lt;dyn StorageProvider&lt;Error = StorageError&gt;&gt; = if let Some(cache_config) = config.caching {
        if cache_config.enabled {
            Box::new(CachedStorage::new(
                storage,
                Duration::from_secs(cache_config.ttl_seconds),
            ))
        } else {
            storage
        }
    } else {
        storage
    };
    
    // Create resource provider
    let provider = StandardResourceProvider::new(storage);
    
    // Add validation layer
    let validator = create_validator(&amp;config.validation)?;
    let provider = ValidatingResourceProvider::new(provider, validator);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="provider-testing"><a class="header" href="#provider-testing">Provider Testing</a></h1>
<p>This guide covers comprehensive testing strategies for storage and resource providers in the SCIM Server library. Testing ensures your providers work correctly, handle edge cases gracefully, and perform well under load.</p>
<h2 id="testing-architecture"><a class="header" href="#testing-architecture">Testing Architecture</a></h2>
<p>The SCIM Server's two-layer architecture requires testing at both levels:</p>
<ul>
<li><strong>Storage Provider Tests</strong>: Test data persistence, retrieval, and tenant isolation</li>
<li><strong>Resource Provider Tests</strong>: Test SCIM protocol logic, validation, and metadata handling</li>
<li><strong>Integration Tests</strong>: Test the complete stack working together</li>
</ul>
<h2 id="storage-provider-testing"><a class="header" href="#storage-provider-testing">Storage Provider Testing</a></h2>
<h3 id="basic-crud-operations"><a class="header" href="#basic-crud-operations">Basic CRUD Operations</a></h3>
<p>Test fundamental storage operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod storage_tests {
    use super::*;
    use scim_server::storage::{StorageProvider, StorageKey, StoragePrefix, StorageError};
    use serde_json::json;
    use tokio_test;

    async fn test_storage_crud&lt;S: StorageProvider&gt;(storage: S) 
    where 
        S::Error: std::fmt::Debug,
    {
        let key = StorageKey::new("test-tenant", "User", "user-123");
        let data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });

        // Test put operation
        let stored = storage.put(key.clone(), data.clone()).await.unwrap();
        assert_eq!(stored, data);

        // Test get operation
        let retrieved = storage.get(key.clone()).await.unwrap();
        assert_eq!(retrieved, Some(data.clone()));

        // Test exists operation
        let exists = storage.exists(key.clone()).await.unwrap();
        assert!(exists);

        // Test delete operation
        let deleted = storage.delete(key.clone()).await.unwrap();
        assert!(deleted);

        // Verify deletion
        let after_delete = storage.get(key.clone()).await.unwrap();
        assert_eq!(after_delete, None);

        // Test delete non-existent
        let not_deleted = storage.delete(key).await.unwrap();
        assert!(!not_deleted);
    }

    #[tokio::test]
    async fn test_inmemory_storage_crud() {
        let storage = InMemoryStorage::new();
        test_storage_crud(storage).await;
    }

    #[tokio::test]
    async fn test_custom_storage_crud() {
        let storage = MyCustomStorage::new();
        test_storage_crud(storage).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation-testing-1"><a class="header" href="#tenant-isolation-testing-1">Tenant Isolation Testing</a></h3>
<p>Verify that tenant data is properly isolated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_tenant_isolation() {
    let storage = InMemoryStorage::new();
    
    // Create resources in different tenants
    let tenant1_key = StorageKey::new("tenant-1", "User", "user-123");
    let tenant2_key = StorageKey::new("tenant-2", "User", "user-123");
    
    let tenant1_data = json!({"userName": "alice@tenant1.com"});
    let tenant2_data = json!({"userName": "alice@tenant2.com"});
    
    storage.put(tenant1_key.clone(), tenant1_data.clone()).await.unwrap();
    storage.put(tenant2_key.clone(), tenant2_data.clone()).await.unwrap();
    
    // Verify isolation - same resource ID but different tenants
    let retrieved1 = storage.get(tenant1_key).await.unwrap();
    let retrieved2 = storage.get(tenant2_key).await.unwrap();
    
    assert_eq!(retrieved1, Some(tenant1_data));
    assert_eq!(retrieved2, Some(tenant2_data));
    
    // Verify list operations are also isolated
    let prefix1 = StorageKey::prefix("tenant-1", "User");
    let prefix2 = StorageKey::prefix("tenant-2", "User");
    
    let list1 = storage.list(prefix1, 0, 100).await.unwrap();
    let list2 = storage.list(prefix2, 0, 100).await.unwrap();
    
    assert_eq!(list1.len(), 1);
    assert_eq!(list2.len(), 1);
    assert_ne!(list1[0].1, list2[0].1); // Different data
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-operations-testing"><a class="header" href="#query-operations-testing">Query Operations Testing</a></h3>
<p>Test list, search, and pagination:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_list_operations() {
    let storage = InMemoryStorage::new();
    let prefix = StorageKey::prefix("tenant-1", "User");
    
    // Create multiple resources
    for i in 1..=10 {
        let key = StorageKey::new("tenant-1", "User", &amp;format!("user-{:03}", i));
        let data = json!({
            "userName": format!("user{}@example.com", i),
            "displayName": format!("User {}", i)
        });
        storage.put(key, data).await.unwrap();
    }
    
    // Test list all
    let all_users = storage.list(prefix.clone(), 0, 100).await.unwrap();
    assert_eq!(all_users.len(), 10);
    
    // Test pagination
    let page1 = storage.list(prefix.clone(), 0, 3).await.unwrap();
    let page2 = storage.list(prefix.clone(), 3, 3).await.unwrap();
    let page3 = storage.list(prefix.clone(), 6, 3).await.unwrap();
    let page4 = storage.list(prefix.clone(), 9, 3).await.unwrap();
    
    assert_eq!(page1.len(), 3);
    assert_eq!(page2.len(), 3);
    assert_eq!(page3.len(), 3);
    assert_eq!(page4.len(), 1);
    
    // Verify no overlap between pages
    let all_ids: HashSet&lt;_&gt; = page1.iter().chain(&amp;page2).chain(&amp;page3).chain(&amp;page4)
        .map(|(key, _)| key.resource_id())
        .collect();
    assert_eq!(all_ids.len(), 10);
}

#[tokio::test]
async fn test_find_by_attribute() {
    let storage = InMemoryStorage::new();
    let prefix = StorageKey::prefix("tenant-1", "User");
    
    // Create test users
    let users = vec![
        ("user-1", "alice@example.com", "Alice Smith"),
        ("user-2", "bob@example.com", "Bob Jones"),
        ("user-3", "alice@company.com", "Alice Johnson"),
    ];
    
    for (id, username, display_name) in users {
        let key = StorageKey::new("tenant-1", "User", id);
        let data = json!({
            "userName": username,
            "displayName": display_name
        });
        storage.put(key, data).await.unwrap();
    }
    
    // Test exact match
    let alice_users = storage.find_by_attribute(
        prefix.clone(),
        "userName",
        "alice@example.com"
    ).await.unwrap();
    assert_eq!(alice_users.len(), 1);
    assert_eq!(alice_users[0].0.resource_id(), "user-1");
    
    // Test no matches
    let no_matches = storage.find_by_attribute(
        prefix.clone(),
        "userName",
        "nonexistent@example.com"
    ).await.unwrap();
    assert_eq!(no_matches.len(), 0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="concurrent-access-testing"><a class="header" href="#concurrent-access-testing">Concurrent Access Testing</a></h3>
<p>Test thread safety and concurrent operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::task::JoinSet;

#[tokio::test]
async fn test_concurrent_access() {
    let storage = Arc::new(InMemoryStorage::new());
    let mut join_set = JoinSet::new();
    
    // Spawn multiple concurrent operations
    for i in 0..10 {
        let storage_clone = Arc::clone(&amp;storage);
        join_set.spawn(async move {
            let key = StorageKey::new("tenant-1", "User", &amp;format!("user-{}", i));
            let data = json!({
                "userName": format!("user{}@example.com", i),
                "displayName": format!("User {}", i)
            });
            
            // Perform multiple operations
            storage_clone.put(key.clone(), data.clone()).await.unwrap();
            let retrieved = storage_clone.get(key.clone()).await.unwrap();
            assert_eq!(retrieved, Some(data));
            
            storage_clone.delete(key).await.unwrap()
        });
    }
    
    // Wait for all operations to complete
    while let Some(result) = join_set.join_next().await {
        result.unwrap(); // Panic if any task failed
    }
    
    // Verify final state
    let prefix = StorageKey::prefix("tenant-1", "User");
    let remaining = storage.list(prefix, 0, 100).await.unwrap();
    assert_eq!(remaining.len(), 0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-testing"><a class="header" href="#error-handling-testing">Error Handling Testing</a></h3>
<p>Test error conditions and edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_error_handling() {
    let storage = InMemoryStorage::new();
    
    // Test get non-existent resource
    let key = StorageKey::new("tenant-1", "User", "non-existent");
    let result = storage.get(key.clone()).await.unwrap();
    assert_eq!(result, None);
    
    // Test delete non-existent resource
    let deleted = storage.delete(key).await.unwrap();
    assert!(!deleted);
    
    // Test invalid operations (implementation specific)
    // For example, if your storage has size limits:
    // let large_data = json!({"data": "x".repeat(1_000_000)});
    // let result = storage.put(key, large_data).await;
    // assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-provider-testing"><a class="header" href="#resource-provider-testing">Resource Provider Testing</a></h2>
<h3 id="scim-protocol-testing"><a class="header" href="#scim-protocol-testing">SCIM Protocol Testing</a></h3>
<p>Test SCIM-specific functionality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod resource_provider_tests {
    use super::*;
    use scim_server::{
        providers::StandardResourceProvider,
        storage::InMemoryStorage,
        resource::{RequestContext, TenantContext, ResourceProvider},
    };
    use serde_json::json;

    #[tokio::test]
    async fn test_resource_metadata_generation() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::with_generated_id();
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        let user = provider.create_resource("User", user_data, &amp;context).await.unwrap();
        
        // Verify SCIM metadata is generated
        assert!(user.get_id().is_some());
        assert!(user.get_created().is_some());
        assert!(user.get_last_modified().is_some());
        assert!(user.get_version().is_some());
        assert_eq!(user.get_username().unwrap(), "alice@example.com");
    }

    #[tokio::test]
    async fn test_tenant_context_handling() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        
        // Single-tenant context
        let single_context = RequestContext::with_generated_id();
        
        // Multi-tenant context
        let tenant_context = TenantContext::new("tenant-1".to_string(), "client-1".to_string());
        let multi_context = RequestContext::with_tenant_generated_id(tenant_context);
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        // Create users in different contexts
        let single_user = provider.create_resource("User", user_data.clone(), &amp;single_context).await.unwrap();
        let multi_user = provider.create_resource("User", user_data, &amp;multi_context).await.unwrap();
        
        // Verify they are isolated
        let single_list = provider.list_resources("User", None, &amp;single_context).await.unwrap();
        let multi_list = provider.list_resources("User", None, &amp;multi_context).await.unwrap();
        
        assert_eq!(single_list.len(), 1);
        assert_eq!(multi_list.len(), 1);
        assert_ne!(single_user.get_id(), multi_user.get_id());
    }

    #[tokio::test]
    async fn test_duplicate_username_handling() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::with_generated_id();
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        // Create first user
        let user1 = provider.create_resource("User", user_data.clone(), &amp;context).await.unwrap();
        
        // Try to create duplicate username
        let result = provider.create_resource("User", user_data, &amp;context).await;
        
        // Should fail with conflict
        assert!(result.is_err());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-operations-testing"><a class="header" href="#conditional-operations-testing">Conditional Operations Testing</a></h3>
<p>Test ETag-based concurrency control:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_conditional_operations() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::with_generated_id();
    
    // Create a user
    let user_data = json!({
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    });
    
    let user = provider.create_resource("User", user_data, &amp;context).await.unwrap();
    let user_id = user.get_id().unwrap();
    let version = user.get_version().unwrap();
    
    // Test successful conditional update
    let updated_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "displayName": "Alice Updated"
    });
    
    let result = provider.conditional_update(
        "User",
        user_id,
        updated_data,
        &amp;ScimVersion::from_etag(version),
        &amp;context,
    ).await.unwrap();
    
    match result {
        ConditionalResult::Success(updated_user) =&gt; {
            assert_eq!(updated_user.get_display_name().unwrap(), "Alice Updated");
            assert_ne!(updated_user.get_version().unwrap(), version); // Version should change
        }
        ConditionalResult::Conflict(_) =&gt; panic!("Should not have conflict"),
    }
    
    // Test conditional update with wrong version (should conflict)
    let wrong_version_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "displayName": "Alice Wrong Version"
    });
    
    let conflict_result = provider.conditional_update(
        "User",
        user_id,
        wrong_version_data,
        &amp;ScimVersion::from_etag(version), // Old version
        &amp;context,
    ).await.unwrap();
    
    match conflict_result {
        ConditionalResult::Success(_) =&gt; panic!("Should have conflict"),
        ConditionalResult::Conflict(conflict) =&gt; {
            assert_eq!(conflict.expected_version, version);
            assert_ne!(conflict.current_version, version);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing-2"><a class="header" href="#integration-testing-2">Integration Testing</a></h2>
<h3 id="full-stack-testing"><a class="header" href="#full-stack-testing">Full Stack Testing</a></h3>
<p>Test the complete SCIM workflow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_full_scim_workflow() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::with_generated_id();
    
    // Create user
    let create_data = json!({
        "userName": "alice@example.com",
        "name": {
            "givenName": "Alice",
            "familyName": "Smith"
        },
        "emails": [{
            "value": "alice@example.com",
            "primary": true
        }]
    });
    
    let user = provider.create_resource("User", create_data, &amp;context).await.unwrap();
    let user_id = user.get_id().unwrap();
    
    // Read user
    let retrieved = provider.get_resource("User", user_id, &amp;context).await.unwrap();
    assert!(retrieved.is_some());
    let retrieved_user = retrieved.unwrap();
    assert_eq!(retrieved_user.get_username().unwrap(), "alice@example.com");
    
    // Update user
    let update_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "name": {
            "givenName": "Alice",
            "familyName": "Johnson"
        },
        "emails": [{
            "value": "alice@example.com",
            "primary": true
        }]
    });
    
    let updated_user = provider.update_resource("User", user_id, update_data, &amp;context).await.unwrap();
    assert_eq!(updated_user.get_family_name().unwrap(), "Johnson");
    
    // List users
    let users = provider.list_resources("User", None, &amp;context).await.unwrap();
    assert_eq!(users.len(), 1);
    
    // Search user
    let found = provider.find_resource_by_attribute(
        "User",
        "userName",
        &amp;json!("alice@example.com"),
        &amp;context,
    ).await.unwrap();
    assert!(found.is_some());
    
    // Delete user
    let deleted = provider.delete_resource("User", user_id, &amp;context).await.unwrap();
    assert!(deleted);
    
    // Verify deletion
    let after_delete = provider.get_resource("User", user_id, &amp;context).await.unwrap();
    assert!(after_delete.is_none());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-tenant-integration-testing"><a class="header" href="#multi-tenant-integration-testing">Multi-Tenant Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_multi_tenant_integration() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    
    // Create contexts for different tenants
    let tenant1_context = RequestContext::with_tenant_generated_id(
        TenantContext::new("tenant-1".to_string(), "client-1".to_string())
    );
    let tenant2_context = RequestContext::with_tenant_generated_id(
        TenantContext::new("tenant-2".to_string(), "client-2".to_string())
    );
    
    // Create users in different tenants
    let user_data = json!({
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    });
    
    let tenant1_user = provider.create_resource("User", user_data.clone(), &amp;tenant1_context).await.unwrap();
    let tenant2_user = provider.create_resource("User", user_data, &amp;tenant2_context).await.unwrap();
    
    // Verify isolation
    let tenant1_users = provider.list_resources("User", None, &amp;tenant1_context).await.unwrap();
    let tenant2_users = provider.list_resources("User", None, &amp;tenant2_context).await.unwrap();
    
    assert_eq!(tenant1_users.len(), 1);
    assert_eq!(tenant2_users.len(), 1);
    assert_ne!(tenant1_user.get_id(), tenant2_user.get_id());
    
    // Verify cross-tenant access fails
    let cross_access = provider.get_resource(
        "User",
        tenant1_user.get_id().unwrap(),
        &amp;tenant2_context,
    ).await.unwrap();
    assert!(cross_access.is_none()); // Should not find user from different tenant
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="load-testing"><a class="header" href="#load-testing">Load Testing</a></h3>
<p>Test provider performance under load:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tokio::task::JoinSet;

#[tokio::test]
async fn test_provider_performance() {
    let storage = InMemoryStorage::new();
    let provider = Arc::new(StandardResourceProvider::new(storage));
    
    let num_operations = 1000;
    let num_concurrent = 10;
    
    let start = Instant::now();
    let mut join_set = JoinSet::new();
    
    for batch in 0..num_concurrent {
        let provider_clone = Arc::clone(&amp;provider);
        join_set.spawn(async move {
            let context = RequestContext::with_generated_id();
            
            for i in 0..(num_operations / num_concurrent) {
                let user_id = format!("user-{}-{}", batch, i);
                let user_data = json!({
                    "userName": format!("{}@example.com", user_id),
                    "displayName": format!("User {}", user_id)
                });
                
                // Create, read, update, delete cycle
                let user = provider_clone.create_resource("User", user_data, &amp;context).await.unwrap();
                let id = user.get_id().unwrap();
                
                let retrieved = provider_clone.get_resource("User", id, &amp;context).await.unwrap();
                assert!(retrieved.is_some());
                
                let updated_data = json!({
                    "id": id,
                    "userName": format!("{}@example.com", user_id),
                    "displayName": format!("Updated User {}", user_id)
                });
                
                let updated = provider_clone.update_resource("User", id, updated_data, &amp;context).await.unwrap();
                assert_eq!(updated.get_display_name().unwrap(), format!("Updated User {}", user_id));
                
                let deleted = provider_clone.delete_resource("User", id, &amp;context).await.unwrap();
                assert!(deleted);
            }
        });
    }
    
    // Wait for all operations to complete
    while let Some(result) = join_set.join_next().await {
        result.unwrap();
    }
    
    let duration = start.elapsed();
    let ops_per_second = (num_operations * 4) as f64 / duration.as_secs_f64(); // 4 ops per iteration
    
    println!("Completed {} operations in {:?}", num_operations * 4, duration);
    println!("Performance: {:.2} operations/second", ops_per_second);
    
    // Assert minimum performance threshold (adjust based on requirements)
    assert!(ops_per_second &gt; 100.0, "Performance below threshold: {:.2} ops/sec", ops_per_second);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-usage-testing"><a class="header" href="#memory-usage-testing">Memory Usage Testing</a></h3>
<p>Test memory efficiency and leak detection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_memory_usage() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage.clone());
    let context = RequestContext::with_generated_id();
    
    // Create many resources
    let num_resources = 10000;
    for i in 0..num_resources {
        let user_data = json!({
            "userName": format!("user{}@example.com", i),
            "displayName": format!("User {}", i)
        });
        
        provider.create_resource("User", user_data, &amp;context).await.unwrap();
    }
    
    // Check storage stats
    let stats = storage.stats().await;
    assert_eq!(stats.total_resources, num_resources);
    assert_eq!(stats.tenant_count, 1); // All in default tenant
    
    // Delete all resources
    let users = provider.list_resources("User", None, &amp;context).await.unwrap();
    for user in users {
        provider.delete_resource("User", user.get_id().unwrap(), &amp;context).await.unwrap();
    }
    
    // Verify cleanup
    let final_stats = storage.stats().await;
    assert_eq!(final_stats.total_resources, 0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-utilities-and-helpers"><a class="header" href="#test-utilities-and-helpers">Test Utilities and Helpers</a></h2>
<h3 id="reusable-test-fixtures"><a class="header" href="#reusable-test-fixtures">Reusable Test Fixtures</a></h3>
<p>Create common test utilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod test_utils {
    use super::*;
    use serde_json::{json, Value};
    use uuid::Uuid;

    pub fn random_tenant_id() -&gt; String {
        format!("test-tenant-{}", Uuid::new_v4())
    }

    pub fn sample_user_data(username: &amp;str) -&gt; Value {
        json!({
            "userName": username,
            "name": {
                "givenName": "Test",
                "familyName": "User"
            },
            "displayName": format!("Test User {}", username),
            "emails": [{
                "value": username,
                "primary": true
            }]
        })
    }

    pub fn sample_group_data(name: &amp;str) -&gt; Value {
        json!({
            "displayName": name,
            "members": []
        })
    }

    pub async fn create_test_provider() -&gt; StandardResourceProvider&lt;InMemoryStorage&gt; {
        let storage = InMemoryStorage::new();
        StandardResourceProvider::new(storage)
    }

    pub async fn setup_test_data(
        provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
        context: &amp;RequestContext,
    ) -&gt; Vec&lt;String&gt; {
        let mut user_ids = Vec::new();
        
        for i in 1..=5 {
            let username = format!("testuser{}@example.com", i);
            let user_data = sample_user_data(&amp;username);
            
            let user = provider.create_resource("User", user_data, context).await.unwrap();
            user_ids.push(user.get_id().unwrap().to_string());
        }
        
        user_ids
    }
}

// Usage in tests
#[tokio::test]
async fn test_with_utilities() {
    let provider = test_utils::create_test_provider().await;
    let context = RequestContext::with_generated_id();
    
    let user_ids = test_utils::setup_test_data(&amp;provider, &amp;context).await;
    assert_eq!(user_ids.len(), 5);
    
    // Your test logic here...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<p>Use property-based testing for edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn test_resource_id_roundtrip(
        tenant_id in "[a-zA-Z0-9-]{1,50}",
        resource_type in "[a-zA-Z]{1,20}",
        resource_id in "[a-zA-Z0-9-]{1,50}"
    ) {
        tokio_test::block_on(async {
            let storage = InMemoryStorage::new();
            let key = StorageKey::new(&amp;tenant_id, &amp;resource_type, &amp;resource_id);
            let data = json!({"test": "data"});
            
            let stored = storage.put(key.clone(), data.clone()).await.unwrap();
            let retrieved = storage.get(key).await.unwrap();
            
            prop_assert_eq!(retrieved, Some(stored));
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="continuous-integration-testing"><a class="header" href="#continuous-integration-testing">Continuous Integration Testing</a></h2>
<h3 id="github-actions-example"><a class="header" href="#github-actions-example">GitHub Actions Example</a></h3>
<pre><code class="language-yaml">name: Provider Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta, nightly]
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        override: true
        components: rustfmt, clippy
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        
    - name: Run tests
      run: cargo test --all-features
      
    - name: Run storage provider tests
      run: cargo test storage::tests --all-features
      
    - name: Run resource provider tests  
      run: cargo test providers::tests --all-features
      
    - name: Run integration tests
      run: cargo test integration --all-features
      
    - name: Check formatting
      run: cargo fmt -- --check
      
    - name: Run clippy
      run: cargo clippy -- -D warnings
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h3>
<ol>
<li><strong>Separate Concerns</strong>: Test storage and resource providers separately</li>
<li><strong>Use Descriptive Names</strong>: Test names should clearly indicate what is being tested</li>
<li><strong>Test Edge Cases</strong>: Include tests for error conditions and boundary cases</li>
<li><strong>Performance Regression</strong>: Include performance tests in CI</li>
<li><strong>Documentation</strong>: Document complex test scenarios</li>
</ol>
<h3 id="test-data-management"><a class="header" href="#test-data-management">Test Data Management</a></h3>
<ol>
<li><strong>Isolated Tests</strong>: Each test should create its own data</li>
<li><strong>Cleanup</strong>: Tests should clean up after themselves</li>
<li><strong>Deterministic</strong>: Tests should produce consistent results</li>
<li><strong>Realistic Data</strong>: Use realistic test data that matches production patterns</li>
</ol>
<h3 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h3>
<ol>
<li><strong>Expected Errors</strong>: Test that errors are properly handled and returned</li>
<li><strong>Recovery</strong>: Test that providers can recover from transient errors</li>
<li><strong>Resource Cleanup</strong>: Ensure resources are properly cleaned up on errors</li>
</ol>
<p>This comprehensive testing approach ensures your providers are reliable, performant, and ready for production use.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema-overview"><a class="header" href="#schema-overview">Schema Overview</a></h1>
<p>This guide provides an overview of SCIM schemas and how they work within the SCIM Server library. Understanding schemas is essential for extending the server with custom attributes and resource types.</p>
<h2 id="what-are-scim-schemas"><a class="header" href="#what-are-scim-schemas">What are SCIM Schemas?</a></h2>
<p>SCIM (System for Cross-domain Identity Management) schemas define the structure, attributes, and validation rules for resources like Users and Groups. They provide a standardized way to describe what data can be stored and how it should be formatted.</p>
<h3 id="core-concepts-1"><a class="header" href="#core-concepts-1">Core Concepts</a></h3>
<ul>
<li><strong>Schema URI</strong>: Unique identifier for each schema (e.g., <code>urn:ietf:params:scim:schemas:core:2.0:User</code>)</li>
<li><strong>Resource Types</strong>: The types of objects that can be managed (User, Group, custom types)</li>
<li><strong>Attributes</strong>: The fields that make up a resource (name, email, etc.)</li>
<li><strong>Extensions</strong>: Additional schemas that add custom attributes to existing resource types</li>
</ul>
<h2 id="standard-scim-schemas"><a class="header" href="#standard-scim-schemas">Standard SCIM Schemas</a></h2>
<h3 id="core-user-schema"><a class="header" href="#core-user-schema">Core User Schema</a></h3>
<pre><code>urn:ietf:params:scim:schemas:core:2.0:User
</code></pre>
<p>Defines essential user attributes:</p>
<ul>
<li><code>id</code> - Unique identifier</li>
<li><code>userName</code> - Primary identifier for authentication</li>
<li><code>name</code> - User's full name (complex attribute)</li>
<li><code>displayName</code> - Name for display purposes</li>
<li><code>emails</code> - Email addresses (multi-valued)</li>
<li><code>phoneNumbers</code> - Phone numbers (multi-valued)</li>
<li><code>active</code> - Whether the user account is active</li>
</ul>
<h3 id="core-group-schema"><a class="header" href="#core-group-schema">Core Group Schema</a></h3>
<pre><code>urn:ietf:params:scim:schemas:core:2.0:Group
</code></pre>
<p>Defines group attributes:</p>
<ul>
<li><code>id</code> - Unique identifier</li>
<li><code>displayName</code> - Group's display name</li>
<li><code>members</code> - Group members (multi-valued complex)</li>
</ul>
<h3 id="enterprise-user-extension"><a class="header" href="#enterprise-user-extension">Enterprise User Extension</a></h3>
<pre><code>urn:ietf:params:scim:schemas:extension:enterprise:2.0:User
</code></pre>
<p>Adds enterprise-specific attributes:</p>
<ul>
<li><code>employeeNumber</code> - Employee identifier</li>
<li><code>department</code> - Department name</li>
<li><code>manager</code> - Reference to manager</li>
<li><code>organization</code> - Organization name</li>
</ul>
<h2 id="schema-architecture"><a class="header" href="#schema-architecture">Schema Architecture</a></h2>
<h3 id="schema-definition-structure"><a class="header" href="#schema-definition-structure">Schema Definition Structure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::{SchemaDefinition, AttributeDefinition};
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaDefinition {
    pub id: String,                              // Schema URI
    pub name: String,                            // Human-readable name
    pub description: String,                     // Schema description
    pub attributes: Vec&lt;AttributeDefinition&gt;,    // Attribute definitions
    pub meta: SchemaMeta,                        // Metadata
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaMeta {
    pub resource_type: String,
    pub location: String,
    pub created: DateTime&lt;Utc&gt;,
    pub last_modified: DateTime&lt;Utc&gt;,
    pub version: String,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-definition"><a class="header" href="#attribute-definition">Attribute Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttributeDefinition {
    pub name: String,                    // Attribute name
    pub attribute_type: AttributeType,   // Data type
    pub multi_valued: bool,              // Can have multiple values
    pub description: String,             // Human-readable description
    pub required: bool,                  // Must be present
    pub case_exact: bool,                // Case-sensitive comparison
    pub mutability: Mutability,          // When attribute can be modified
    pub returned: Returned,              // When attribute is returned
    pub uniqueness: Uniqueness,          // Uniqueness constraint
    pub reference_types: Option&lt;Vec&lt;String&gt;&gt;, // For reference attributes
    pub canonical_values: Option&lt;Vec&lt;String&gt;&gt;, // Predefined valid values
    pub sub_attributes: Option&lt;Vec&lt;AttributeDefinition&gt;&gt;, // For complex types
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-types"><a class="header" href="#attribute-types">Attribute Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AttributeType {
    String,    // Text data
    Boolean,   // True/false values
    Decimal,   // Floating-point numbers
    Integer,   // Whole numbers
    DateTime,  // ISO 8601 date-time
    Binary,    // Base64-encoded binary data
    Reference, // Reference to another resource
    Complex,   // Nested object with sub-attributes
}
<span class="boring">}</span></code></pre></pre>
<h3 id="mutability-levels"><a class="header" href="#mutability-levels">Mutability Levels</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Mutability {
    ReadOnly,   // Cannot be modified by client
    ReadWrite,  // Can be read and written
    Immutable,  // Can only be set during creation
    WriteOnly,  // Can be written but not read (e.g., passwords)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="return-behavior"><a class="header" href="#return-behavior">Return Behavior</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Returned {
    Always,  // Always returned
    Never,   // Never returned (e.g., passwords)
    Default, // Returned by default
    Request, // Only returned when explicitly requested
}
<span class="boring">}</span></code></pre></pre>
<h3 id="uniqueness-constraints"><a class="header" href="#uniqueness-constraints">Uniqueness Constraints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Uniqueness {
    None,   // No uniqueness constraint
    Server, // Unique within the server
    Global, // Globally unique
}
<span class="boring">}</span></code></pre></pre>
<h2 id="schema-registry"><a class="header" href="#schema-registry">Schema Registry</a></h2>
<p>The schema registry manages all available schemas and provides validation services:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::SchemaRegistry;
use std::collections::HashMap;

pub struct SchemaRegistry {
    schemas: HashMap&lt;String, SchemaDefinition&gt;,
    resource_schemas: HashMap&lt;String, Vec&lt;String&gt;&gt;, // resource_type -&gt; schema_uris
}

impl SchemaRegistry {
    pub fn new() -&gt; Self {
        let mut registry = Self {
            schemas: HashMap::new(),
            resource_schemas: HashMap::new(),
        };
        
        // Register core schemas
        registry.register_core_schemas();
        registry
    }
    
    pub fn register_schema(&amp;mut self, schema: SchemaDefinition) -&gt; Result&lt;(), SchemaError&gt; {
        // Validate schema definition
        self.validate_schema(&amp;schema)?;
        
        // Store schema
        self.schemas.insert(schema.id.clone(), schema);
        Ok(())
    }
    
    pub fn get_schema(&amp;self, schema_uri: &amp;str) -&gt; Option&lt;&amp;SchemaDefinition&gt; {
        self.schemas.get(schema_uri)
    }
    
    pub fn get_resource_schemas(&amp;self, resource_type: &amp;str) -&gt; Vec&lt;&amp;SchemaDefinition&gt; {
        if let Some(schema_uris) = self.resource_schemas.get(resource_type) {
            schema_uris.iter()
                .filter_map(|uri| self.schemas.get(uri))
                .collect()
        } else {
            Vec::new()
        }
    }
    
    pub fn validate_resource(
        &amp;self,
        resource: &amp;serde_json::Value,
        schemas: &amp;[String],
    ) -&gt; Result&lt;(), ValidationError&gt; {
        for schema_uri in schemas {
            if let Some(schema) = self.get_schema(schema_uri) {
                self.validate_against_schema(resource, schema)?;
            } else {
                return Err(ValidationError::UnknownSchema(schema_uri.clone()));
            }
        }
        Ok(())
    }
    
    fn register_core_schemas(&amp;mut self) {
        // Register User schema
        let user_schema = self.create_user_schema();
        self.schemas.insert(user_schema.id.clone(), user_schema);
        
        // Register Group schema
        let group_schema = self.create_group_schema();
        self.schemas.insert(group_schema.id.clone(), group_schema);
        
        // Register Enterprise User extension
        let enterprise_schema = self.create_enterprise_user_schema();
        self.schemas.insert(enterprise_schema.id.clone(), enterprise_schema);
        
        // Map resource types to schemas
        self.resource_schemas.insert(
            "User".to_string(),
            vec![
                "urn:ietf:params:scim:schemas:core:2.0:User".to_string(),
                "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User".to_string(),
            ]
        );
        
        self.resource_schemas.insert(
            "Group".to_string(),
            vec!["urn:ietf:params:scim:schemas:core:2.0:Group".to_string()]
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="working-with-schemas"><a class="header" href="#working-with-schemas">Working with Schemas</a></h2>
<h3 id="retrieving-schema-information"><a class="header" href="#retrieving-schema-information">Retrieving Schema Information</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::ScimServer;

async fn get_user_schema(server: &amp;ScimServer) -&gt; Result&lt;SchemaDefinition, ScimError&gt; {
    let registry = server.schema_registry();
    let schema = registry.get_schema("urn:ietf:params:scim:schemas:core:2.0:User")
        .ok_or(ScimError::SchemaNotFound)?;
    Ok(schema.clone())
}

async fn list_all_schemas(server: &amp;ScimServer) -&gt; Vec&lt;SchemaDefinition&gt; {
    let registry = server.schema_registry();
    registry.list_schemas()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validating-resources"><a class="header" href="#validating-resources">Validating Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::models::User;
use serde_json;

async fn validate_user(
    registry: &amp;SchemaRegistry,
    user: &amp;User,
) -&gt; Result&lt;(), ValidationError&gt; {
    let user_json = serde_json::to_value(user)?;
    
    registry.validate_resource(
        &amp;user_json,
        &amp;user.schemas,
    )
}
<span class="boring">}</span></code></pre></pre>
<h2 id="schema-versioning"><a class="header" href="#schema-versioning">Schema Versioning</a></h2>
<h3 id="version-management-1"><a class="header" href="#version-management-1">Version Management</a></h3>
<p>Schemas should be versioned to handle evolution over time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct SchemaVersion {
    pub major: u32,
    pub minor: u32,
    pub patch: u32,
}

impl SchemaVersion {
    pub fn new(major: u32, minor: u32, patch: u32) -&gt; Self {
        Self { major, minor, patch }
    }
    
    pub fn is_compatible_with(&amp;self, other: &amp;SchemaVersion) -&gt; bool {
        // Same major version is compatible
        self.major == other.major
    }
}

// Schema URI with version
// urn:company:schemas:extension:employee:1.0:User
<span class="boring">}</span></code></pre></pre>
<h3 id="migration-support"><a class="header" href="#migration-support">Migration Support</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SchemaMigration {
    fn migrate(&amp;self, from: &amp;SchemaVersion, to: &amp;SchemaVersion, data: &amp;mut serde_json::Value) -&gt; Result&lt;(), MigrationError&gt;;
    fn supports_migration(&amp;self, from: &amp;SchemaVersion, to: &amp;SchemaVersion) -&gt; bool;
}

pub struct SchemaEvolutionManager {
    migrations: Vec&lt;Box&lt;dyn SchemaMigration&gt;&gt;,
}

impl SchemaEvolutionManager {
    pub fn migrate_data(
        &amp;self,
        data: &amp;mut serde_json::Value,
        from_version: &amp;SchemaVersion,
        to_version: &amp;SchemaVersion,
    ) -&gt; Result&lt;(), MigrationError&gt; {
        for migration in &amp;self.migrations {
            if migration.supports_migration(from_version, to_version) {
                migration.migrate(from_version, to_version, data)?;
                break;
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-10"><a class="header" href="#error-handling-10">Error Handling</a></h2>
<h3 id="schema-related-errors"><a class="header" href="#schema-related-errors">Schema-Related Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum SchemaError {
    #[error("Schema validation failed: {0}")]
    ValidationFailed(String),
    
    #[error("Unknown schema: {0}")]
    UnknownSchema(String),
    
    #[error("Schema conflict: {0}")]
    SchemaConflict(String),
    
    #[error("Invalid attribute definition: {0}")]
    InvalidAttribute(String),
    
    #[error("Schema version incompatible: {0}")]
    VersionIncompatible(String),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<h3 id="schema-design-guidelines"><a class="header" href="#schema-design-guidelines">Schema Design Guidelines</a></h3>
<ol>
<li><strong>Use meaningful names</strong>: Attribute names should be descriptive and follow camelCase convention</li>
<li><strong>Choose appropriate types</strong>: Select the most specific type that fits your data</li>
<li><strong>Set proper constraints</strong>: Use <code>required</code>, <code>uniqueness</code>, and <code>mutability</code> appropriately</li>
<li><strong>Document thoroughly</strong>: Provide clear descriptions for schemas and attributes</li>
<li><strong>Version strategically</strong>: Plan for schema evolution from the beginning</li>
</ol>
<h3 id="performance-considerations-4"><a class="header" href="#performance-considerations-4">Performance Considerations</a></h3>
<ol>
<li><strong>Index unique attributes</strong>: Ensure database indexes exist for attributes with uniqueness constraints</li>
<li><strong>Minimize complex attributes</strong>: Deeply nested structures can impact performance</li>
<li><strong>Cache schema definitions</strong>: Avoid repeated schema lookups during validation</li>
<li><strong>Batch validation</strong>: Validate multiple resources together when possible</li>
</ol>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><a href="schemas/./custom-resources.html">Custom Resources</a> - Learn to create entirely new resource types</li>
<li><a href="schemas/./extensions.html">Extensions</a> - Add custom attributes to existing resources</li>
<li><a href="schemas/./validation.html">Validation</a> - Implement custom validation rules for schemas</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-resources-1"><a class="header" href="#custom-resources-1">Custom Resources</a></h1>
<p>This guide covers creating entirely new resource types in the SCIM Server library. While User and Group are the standard SCIM resources, you can define custom resource types to model organization-specific entities.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>Custom resources allow you to:</p>
<ul>
<li><strong>Model business entities</strong> - Devices, applications, roles, projects</li>
<li><strong>Extend beyond identity</strong> - Any organizational resource</li>
<li><strong>Maintain SCIM compliance</strong> - Follow SCIM patterns and conventions</li>
<li><strong>Integrate with existing flows</strong> - Use standard SCIM operations</li>
<li><strong>Support multi-tenancy</strong> - Different resource types per tenant</li>
</ul>
<h2 id="creating-a-device-resource"><a class="header" href="#creating-a-device-resource">Creating a Device Resource</a></h2>
<h3 id="resource-definition"><a class="header" href="#resource-definition">Resource Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::models::{Meta, Resource};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
    pub id: Option&lt;String&gt;,
    pub schemas: Vec&lt;String&gt;,
    pub device_name: String,
    pub device_type: DeviceType,
    pub serial_number: Option&lt;String&gt;,
    pub manufacturer: Option&lt;String&gt;,
    pub model: Option&lt;String&gt;,
    pub operating_system: Option&lt;OperatingSystem&gt;,
    pub owner: Option&lt;DeviceOwner&gt;,
    pub location: Option&lt;DeviceLocation&gt;,
    pub network_info: Option&lt;NetworkInfo&gt;,
    pub security_info: Option&lt;DeviceSecurityInfo&gt;,
    pub active: Option&lt;bool&gt;,
    pub meta: Option&lt;Meta&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceType {
    Laptop,
    Desktop,
    Tablet,
    Phone,
    Server,
    Printer,
    Other(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OperatingSystem {
    pub name: String,
    pub version: String,
    pub architecture: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceOwner {
    pub user_id: String,
    pub user_name: Option&lt;String&gt;,
    pub assignment_date: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub assignment_type: AssignmentType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AssignmentType {
    Personal,
    Shared,
    Pool,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="schema-definition-1"><a class="header" href="#schema-definition-1">Schema Definition</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::{SchemaDefinition, AttributeDefinition, AttributeType};

pub fn create_device_schema() -&gt; SchemaDefinition {
    SchemaDefinition {
        id: "urn:company:schemas:core:2.0:Device".to_string(),
        name: "Device".to_string(),
        description: "Device resource schema".to_string(),
        attributes: vec![
            AttributeDefinition {
                name: "deviceName".to_string(),
                attribute_type: AttributeType::String,
                multi_valued: false,
                description: "The name of the device".to_string(),
                required: true,
                case_exact: false,
                mutability: Mutability::ReadWrite,
                returned: Returned::Always,
                uniqueness: Uniqueness::None,
                reference_types: None,
                canonical_values: None,
                sub_attributes: None,
            },
            AttributeDefinition {
                name: "deviceType".to_string(),
                attribute_type: AttributeType::String,
                multi_valued: false,
                description: "The type of device".to_string(),
                required: true,
                case_exact: false,
                mutability: Mutability::ReadWrite,
                returned: Returned::Always,
                uniqueness: Uniqueness::None,
                reference_types: None,
                canonical_values: Some(vec![
                    "Laptop".to_string(),
                    "Desktop".to_string(),
                    "Tablet".to_string(),
                    "Phone".to_string(),
                    "Server".to_string(),
                    "Printer".to_string(),
                    "Other".to_string(),
                ]),
                sub_attributes: None,
            },
            // Add more attributes...
        ],
        meta: SchemaMeta {
            resource_type: "Schema".to_string(),
            location: "/Schemas/urn:company:schemas:core:2.0:Device".to_string(),
            created: Utc::now(),
            last_modified: Utc::now(),
            version: "1.0".to_string(),
        },
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-provider-implementation"><a class="header" href="#resource-provider-implementation">Resource Provider Implementation</a></h2>
<h3 id="storage-provider-extension"><a class="header" href="#storage-provider-extension">Storage Provider Extension</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::StorageProvider;
use async_trait::async_trait;

#[async_trait]
pub trait DeviceStorageProvider: StorageProvider {
    async fn create_device(
        &amp;self,
        tenant_id: &amp;str,
        device: Device,
    ) -&gt; Result&lt;Device, StorageError&gt;;
    
    async fn get_device(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
    ) -&gt; Result&lt;Device, StorageError&gt;;
    
    async fn update_device(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
        device: Device,
        version: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;Device, StorageError&gt;;
    
    async fn delete_device(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
        version: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;(), StorageError&gt;;
    
    async fn list_devices(
        &amp;self,
        tenant_id: &amp;str,
        sort_by: Option&lt;&amp;str&gt;,
        sort_order: Option&lt;SortOrder&gt;,
        start_index: Option&lt;usize&gt;,
        count: Option&lt;usize&gt;,
    ) -&gt; Result&lt;ListResponse&lt;Device&gt;, StorageError&gt;;
    
    // Helper methods for common filtering patterns
    async fn find_devices_by_type(
        &amp;self,
        tenant_id: &amp;str,
        device_type: &amp;DeviceType,
    ) -&gt; Result&lt;Vec&lt;Device&gt;, StorageError&gt;;
    
    async fn find_devices_by_status(
        &amp;self,
        tenant_id: &amp;str,
        status: &amp;DeviceStatus,
    ) -&gt; Result&lt;Vec&lt;Device&gt;, StorageError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-handler"><a class="header" href="#resource-handler">Resource Handler</a></h2>
<h3 id="http-endpoint-implementation"><a class="header" href="#http-endpoint-implementation">HTTP Endpoint Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::handlers::{ResourceHandler, ScimHandler};
use axum::{Json, Path, Query};

pub struct DeviceHandler&lt;T: DeviceStorageProvider&gt; {
    storage: T,
    validator: DeviceValidator,
}

impl&lt;T: DeviceStorageProvider&gt; DeviceHandler&lt;T&gt; {
    pub fn new(storage: T) -&gt; Self {
        Self {
            storage,
            validator: DeviceValidator::new(),
        }
    }
}

#[async_trait]
impl&lt;T: DeviceStorageProvider&gt; ResourceHandler&lt;Device&gt; for DeviceHandler&lt;T&gt; {
    async fn create(
        &amp;self,
        tenant_id: &amp;str,
        device: Device,
    ) -&gt; Result&lt;Device, ScimError&gt; {
        // Validate device
        self.validator.validate_create(&amp;device)?;
        
        // Create in storage
        let created_device = self.storage.create_device(tenant_id, device).await?;
        
        Ok(created_device)
    }
    
    async fn get(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
    ) -&gt; Result&lt;Device, ScimError&gt; {
        self.storage.get_device(tenant_id, device_id).await
            .map_err(|e| e.into())
    }
    
    async fn update(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
        device: Device,
        version: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;Device, ScimError&gt; {
        // Validate update
        self.validator.validate_update(&amp;device)?;
        
        // Update in storage
        let updated_device = self.storage.update_device(
            tenant_id,
            device_id,
            device,
            version,
        ).await?;
        
        Ok(updated_device)
    }
    
    async fn delete(
        &amp;self,
        tenant_id: &amp;str,
        device_id: &amp;str,
        version: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;(), ScimError&gt; {
        self.storage.delete_device(tenant_id, device_id, version).await
            .map_err(|e| e.into())
    }
    
    async fn list(
        &amp;self,
        tenant_id: &amp;str,
        sort_by: Option&lt;&amp;str&gt;,
        sort_order: Option&lt;SortOrder&gt;,
        start_index: Option&lt;usize&gt;,
        count: Option&lt;usize&gt;,
    ) -&gt; Result&lt;ListResponse&lt;Device&gt;, ScimError&gt; {
        self.storage.list_devices(
            tenant_id,
            sort_by,
            sort_order,
            start_index,
            count,
        ).await.map_err(|e| e.into())
    }
    
    // Implement specific search methods for common patterns
    async fn search_by_type(
        &amp;self,
        tenant_id: &amp;str,
        device_type: &amp;DeviceType,
    ) -&gt; Result&lt;Vec&lt;Device&gt;, ScimError&gt; {
        self.storage.find_devices_by_type(tenant_id, device_type)
            .await
            .map_err(|e| e.into())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="registration-and-configuration"><a class="header" href="#registration-and-configuration">Registration and Configuration</a></h2>
<h3 id="registering-custom-resources"><a class="header" href="#registering-custom-resources">Registering Custom Resources</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::ScimServerBuilder;

let server = ScimServerBuilder::new()
    .with_provider(storage_provider)
    .register_resource_type::&lt;Device&gt;("Device", device_handler)
    .register_schema(create_device_schema())
    .add_endpoint("/Devices", device_routes())
    .build();
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<h3 id="resource-design"><a class="header" href="#resource-design">Resource Design</a></h3>
<ul>
<li>Follow SCIM naming conventions</li>
<li>Use appropriate attribute types</li>
<li>Define proper mutability rules</li>
<li>Include comprehensive metadata</li>
</ul>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<ul>
<li>Index frequently queried attributes</li>
<li>Implement efficient filtering</li>
<li>Consider caching for read-heavy resources</li>
<li>Optimize storage provider operations</li>
</ul>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<ul>
<li>Implement comprehensive validation rules</li>
<li>Validate references to other resources</li>
<li>Check business logic constraints</li>
<li>Provide meaningful error messages</li>
</ul>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><a href="schemas/./extensions.html">Extensions</a> - Add custom attributes to existing resources</li>
<li><a href="schemas/./validation.html">Validation</a> - Implement custom validation rules</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<blockquote>
<p><strong>TODO</strong>: This section is under development. Basic schema extension patterns are outlined below.</p>
</blockquote>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>SCIM schema extensions allow you to add custom attributes to standard resource types like User and Group. This enables organizations to capture additional data specific to their needs while maintaining SCIM compliance.</p>
<h2 id="standard-extensions"><a class="header" href="#standard-extensions">Standard Extensions</a></h2>
<h3 id="enterprise-user-extension-1"><a class="header" href="#enterprise-user-extension-1">Enterprise User Extension</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{Schema, Attribute, AttributeType};
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnterpriseUser {
    #[serde(rename = "employeeNumber")]
    pub employee_number: Option&lt;String&gt;,
    
    #[serde(rename = "costCenter")]
    pub cost_center: Option&lt;String&gt;,
    
    pub organization: Option&lt;String&gt;,
    pub division: Option&lt;String&gt;,
    pub department: Option&lt;String&gt;,
    pub manager: Option&lt;Manager&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Manager {
    pub value: String,           // Manager's user ID
    #[serde(rename = "$ref")]
    pub reference: Option&lt;String&gt;, // URI reference to manager
    #[serde(rename = "displayName")]
    pub display_name: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-extensions"><a class="header" href="#custom-extensions">Custom Extensions</a></h2>
<h3 id="creating-custom-schema-extensions"><a class="header" href="#creating-custom-schema-extensions">Creating Custom Schema Extensions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::{SchemaBuilder, AttributeBuilder};

pub fn create_custom_extension() -&gt; Schema {
    SchemaBuilder::new()
        .id("urn:company:scim:schemas:extension:employee:2.0")
        .name("Employee Extension")
        .description("Custom attributes for employee data")
        .add_attribute(
            AttributeBuilder::new()
                .name("badgeNumber")
                .type_(AttributeType::String)
                .description("Employee badge number")
                .required(false)
                .case_exact(true)
                .build()
        )
        .add_attribute(
            AttributeBuilder::new()
                .name("startDate")
                .type_(AttributeType::DateTime)
                .description("Employee start date")
                .required(false)
                .build()
        )
        .add_attribute(
            AttributeBuilder::new()
                .name("clearanceLevel")
                .type_(AttributeType::String)
                .description("Security clearance level")
                .required(false)
                .canonical_values(vec!["PUBLIC", "CONFIDENTIAL", "SECRET", "TOP_SECRET"])
                .build()
        )
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-in-resources"><a class="header" href="#usage-in-resources">Usage in Resources</a></h2>
<h3 id="extended-user-resource"><a class="header" href="#extended-user-resource">Extended User Resource</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::json;

let extended_user = json!({
    "schemas": [
        "urn:ietf:params:scim:schemas:core:2.0:User",
        "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
        "urn:company:scim:schemas:extension:employee:2.0"
    ],
    "userName": "john.doe@company.com",
    "name": {
        "givenName": "John",
        "familyName": "Doe"
    },
    "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User": {
        "employeeNumber": "12345",
        "department": "Engineering",
        "manager": {
            "value": "manager-uuid",
            "displayName": "Jane Smith"
        }
    },
    "urn:company:scim:schemas:extension:employee:2.0": {
        "badgeNumber": "BADGE-12345",
        "startDate": "2024-01-15T00:00:00Z",
        "clearanceLevel": "CONFIDENTIAL"
    }
});
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<h3 id="extension-validation"><a class="header" href="#extension-validation">Extension Validation</a></h3>
<blockquote>
<p><strong>TODO</strong>: Implement comprehensive extension validation patterns.</p>
</blockquote>
<h3 id="schema-registration"><a class="header" href="#schema-registration">Schema Registration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::SchemaRegistry;

fn register_extensions(registry: &amp;mut SchemaRegistry) {
    // Register enterprise extension
    registry.register_extension(
        "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
        create_enterprise_extension()
    );
    
    // Register custom extension
    registry.register_extension(
        "urn:company:scim:schemas:extension:employee:2.0",
        create_custom_extension()
    );
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<ol>
<li><strong>Use descriptive URNs</strong> for extension schemas</li>
<li><strong>Follow naming conventions</strong> (camelCase for attributes)</li>
<li><strong>Document all extensions</strong> thoroughly</li>
<li><strong>Version your extensions</strong> appropriately</li>
<li><strong>Test extension compatibility</strong> with SCIM clients</li>
</ol>
<blockquote>
<p><strong>TODO</strong>: Add more advanced extension patterns and examples.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validation-2"><a class="header" href="#validation-2">Validation</a></h1>
<blockquote>
<p><strong>TODO</strong>: This section is under development. Basic schema validation patterns are outlined below.</p>
</blockquote>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>Schema validation ensures that SCIM resources conform to their defined schemas before being stored or processed. This includes validating data types, required fields, constraints, and custom business rules.</p>
<h2 id="built-in-validation-1"><a class="header" href="#built-in-validation-1">Built-in Validation</a></h2>
<h3 id="core-schema-validation"><a class="header" href="#core-schema-validation">Core Schema Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{Schema, ValidationError, ValidationResult};
use serde_json::Value;

pub struct SchemaValidator {
    schemas: HashMap&lt;String, Schema&gt;,
}

impl SchemaValidator {
    pub fn validate_resource(
        &amp;self,
        resource: &amp;Value,
        resource_type: &amp;str,
    ) -&gt; ValidationResult {
        let schemas = self.extract_schemas(resource)?;
        
        for schema_id in schemas {
            let schema = self.schemas.get(&amp;schema_id)
                .ok_or_else(|| ValidationError::UnknownSchema(schema_id.clone()))?;
            
            self.validate_against_schema(resource, schema)?;
        }
        
        Ok(())
    }
    
    fn validate_against_schema(
        &amp;self,
        resource: &amp;Value,
        schema: &amp;Schema,
    ) -&gt; ValidationResult {
        for attribute in schema.attributes() {
            self.validate_attribute(resource, attribute)?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-validation"><a class="header" href="#attribute-validation">Attribute Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::schema::{Attribute, AttributeType, Mutability};

impl SchemaValidator {
    fn validate_attribute(
        &amp;self,
        resource: &amp;Value,
        attribute: &amp;Attribute,
    ) -&gt; ValidationResult {
        let value = resource.get(attribute.name());
        
        // Check required attributes
        if attribute.required() &amp;&amp; value.is_none() {
            return Err(ValidationError::MissingRequired(attribute.name().to_string()));
        }
        
        if let Some(value) = value {
            // Type validation
            self.validate_type(value, attribute.type_())?;
            
            // Constraints validation
            if let Some(canonical_values) = attribute.canonical_values() {
                self.validate_canonical_values(value, canonical_values)?;
            }
            
            // Custom validation rules
            self.validate_custom_rules(value, attribute)?;
        }
        
        Ok(())
    }
    
    fn validate_type(&amp;self, value: &amp;Value, expected_type: AttributeType) -&gt; ValidationResult {
        match expected_type {
            AttributeType::String =&gt; {
                if !value.is_string() {
                    return Err(ValidationError::TypeMismatch {
                        expected: "string".to_string(),
                        actual: value.clone(),
                    });
                }
            },
            AttributeType::Boolean =&gt; {
                if !value.is_boolean() {
                    return Err(ValidationError::TypeMismatch {
                        expected: "boolean".to_string(),
                        actual: value.clone(),
                    });
                }
            },
            AttributeType::Integer =&gt; {
                if !value.is_i64() {
                    return Err(ValidationError::TypeMismatch {
                        expected: "integer".to_string(),
                        actual: value.clone(),
                    });
                }
            },
            // TODO: Add other type validations
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="custom-validation-rules-1"><a class="header" href="#custom-validation-rules-1">Custom Validation Rules</a></h2>
<h3 id="business-logic-validation"><a class="header" href="#business-logic-validation">Business Logic Validation</a></h3>
<blockquote>
<p><strong>TODO</strong>: Implement custom business rule validation patterns.</p>
</blockquote>
<h3 id="cross-field-validation"><a class="header" href="#cross-field-validation">Cross-Field Validation</a></h3>
<blockquote>
<p><strong>TODO</strong>: Add examples for validating relationships between fields.</p>
</blockquote>
<h2 id="validation-errors"><a class="header" href="#validation-errors">Validation Errors</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum ValidationError {
    MissingRequired(String),
    TypeMismatch {
        expected: String,
        actual: Value,
    },
    InvalidValue {
        field: String,
        value: Value,
        reason: String,
    },
    UnknownSchema(String),
    CustomRule {
        rule: String,
        message: String,
    },
}

impl std::fmt::Display for ValidationError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            ValidationError::MissingRequired(field) =&gt; {
                write!(f, "Missing required field: {}", field)
            },
            ValidationError::TypeMismatch { expected, actual } =&gt; {
                write!(f, "Type mismatch: expected {}, got {:?}", expected, actual)
            },
            ValidationError::InvalidValue { field, value, reason } =&gt; {
                write!(f, "Invalid value for {}: {:?} ({})", field, value, reason)
            },
            ValidationError::UnknownSchema(schema) =&gt; {
                write!(f, "Unknown schema: {}", schema)
            },
            ValidationError::CustomRule { rule, message } =&gt; {
                write!(f, "Custom rule '{}' failed: {}", rule, message)
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-providers"><a class="header" href="#integration-with-providers">Integration with Providers</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ResourceProvider for ValidatedProvider {
    async fn create_resource(
        &amp;self,
        resource_type: &amp;str,
        data: Value,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;ScimResource, ProviderError&gt; {
        // Validate before creating
        self.validator.validate_resource(&amp;data, resource_type)
            .map_err(|e| ProviderError::ValidationFailed(e))?;
        
        // Proceed with creation
        self.inner.create_resource(resource_type, data, context).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-validation"><a class="header" href="#testing-validation">Testing Validation</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_required_field_validation() {
        // TODO: Test required field validation
    }
    
    #[test]
    fn test_type_validation() {
        // TODO: Test type validation
    }
    
    #[test]
    fn test_custom_rules() {
        // TODO: Test custom validation rules
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>TODO</strong>: Add more comprehensive validation patterns and examples.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency-overview"><a class="header" href="#concurrency-overview">Concurrency Overview</a></h1>
<p>This guide provides an overview of concurrency management in the SCIM Server library. Understanding concurrency control is essential for building reliable, multi-user SCIM deployments that maintain data consistency under load.</p>
<h2 id="what-is-concurrency-control"><a class="header" href="#what-is-concurrency-control">What is Concurrency Control?</a></h2>
<p>Concurrency control ensures that simultaneous operations on shared resources don't interfere with each other or corrupt data. In SCIM servers, this is particularly important when multiple clients are:</p>
<ul>
<li>Modifying the same user or group</li>
<li>Creating resources with unique constraints</li>
<li>Performing bulk operations</li>
<li>Running in distributed deployments</li>
</ul>
<h2 id="scim-20-concurrency-model"><a class="header" href="#scim-20-concurrency-model">SCIM 2.0 Concurrency Model</a></h2>
<h3 id="etags-and-optimistic-concurrency"><a class="header" href="#etags-and-optimistic-concurrency">ETags and Optimistic Concurrency</a></h3>
<p>SCIM 2.0 uses ETags (Entity Tags) to implement optimistic concurrency control:</p>
<ol>
<li><strong>ETag Generation</strong>: Each resource gets a unique version identifier</li>
<li><strong>Client Requests</strong>: Clients include ETags in conditional requests</li>
<li><strong>Version Checking</strong>: Server validates ETags before modifications</li>
<li><strong>Conflict Detection</strong>: Mismatched ETags indicate concurrent modifications</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::concurrency::{ETagManager, VersionControl};
use scim_server::models::{User, Meta};
use chrono::Utc;

pub struct ETagManager {
    hash_algorithm: HashAlgorithm,
    weak_etags: bool,
}

impl ETagManager {
    pub fn new() -&gt; Self {
        Self {
            hash_algorithm: HashAlgorithm::Sha256,
            weak_etags: true, // SCIM typically uses weak ETags
        }
    }

    pub fn generate_etag(&amp;self, resource: &amp;dyn Resource) -&gt; String {
        let content = self.serialize_for_etag(resource);
        let hash = self.calculate_hash(&amp;content);
        let timestamp = Utc::now().timestamp_millis();
        
        if self.weak_etags {
            format!("W/\"{}-{}\"", hash, timestamp)
        } else {
            format!("\"{}-{}\"", hash, timestamp)
        }
    }

    pub fn parse_etag(&amp;self, etag: &amp;str) -&gt; Result&lt;ETagInfo, ETagError&gt; {
        let is_weak = etag.starts_with("W/");
        let tag_value = if is_weak {
            &amp;etag[3..etag.len()-1] // Remove W/" and "
        } else {
            &amp;etag[1..etag.len()-1] // Remove " and "
        };

        let parts: Vec&lt;&amp;str&gt; = tag_value.split('-').collect();
        if parts.len() != 2 {
            return Err(ETagError::InvalidFormat);
        }

        Ok(ETagInfo {
            hash: parts[0].to_string(),
            timestamp: parts[1].parse()?,
            is_weak,
        })
    }
}

pub struct ETagInfo {
    pub hash: String,
    pub timestamp: i64,
    pub is_weak: bool,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="http-conditional-headers"><a class="header" href="#http-conditional-headers">HTTP Conditional Headers</a></h3>
<p>SCIM uses standard HTTP conditional headers for concurrency control:</p>
<ul>
<li><strong>If-Match</strong>: Proceed only if ETag matches (for updates/deletes)</li>
<li><strong>If-None-Match</strong>: Proceed only if ETag doesn't match (for creates)</li>
<li><strong>If-Modified-Since</strong>: Check modification time</li>
<li><strong>If-Unmodified-Since</strong>: Check that resource hasn't been modified</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
pub struct ConditionalRequest {
    pub if_match: Option&lt;String&gt;,
    pub if_none_match: Option&lt;String&gt;,
    pub if_modified_since: Option&lt;DateTime&lt;Utc&gt;&gt;,
    pub if_unmodified_since: Option&lt;DateTime&lt;Utc&gt;&gt;,
}

impl ConditionalRequest {
    pub fn from_headers(headers: &amp;HeaderMap) -&gt; Self {
        Self {
            if_match: headers.get("If-Match")
                .and_then(|v| v.to_str().ok())
                .map(|s| s.to_string()),
            if_none_match: headers.get("If-None-Match")
                .and_then(|v| v.to_str().ok())
                .map(|s| s.to_string()),
            if_modified_since: headers.get("If-Modified-Since")
                .and_then(|v| v.to_str().ok())
                .and_then(|s| DateTime::parse_from_rfc2822(s).ok())
                .map(|dt| dt.with_timezone(&amp;Utc)),
            if_unmodified_since: headers.get("If-Unmodified-Since")
                .and_then(|v| v.to_str().ok())
                .and_then(|s| DateTime::parse_from_rfc2822(s).ok())
                .map(|dt| dt.with_timezone(&amp;Utc)),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="concurrency-strategies"><a class="header" href="#concurrency-strategies">Concurrency Strategies</a></h2>
<h3 id="1-optimistic-concurrency-control"><a class="header" href="#1-optimistic-concurrency-control">1. Optimistic Concurrency Control</a></h3>
<p>Assumes conflicts are rare and checks for them before committing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OptimisticConcurrencyManager {
    etag_manager: ETagManager,
    conflict_resolver: Box&lt;dyn ConflictResolver&gt;,
}

impl OptimisticConcurrencyManager {
    pub async fn update_resource&lt;T: Resource&gt;(
        &amp;self,
        storage: &amp;dyn StorageProvider,
        tenant_id: &amp;str,
        resource_id: &amp;str,
        updated_resource: T,
        conditions: &amp;ConditionalRequest,
    ) -&gt; Result&lt;T, ConcurrencyError&gt; {
        // Get current resource
        let current = storage.get_resource(tenant_id, resource_id).await?;
        
        // Validate conditions
        self.validate_conditions(&amp;current, conditions)?;
        
        // Attempt update
        match storage.update_resource(tenant_id, resource_id, updated_resource).await {
            Ok(result) =&gt; Ok(result),
            Err(StorageError::VersionMismatch) =&gt; {
                // Handle conflict
                self.handle_version_conflict(storage, tenant_id, resource_id, updated_resource).await
            }
            Err(e) =&gt; Err(ConcurrencyError::StorageError(e)),
        }
    }

    fn validate_conditions(
        &amp;self,
        resource: &amp;dyn Resource,
        conditions: &amp;ConditionalRequest,
    ) -&gt; Result&lt;(), ConcurrencyError&gt; {
        // Validate If-Match
        if let Some(if_match) = &amp;conditions.if_match {
            let current_etag = resource.get_etag();
            if !self.etags_match(if_match, &amp;current_etag) {
                return Err(ConcurrencyError::PreconditionFailed("If-Match failed".to_string()));
            }
        }

        // Validate If-None-Match
        if let Some(if_none_match) = &amp;conditions.if_none_match {
            let current_etag = resource.get_etag();
            if self.etags_match(if_none_match, &amp;current_etag) {
                return Err(ConcurrencyError::NotModified);
            }
        }

        // Validate If-Unmodified-Since
        if let Some(if_unmodified_since) = conditions.if_unmodified_since {
            if let Some(last_modified) = resource.get_last_modified() {
                if last_modified &gt; if_unmodified_since {
                    return Err(ConcurrencyError::PreconditionFailed("Resource was modified".to_string()));
                }
            }
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-pessimistic-concurrency-control"><a class="header" href="#2-pessimistic-concurrency-control">2. Pessimistic Concurrency Control</a></h3>
<p>Uses locks to prevent concurrent access:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait LockManager: Send + Sync {
    async fn acquire_lock(&amp;self, resource_id: &amp;str, lock_type: LockType, timeout: Duration) -&gt; Result&lt;Lock, LockError&gt;;
    async fn release_lock(&amp;self, lock: Lock) -&gt; Result&lt;(), LockError&gt;;
    async fn extend_lock(&amp;self, lock: &amp;mut Lock, duration: Duration) -&gt; Result&lt;(), LockError&gt;;
}

#[derive(Debug, Clone)]
pub enum LockType {
    Shared,    // Multiple readers
    Exclusive, // Single writer
}

pub struct Lock {
    pub id: String,
    pub resource_id: String,
    pub lock_type: LockType,
    pub acquired_at: DateTime&lt;Utc&gt;,
    pub expires_at: DateTime&lt;Utc&gt;,
    pub owner: String,
}

pub struct PessimisticConcurrencyManager {
    lock_manager: Box&lt;dyn LockManager&gt;,
    default_timeout: Duration,
}

impl PessimisticConcurrencyManager {
    pub async fn with_exclusive_lock&lt;T, F, Fut&gt;(
        &amp;self,
        resource_id: &amp;str,
        operation: F,
    ) -&gt; Result&lt;T, ConcurrencyError&gt;
    where
        F: FnOnce() -&gt; Fut,
        Fut: Future&lt;Output = Result&lt;T, ConcurrencyError&gt;&gt;,
    {
        let lock = self.lock_manager
            .acquire_lock(resource_id, LockType::Exclusive, self.default_timeout)
            .await?;

        let result = operation().await;

        self.lock_manager.release_lock(lock).await?;
        result
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="3-hybrid-approach"><a class="header" href="#3-hybrid-approach">3. Hybrid Approach</a></h3>
<p>Combines optimistic and pessimistic strategies:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct HybridConcurrencyManager {
    optimistic: OptimisticConcurrencyManager,
    pessimistic: PessimisticConcurrencyManager,
    conflict_threshold: usize,
    conflict_tracker: ConflictTracker,
}

impl HybridConcurrencyManager {
    pub async fn update_resource&lt;T: Resource&gt;(
        &amp;self,
        resource_id: &amp;str,
        update_fn: impl FnOnce(&amp;T) -&gt; Result&lt;T, ConcurrencyError&gt;,
    ) -&gt; Result&lt;T, ConcurrencyError&gt; {
        let conflict_count = self.conflict_tracker.get_recent_conflicts(resource_id).await;
        
        if conflict_count &gt; self.conflict_threshold {
            // High contention - use pessimistic locking
            self.pessimistic.with_exclusive_lock(resource_id, || async {
                // Perform update within lock
                self.optimistic.update_resource(resource_id, update_fn).await
            }).await
        } else {
            // Low contention - use optimistic approach
            match self.optimistic.update_resource(resource_id, update_fn).await {
                Ok(result) =&gt; Ok(result),
                Err(ConcurrencyError::VersionMismatch) =&gt; {
                    // Record conflict and retry with lock
                    self.conflict_tracker.record_conflict(resource_id).await;
                    self.pessimistic.with_exclusive_lock(resource_id, || async {
                        self.optimistic.update_resource(resource_id, update_fn).await
                    }).await
                }
                Err(e) =&gt; Err(e),
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="distributed-concurrency"><a class="header" href="#distributed-concurrency">Distributed Concurrency</a></h2>
<h3 id="redis-based-distributed-locking"><a class="header" href="#redis-based-distributed-locking">Redis-Based Distributed Locking</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use redis::{Client, Commands};

pub struct RedisLockManager {
    client: Client,
    lock_prefix: String,
    default_ttl: Duration,
}

impl RedisLockManager {
    pub fn new(redis_url: &amp;str) -&gt; Result&lt;Self, LockError&gt; {
        Ok(Self {
            client: Client::open(redis_url)?,
            lock_prefix: "scim:lock:".to_string(),
            default_ttl: Duration::from_secs(30),
        })
    }

    fn lock_key(&amp;self, resource_id: &amp;str) -&gt; String {
        format!("{}{}", self.lock_prefix, resource_id)
    }
}

#[async_trait]
impl LockManager for RedisLockManager {
    async fn acquire_lock(
        &amp;self,
        resource_id: &amp;str,
        lock_type: LockType,
        timeout: Duration,
    ) -&gt; Result&lt;Lock, LockError&gt; {
        let mut conn = self.client.get_async_connection().await?;
        let lock_key = self.lock_key(resource_id);
        let lock_value = uuid::Uuid::new_v4().to_string();
        let ttl_seconds = self.default_ttl.as_secs() as usize;

        let start = Instant::now();
        
        loop {
            // Try to acquire lock using SET NX EX
            let result: Option&lt;String&gt; = conn.set_nx_ex(&amp;lock_key, &amp;lock_value, ttl_seconds).await?;
            
            if result.is_some() {
                return Ok(Lock {
                    id: lock_value,
                    resource_id: resource_id.to_string(),
                    lock_type,
                    acquired_at: Utc::now(),
                    expires_at: Utc::now() + chrono::Duration::from_std(self.default_ttl).unwrap(),
                    owner: "current_process".to_string(),
                });
            }

            if start.elapsed() &gt;= timeout {
                return Err(LockError::Timeout);
            }

            tokio::time::sleep(Duration::from_millis(50)).await;
        }
    }

    async fn release_lock(&amp;self, lock: Lock) -&gt; Result&lt;(), LockError&gt; {
        let mut conn = self.client.get_async_connection().await?;
        let lock_key = self.lock_key(&amp;lock.resource_id);

        // Use Lua script for atomic check-and-delete
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
        "#;

        let result: i32 = redis::Script::new(script)
            .key(&amp;lock_key)
            .arg(&amp;lock.id)
            .invoke_async(&amp;mut conn)
            .await?;

        if result == 1 {
            Ok(())
        } else {
            Err(LockError::LockNotFound)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-11"><a class="header" href="#error-handling-11">Error Handling</a></h2>
<h3 id="concurrency-related-errors"><a class="header" href="#concurrency-related-errors">Concurrency-Related Errors</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, thiserror::Error)]
pub enum ConcurrencyError {
    #[error("Version mismatch detected")]
    VersionMismatch,
    
    #[error("Precondition failed: {0}")]
    PreconditionFailed(String),
    
    #[error("Resource not modified")]
    NotModified,
    
    #[error("Lock acquisition failed: {0}")]
    LockFailed(String),
    
    #[error("Lock timeout exceeded")]
    LockTimeout,
    
    #[error("Deadlock detected")]
    Deadlock,
    
    #[error("Conflict resolution failed: {0}")]
    ConflictResolutionFailed(String),
    
    #[error("Storage error: {0}")]
    StorageError(#[from] StorageError),
}

impl From&lt;ConcurrencyError&gt; for ScimError {
    fn from(error: ConcurrencyError) -&gt; Self {
        match error {
            ConcurrencyError::VersionMismatch =&gt; ScimError::PreconditionFailed,
            ConcurrencyError::PreconditionFailed(_) =&gt; ScimError::PreconditionFailed,
            ConcurrencyError::NotModified =&gt; ScimError::NotModified,
            ConcurrencyError::LockTimeout =&gt; ScimError::TooManyRequests,
            _ =&gt; ScimError::InternalServerError,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-5"><a class="header" href="#performance-considerations-5">Performance Considerations</a></h2>
<h3 id="etag-optimization"><a class="header" href="#etag-optimization">ETag Optimization</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct OptimizedETagManager {
    cache: Arc&lt;RwLock&lt;LruCache&lt;String, String&gt;&gt;&gt;,
    hash_cache_size: usize,
}

impl OptimizedETagManager {
    pub fn generate_etag_cached(&amp;self, resource: &amp;dyn Resource) -&gt; String {
        let resource_key = format!("{}:{}", resource.get_type(), resource.get_id());
        
        // Check cache first
        {
            let cache = self.cache.read().unwrap();
            if let Some(cached_etag) = cache.peek(&amp;resource_key) {
                // Verify resource hasn't changed
                if self.resource_unchanged(resource, cached_etag) {
                    return cached_etag.clone();
                }
            }
        }
        
        // Generate new ETag
        let new_etag = self.generate_fresh_etag(resource);
        
        // Update cache
        {
            let mut cache = self.cache.write().unwrap();
            cache.put(resource_key, new_etag.clone());
        }
        
        new_etag
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lock-granularity"><a class="header" href="#lock-granularity">Lock Granularity</a></h3>
<p>Choose appropriate lock granularity for your use case:</p>
<ul>
<li><strong>Resource-level</strong>: Lock individual users/groups (fine-grained)</li>
<li><strong>Tenant-level</strong>: Lock entire tenant (coarse-grained)</li>
<li><strong>Attribute-level</strong>: Lock specific attributes (very fine-grained)</li>
<li><strong>Operation-level</strong>: Lock based on operation type</li>
</ul>
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<h3 id="1-etag-management"><a class="header" href="#1-etag-management">1. ETag Management</a></h3>
<ul>
<li>Always include ETags in resource metadata</li>
<li>Use weak ETags for flexibility</li>
<li>Cache ETag calculations for performance</li>
<li>Implement ETag validation consistently</li>
</ul>
<h3 id="2-lock-management"><a class="header" href="#2-lock-management">2. Lock Management</a></h3>
<ul>
<li>Keep lock duration minimal</li>
<li>Implement lock timeouts</li>
<li>Use deadlock detection</li>
<li>Consider lock hierarchies</li>
</ul>
<h3 id="3-conflict-resolution"><a class="header" href="#3-conflict-resolution">3. Conflict Resolution</a></h3>
<ul>
<li>Provide meaningful error messages</li>
<li>Implement retry strategies</li>
<li>Log concurrency conflicts</li>
<li>Monitor conflict rates</li>
</ul>
<h3 id="4-performance-1"><a class="header" href="#4-performance-1">4. Performance</a></h3>
<ul>
<li>Use appropriate concurrency strategy for load patterns</li>
<li>Monitor lock contention</li>
<li>Optimize for common cases</li>
<li>Consider eventual consistency where appropriate</li>
</ul>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><a href="concurrency/./implementation.html">Implementation</a> - Learn to implement concurrency control</li>
<li><a href="concurrency/./conflict-resolution.html">Conflict Resolution</a> - Handle conflicts gracefully</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">Implementation</a></h1>
<blockquote>
<p><strong>TODO</strong>: This section is under development. Basic implementation patterns are outlined below.</p>
</blockquote>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>This guide covers practical implementation of concurrency control in SCIM Server, including ETag generation, version tracking, and conditional operations.</p>
<h2 id="etag-generation-1"><a class="header" href="#etag-generation-1">ETag Generation</a></h2>
<h3 id="basic-etag-implementation"><a class="header" href="#basic-etag-implementation">Basic ETag Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone)]
pub struct ETag {
    value: String,
    weak: bool,
}

impl ETag {
    pub fn from_content(content: &amp;[u8]) -&gt; Self {
        let mut hasher = DefaultHasher::new();
        content.hash(&amp;mut hasher);
        let hash = hasher.finish();
        
        ETag {
            value: format!("\"{}\"", hash),
            weak: false,
        }
    }
    
    pub fn from_timestamp(timestamp: DateTime&lt;Utc&gt;) -&gt; Self {
        ETag {
            value: format!("\"{}\"", timestamp.timestamp()),
            weak: true,
        }
    }
    
    pub fn weak() -&gt; Self {
        ETag {
            value: format!("\"{}\"", uuid::Uuid::new_v4()),
            weak: true,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="version-tracking"><a class="header" href="#version-tracking">Version Tracking</a></h2>
<h3 id="database-schema"><a class="header" href="#database-schema">Database Schema</a></h3>
<pre><code class="language-sql">-- Add versioning columns to resource tables
ALTER TABLE users ADD COLUMN version INTEGER DEFAULT 1;
ALTER TABLE users ADD COLUMN etag VARCHAR(64);
ALTER TABLE users ADD COLUMN last_modified TIMESTAMPTZ DEFAULT NOW();

-- Create index for efficient lookups
CREATE INDEX idx_users_etag ON users(tenant_id, id, etag);
</code></pre>
<h3 id="provider-implementation"><a class="header" href="#provider-implementation">Provider Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ResourceProvider for DatabaseProvider {
    async fn conditional_update(
        &amp;self,
        resource_type: &amp;str,
        id: &amp;str,
        data: serde_json::Value,
        expected_etag: &amp;ETag,
        context: &amp;RequestContext,
    ) -&gt; Result&lt;ConditionalResult&lt;VersionedResource&gt;, ProviderError&gt; {
        let mut tx = self.pool.begin().await?;
        
        // Check current version
        let current = sqlx::query!(
            "SELECT etag, version FROM users WHERE tenant_id = $1 AND id = $2",
            context.tenant_id(),
            id
        )
        .fetch_optional(&amp;mut *tx)
        .await?;
        
        let Some(current) = current else {
            return Ok(ConditionalResult::NotFound);
        };
        
        // Verify ETag matches
        if current.etag != expected_etag.value() {
            return Ok(ConditionalResult::VersionMismatch(VersionConflict {
                resource_id: id.to_string(),
                expected_version: expected_etag.clone(),
                current_version: ETag::from_str(&amp;current.etag)?,
            }));
        }
        
        // Update with new version
        let new_version = current.version + 1;
        let new_etag = ETag::from_content(&amp;serde_json::to_vec(&amp;data)?);
        
        sqlx::query!(
            "UPDATE users SET data = $1, version = $2, etag = $3, last_modified = NOW() 
             WHERE tenant_id = $4 AND id = $5",
            data,
            new_version,
            new_etag.value(),
            context.tenant_id(),
            id
        )
        .execute(&amp;mut *tx)
        .await?;
        
        tx.commit().await?;
        
        let updated = self.get_resource(resource_type, id, context).await?
            .ok_or(ProviderError::NotFound)?;
            
        Ok(ConditionalResult::Success(VersionedResource::new(updated, new_etag)))
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="http-headers"><a class="header" href="#http-headers">HTTP Headers</a></h2>
<h3 id="request-headers"><a class="header" href="#request-headers">Request Headers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::http::HeaderMap;

fn extract_if_match(headers: &amp;HeaderMap) -&gt; Option&lt;ETag&gt; {
    headers.get("If-Match")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| ETag::from_str(s).ok())
}

fn extract_if_none_match(headers: &amp;HeaderMap) -&gt; Option&lt;ETag&gt; {
    headers.get("If-None-Match")
        .and_then(|h| h.to_str().ok())
        .and_then(|s| ETag::from_str(s).ok())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="response-headers"><a class="header" href="#response-headers">Response Headers</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::response::{Response, IntoResponse};
use axum::http::{StatusCode, HeaderValue};

fn add_etag_header(mut response: Response, etag: &amp;ETag) -&gt; Response {
    response.headers_mut().insert(
        "ETag",
        HeaderValue::from_str(etag.value()).unwrap()
    );
    response
}

fn not_modified_response(etag: &amp;ETag) -&gt; impl IntoResponse {
    let mut response = Response::new("".into());
    *response.status_mut() = StatusCode::NOT_MODIFIED;
    add_etag_header(response, etag)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-considerations-6"><a class="header" href="#performance-considerations-6">Performance Considerations</a></h2>
<h3 id="1-etag-caching"><a class="header" href="#1-etag-caching">1. ETag Caching</a></h3>
<blockquote>
<p><strong>TODO</strong>: Implement efficient ETag caching strategies.</p>
</blockquote>
<h3 id="2-database-optimization"><a class="header" href="#2-database-optimization">2. Database Optimization</a></h3>
<blockquote>
<p><strong>TODO</strong>: Add database-specific optimization patterns.</p>
</blockquote>
<h3 id="3-memory-usage"><a class="header" href="#3-memory-usage">3. Memory Usage</a></h3>
<blockquote>
<p><strong>TODO</strong>: Document memory usage patterns for large-scale deployments.</p>
</blockquote>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_conditional_update_success() {
        // TODO: Implement comprehensive test cases
    }
    
    #[tokio::test]
    async fn test_version_mismatch() {
        // TODO: Test conflict detection
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>TODO</strong>: Add more comprehensive implementation examples and patterns.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conflict-resolution"><a class="header" href="#conflict-resolution">Conflict Resolution</a></h1>
<blockquote>
<p><strong>TODO</strong>: This section is under development. Basic conflict resolution patterns are outlined below.</p>
</blockquote>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>When multiple clients attempt to modify the same SCIM resource simultaneously, conflicts can occur. This guide covers strategies for detecting and resolving these conflicts using ETags and version control.</p>
<h2 id="conflict-detection"><a class="header" href="#conflict-detection">Conflict Detection</a></h2>
<h3 id="etag-based-detection"><a class="header" href="#etag-based-detection">ETag-Based Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ConditionalResult, ETag};

async fn update_user_with_conflict_detection(
    provider: &amp;impl ResourceProvider,
    user_id: &amp;str,
    data: serde_json::Value,
    expected_etag: &amp;ETag,
) -&gt; Result&lt;ScimUser, ConflictError&gt; {
    let context = RequestContext::new("update", None);
    
    match provider.conditional_update("User", user_id, data, expected_etag, &amp;context).await? {
        ConditionalResult::Success(user) =&gt; Ok(user),
        ConditionalResult::VersionMismatch(conflict) =&gt; {
            Err(ConflictError::VersionMismatch {
                expected: expected_etag.clone(),
                current: conflict.current_version,
                resource_id: user_id.to_string(),
            })
        },
        ConditionalResult::NotFound =&gt; Err(ConflictError::ResourceNotFound),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resolution-strategies"><a class="header" href="#resolution-strategies">Resolution Strategies</a></h2>
<h3 id="1-last-writer-wins"><a class="header" href="#1-last-writer-wins">1. Last-Writer-Wins</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Simple approach: retry with latest version
async fn retry_with_latest(
    provider: &amp;impl ResourceProvider,
    user_id: &amp;str,
    data: serde_json::Value,
) -&gt; Result&lt;ScimUser, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("retry", None);
    
    // Get current version
    let current = provider.get_resource("User", user_id, &amp;context).await?
        .ok_or("User not found")?;
    
    // Apply update with current version
    provider.update_resource("User", user_id, data, &amp;context).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="2-three-way-merge"><a class="header" href="#2-three-way-merge">2. Three-Way Merge</a></h3>
<blockquote>
<p><strong>TODO</strong>: Implement sophisticated merge strategies for complex conflicts.</p>
</blockquote>
<h3 id="3-client-side-resolution"><a class="header" href="#3-client-side-resolution">3. Client-Side Resolution</a></h3>
<blockquote>
<p><strong>TODO</strong>: Add examples for client-side conflict resolution patterns.</p>
</blockquote>
<h2 id="error-handling-12"><a class="header" href="#error-handling-12">Error Handling</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
pub enum ConflictError {
    VersionMismatch {
        expected: ETag,
        current: ETag,
        resource_id: String,
    },
    ResourceNotFound,
    MergeConflict {
        field: String,
        local_value: serde_json::Value,
        remote_value: serde_json::Value,
    },
}

impl std::fmt::Display for ConflictError {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        match self {
            ConflictError::VersionMismatch { expected, current, resource_id } =&gt; {
                write!(f, "Version conflict on {}: expected {}, got {}", 
                       resource_id, expected, current)
            },
            ConflictError::ResourceNotFound =&gt; write!(f, "Resource not found"),
            ConflictError::MergeConflict { field, .. } =&gt; {
                write!(f, "Merge conflict in field: {}", field)
            },
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<ol>
<li><strong>Always use ETags</strong> for update operations</li>
<li><strong>Implement retry logic</strong> with exponential backoff</li>
<li><strong>Provide clear error messages</strong> to clients</li>
<li><strong>Log conflicts</strong> for monitoring and debugging</li>
</ol>
<blockquote>
<p><strong>TODO</strong>: Add more sophisticated conflict resolution algorithms and patterns.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrate-between-versions"><a class="header" href="#migrate-between-versions">Migrate Between Versions</a></h1>
<p>This guide covers migrating your SCIM Server implementation between versions within the 0.3.x series. The library follows semantic versioning and provides clear migration paths for breaking changes.</p>
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>The SCIM Server library started at version 0.3.0 and follows semantic versioning:</p>
<ul>
<li><strong>Patch versions</strong> (0.3.0 → 0.3.1 → 0.3.2): Bug fixes, no breaking changes</li>
<li><strong>Minor versions</strong> (0.3.x → 0.4.x): New features, backward compatible</li>
<li><strong>Major versions</strong> (0.x.x → 1.x.x): Breaking changes requiring migration</li>
</ul>
<h2 id="current-version-history"><a class="header" href="#current-version-history">Current Version History</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Version</th><th>Release Date</th><th>Type</th><th>Key Changes</th></tr></thead><tbody>
<tr><td>0.3.0</td><td>2024-12</td><td>Initial</td><td>Initial release with core SCIM 2.0 functionality</td></tr>
<tr><td>0.3.1</td><td>2024-12</td><td>Patch</td><td>Enhanced storage provider architecture</td></tr>
<tr><td>0.3.2</td><td>2024-12</td><td>Patch</td><td>ETag concurrency control, MCP integration</td></tr>
</tbody></table>
</div>
<h2 id="migration-within-03x-series"><a class="header" href="#migration-within-03x-series">Migration Within 0.3.x Series</a></h2>
<h3 id="from-030-to-031"><a class="header" href="#from-030-to-031">From 0.3.0 to 0.3.1</a></h3>
<p><strong>Breaking Changes</strong>: None - This is a patch release.</p>
<p><strong>New Features</strong>:</p>
<ul>
<li>Enhanced storage provider architecture</li>
<li>Improved error handling</li>
<li>Additional validation features</li>
</ul>
<p><strong>Migration Steps</strong>:</p>
<ol>
<li>
<p>Update <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
scim-server = "0.3.1"
</code></pre>
</li>
<li>
<p>Run <code>cargo update</code> to update dependencies</p>
</li>
<li>
<p>No code changes required - all existing code continues to work</p>
</li>
</ol>
<h3 id="from-031-to-032"><a class="header" href="#from-031-to-032">From 0.3.1 to 0.3.2</a></h3>
<p><strong>Breaking Changes</strong>: None - This is a patch release.</p>
<p><strong>New Features</strong>:</p>
<ul>
<li>ETag concurrency control system</li>
<li>MCP (Model Context Protocol) integration for AI agents</li>
<li>Enhanced versioning with <code>VersionedResource</code></li>
<li>Conditional operations support</li>
</ul>
<p><strong>Migration Steps</strong>:</p>
<ol>
<li>
<p>Update <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
scim-server = "0.3.2"
</code></pre>
</li>
<li>
<p>Run <code>cargo update</code></p>
</li>
<li>
<p><strong>Optional</strong>: Migrate to new concurrency features:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::resource::version::{VersionedResource, ConditionalResult};

// Old approach (still works)
let resource = provider.update_resource("User", &amp;id, data, &amp;context).await?;

// New approach with version control
let versioned = provider.conditional_update("User", &amp;id, data, &amp;expected_version, &amp;context).await?;
match versioned {
    ConditionalResult::Success(resource) =&gt; { /* Update succeeded */ },
    ConditionalResult::VersionMismatch(conflict) =&gt; { /* Handle conflict */ },
    ConditionalResult::NotFound =&gt; { /* Resource not found */ },
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="best-practices-for-migration"><a class="header" href="#best-practices-for-migration">Best Practices for Migration</a></h2>
<h3 id="1-test-before-upgrading"><a class="header" href="#1-test-before-upgrading">1. Test Before Upgrading</a></h3>
<p>Always test version upgrades in a development environment:</p>
<pre><code class="language-bash"># Create a test project
cargo new scim-test
cd scim-test

# Add the new version
cargo add scim-server@0.3.2

# Test your existing code
cargo build
cargo test
</code></pre>
<h3 id="2-review-release-notes"><a class="header" href="#2-review-release-notes">2. Review Release Notes</a></h3>
<p>Check the <a href="how-to/../../../../CHANGELOG.html">CHANGELOG.md</a> for detailed information about each release:</p>
<ul>
<li>New features and their usage</li>
<li>Bug fixes that might affect your code</li>
<li>Performance improvements</li>
<li>Deprecation notices</li>
</ul>
<h3 id="3-incremental-updates"><a class="header" href="#3-incremental-updates">3. Incremental Updates</a></h3>
<p>For multiple version updates, upgrade incrementally:</p>
<pre><code class="language-bash"># Instead of 0.3.0 → 0.3.2 directly
cargo add scim-server@0.3.1  # First step
cargo build &amp;&amp; cargo test     # Verify
cargo add scim-server@0.3.2  # Second step
cargo build &amp;&amp; cargo test     # Verify
</code></pre>
<h3 id="4-backup-before-production-updates"><a class="header" href="#4-backup-before-production-updates">4. Backup Before Production Updates</a></h3>
<p>Always backup your data before updating production systems:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example backup before migration
async fn backup_before_migration() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let provider = get_production_provider().await?;
    let context = RequestContext::new("migration", None);
    
    // Backup all users
    let users = provider.list_resources("User", None, &amp;context).await?;
    let backup_file = format!("users_backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S"));
    std::fs::write(backup_file, serde_json::to_string_pretty(&amp;users)?)?;
    
    // Backup all groups
    let groups = provider.list_resources("Group", None, &amp;context).await?;
    let backup_file = format!("groups_backup_{}.json", chrono::Utc::now().format("%Y%m%d_%H%M%S"));
    std::fs::write(backup_file, serde_json::to_string_pretty(&amp;groups)?)?;
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="staying-updated"><a class="header" href="#staying-updated">Staying Updated</a></h2>
<h3 id="1-watch-for-new-releases"><a class="header" href="#1-watch-for-new-releases">1. Watch for New Releases</a></h3>
<p>Monitor the repository for new releases:</p>
<ul>
<li>GitHub releases page</li>
<li>Cargo.toml dependency updates</li>
<li>Security advisories</li>
</ul>
<h3 id="2-dependency-updates"><a class="header" href="#2-dependency-updates">2. Dependency Updates</a></h3>
<p>Regularly update dependencies:</p>
<pre><code class="language-bash"># Check for outdated dependencies
cargo outdated

# Update to latest compatible versions
cargo update

# Update to specific version
cargo add scim-server@latest
</code></pre>
<h3 id="3-feature-migration"><a class="header" href="#3-feature-migration">3. Feature Migration</a></h3>
<p>When new features are released, consider migrating gradually:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Adopting ETag concurrency control
impl MyApplication {
    // Phase 1: Add version checking without enforcement
    async fn soft_version_check(&amp;self, id: &amp;str, expected_version: Option&lt;&amp;str&gt;) -&gt; bool {
        if let Some(version) = expected_version {
            // Log version mismatches but don't fail
            match self.provider.get_versioned_resource("User", id, &amp;self.context).await {
                Ok(Some(resource)) =&gt; {
                    if resource.version().as_str() != version {
                        warn!("Version mismatch detected for user {}: expected {}, got {}", 
                              id, version, resource.version());
                        return false;
                    }
                },
                _ =&gt; return false,
            }
        }
        true
    }
    
    // Phase 2: Enforce version checking
    async fn strict_version_check(&amp;self, id: &amp;str, expected_version: &amp;str) -&gt; Result&lt;(), AppError&gt; {
        // Now fail on version mismatches
        // Implementation...
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="future-migration-planning"><a class="header" href="#future-migration-planning">Future Migration Planning</a></h2>
<h3 id="upcoming-major-version-10x"><a class="header" href="#upcoming-major-version-10x">Upcoming Major Version (1.0.x)</a></h3>
<p>The library is working toward a 1.0 release that may include:</p>
<ul>
<li>
<p><strong>Potential Breaking Changes</strong>:</p>
<ul>
<li>SCIM filter expression parser (if it changes API)</li>
<li>Bulk operations implementation</li>
<li>Enhanced multi-tenancy features</li>
</ul>
</li>
<li>
<p><strong>Migration Planning</strong>:</p>
<ul>
<li>Follow this documentation for migration guides</li>
<li>Test pre-release versions in development</li>
<li>Plan for potential downtime if storage formats change</li>
</ul>
</li>
</ul>
<h3 id="staying-compatible"><a class="header" href="#staying-compatible">Staying Compatible</a></h3>
<p>To minimize migration effort:</p>
<ol>
<li><strong>Use the public API</strong>: Avoid relying on internal implementation details</li>
<li><strong>Follow deprecation warnings</strong>: Migrate away from deprecated features early</li>
<li><strong>Use feature flags conservatively</strong>: Only enable features you actively use</li>
<li><strong>Test thoroughly</strong>: Comprehensive tests make migrations safer</li>
</ol>
<h2 id="getting-help-2"><a class="header" href="#getting-help-2">Getting Help</a></h2>
<p>If you encounter issues during migration:</p>
<ol>
<li><strong>Check the <a href="how-to/../../../../CHANGELOG.html">CHANGELOG.md</a></strong> for version-specific notes</li>
<li><strong>Review <a href="https://github.com/pukeko37/scim-server/issues">GitHub Issues</a></strong> for known problems</li>
<li><strong>Ask questions</strong> in GitHub Discussions</li>
<li><strong>Report bugs</strong> with version information and reproduction steps</li>
</ol>
<h2 id="example-complete-migration-script"><a class="header" href="#example-complete-migration-script">Example: Complete Migration Script</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// migration_helper.rs
use scim_server::*;

pub struct MigrationHelper {
    old_provider: Box&lt;dyn ResourceProvider&gt;,
    new_provider: Box&lt;dyn ResourceProvider&gt;,
}

impl MigrationHelper {
    pub async fn verify_compatibility(&amp;self) -&gt; Result&lt;(), MigrationError&gt; {
        // Verify that existing code still works
        let context = RequestContext::new("migration_test", None);
        
        // Test basic operations
        let test_user = serde_json::json!({
            "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
            "userName": "migration.test@example.com"
        });
        
        // This should work across all 0.3.x versions
        let created = self.new_provider.create_resource("User", test_user, &amp;context).await?;
        let retrieved = self.new_provider.get_resource("User", &amp;created.id().unwrap(), &amp;context).await?;
        self.new_provider.delete_resource("User", &amp;created.id().unwrap(), &amp;context).await?;
        
        println!("✅ Migration compatibility verified");
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This migration guide focuses on actual version history and real migration scenarios for the SCIM Server library. As the library evolves, this guide will be updated with specific migration instructions for each version.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h1>
<p>This guide helps you diagnose and resolve common issues when working with the SCIM Server library. It covers typical problems, debugging techniques, and performance optimization.</p>
<h2 id="common-issues-1"><a class="header" href="#common-issues-1">Common Issues</a></h2>
<h3 id="connection-and-network-problems"><a class="header" href="#connection-and-network-problems">Connection and Network Problems</a></h3>
<h4 id="connection-refused-or-unable-to-connect"><a class="header" href="#connection-refused-or-unable-to-connect">"Connection refused" or "Unable to connect"</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Server fails to start</li>
<li>Client connections are rejected</li>
<li>Network timeouts</li>
</ul>
<p><strong>Causes &amp; Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if port is already in use
use tokio::net::TcpListener;

// This will fail if port is occupied
let listener = TcpListener::bind("0.0.0.0:3000").await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution 1: Change port</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try a different port
let listener = TcpListener::bind("0.0.0.0:3001").await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution 2: Find and kill process using port</strong></p>
<pre><code class="language-bash"># Find process using port 3000
lsof -i :3000
# Kill the process
kill -9 &lt;PID&gt;
</code></pre>
<p><strong>Solution 3: Bind to correct interface</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For local development
let listener = TcpListener::bind("127.0.0.1:3000").await?;

// For production (all interfaces)
let listener = TcpListener::bind("0.0.0.0:3000").await?;
<span class="boring">}</span></code></pre></pre>
<h4 id="database-connection-issues"><a class="header" href="#database-connection-issues">Database Connection Issues</a></h4>
<p><strong>Error: "Failed to connect to database"</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::DatabaseProvider;

// Add connection retry logic
async fn connect_with_retry(url: &amp;str, max_retries: u32) -&gt; Result&lt;DatabaseProvider, Error&gt; {
    let mut attempts = 0;
    
    loop {
        match DatabaseProvider::new(url).await {
            Ok(provider) =&gt; return Ok(provider),
            Err(e) if attempts &lt; max_retries =&gt; {
                attempts += 1;
                println!("Connection attempt {} failed: {}. Retrying in 5 seconds...", attempts, e);
                tokio::time::sleep(Duration::from_secs(5)).await;
            },
            Err(e) =&gt; return Err(e.into()),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Common database URL formats:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PostgreSQL
"postgresql://username:password@localhost:5432/scim_db"

// SQLite
"sqlite:./scim.db"
"sqlite::memory:" // For testing

// MySQL
"mysql://username:password@localhost:3306/scim_db"
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-and-authorization-issues"><a class="header" href="#authentication-and-authorization-issues">Authentication and Authorization Issues</a></h3>
<h4 id="401-unauthorized-responses"><a class="header" href="#401-unauthorized-responses">"401 Unauthorized" responses</a></h4>
<p><strong>Check authentication configuration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn debug_auth_middleware(
    headers: HeaderMap,
    request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Log all headers for debugging
    for (name, value) in headers.iter() {
        println!("Header: {} = {:?}", name, value);
    }
    
    // Check for Authorization header
    if let Some(auth_header) = headers.get("Authorization") {
        println!("Auth header found: {:?}", auth_header);
    } else {
        println!("No Authorization header found");
        return Err(StatusCode::UNAUTHORIZED);
    }
    
    Ok(next.run(request).await)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Common authentication problems:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Problem: Missing Bearer prefix
// Wrong: "abc123def456"
// Correct: "Bearer abc123def456"

// Problem: Expired tokens
let now = chrono::Utc::now().timestamp() as usize;
if token_claims.exp &lt; now {
    return Err(StatusCode::UNAUTHORIZED);
}

// Problem: Incorrect Base64 encoding for Basic auth
use base64::{Engine as _, engine::general_purpose};
let encoded = general_purpose::STANDARD.encode("username:password");
println!("Correct Basic auth: Basic {}", encoded);
<span class="boring">}</span></code></pre></pre>
<h4 id="403-forbidden-responses"><a class="header" href="#403-forbidden-responses">"403 Forbidden" responses</a></h4>
<p><strong>Debug permission checking:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_permissions(user_perms: &amp;[String], required_perm: &amp;str) -&gt; bool {
    println!("User permissions: {:?}", user_perms);
    println!("Required permission: {}", required_perm);
    
    let has_permission = user_perms.contains(&amp;required_perm.to_string());
    println!("Permission granted: {}", has_permission);
    
    has_permission
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-and-data-issues"><a class="header" href="#resource-and-data-issues">Resource and Data Issues</a></h3>
<h4 id="404-not-found-for-existing-resources"><a class="header" href="#404-not-found-for-existing-resources">"404 Not Found" for existing resources</a></h4>
<p><strong>Check tenant isolation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you're using the correct tenant ID
let user = provider.get_user("correct-tenant-id", &amp;user_id).await?;

// Debug tenant data
let all_tenants = provider.list_all_tenants().await?;
println!("Available tenants: {:?}", all_tenants);
<span class="boring">}</span></code></pre></pre>
<p><strong>Verify resource IDs:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// UUIDs are case-sensitive
let user_id = "2819c223-7f76-453a-919d-413861904646"; // Correct
let user_id = "2819C223-7F76-453A-919D-413861904646"; // Wrong case

// Check if resource exists
if let Some(user) = provider.get_user(tenant_id, user_id).await? {
    println!("User found: {}", user.username());
} else {
    println!("User not found with ID: {}", user_id);
    
    // List all users to debug
    let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
    for user in all_users.resources {
        println!("Existing user: {} ({})", user.username(), user.id());
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="409-conflict-on-resource-creation"><a class="header" href="#409-conflict-on-resource-creation">"409 Conflict" on resource creation</a></h4>
<p><strong>Check for duplicate constraints:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug uniqueness violations
match provider.create_user(tenant_id, user).await {
    Err(ProviderError::Conflict(msg)) =&gt; {
        println!("Conflict detected: {}", msg);
        
        // Check for existing username
        if let Some(existing) = provider.find_user_by_username(tenant_id, &amp;user.username()).await? {
            println!("User with username '{}' already exists: {}", user.username(), existing.id());
        }
        
        // Check for existing email
        if let Some(email) = user.primary_email() {
            if let Some(existing) = provider.find_user_by_email(tenant_id, email).await? {
                println!("User with email '{}' already exists: {}", email, existing.id());
            }
        }
    },
    Ok(created_user) =&gt; println!("User created successfully: {}", created_user.id()),
    Err(e) =&gt; println!("Unexpected error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="412-precondition-failed-on-updates"><a class="header" href="#412-precondition-failed-on-updates">"412 Precondition Failed" on updates</a></h4>
<p><strong>ETag version conflicts:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always fetch latest version before update
let mut user = provider.get_user(tenant_id, user_id).await?
    .ok_or("User not found")?;

println!("Current user version: {}", user.meta().version);

// Make your changes
user.set_given_name("Updated Name");

// Update with current version
match provider.update_user(tenant_id, user).await {
    Ok(updated_user) =&gt; {
        println!("Update successful. New version: {}", updated_user.meta().version);
    },
    Err(ProviderError::VersionConflict { current_version, provided_version }) =&gt; {
        println!("Version conflict: expected {}, got {}", current_version, provided_version);
        
        // Retry with fresh data
        let fresh_user = provider.get_user(tenant_id, user_id).await?;
        // Apply changes to fresh user and retry
    },
    Err(e) =&gt; println!("Update failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validation-and-schema-issues"><a class="header" href="#validation-and-schema-issues">Validation and Schema Issues</a></h3>
<h4 id="400-bad-request-with-validation-errors"><a class="header" href="#400-bad-request-with-validation-errors">"400 Bad Request" with validation errors</a></h4>
<p><strong>Debug JSON parsing:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json;

// Test JSON deserialization
let json_str = r#"{"invalid": "json"}"#;
match serde_json::from_str::&lt;ScimUser&gt;(json_str) {
    Ok(user) =&gt; println!("User parsed successfully"),
    Err(e) =&gt; {
        println!("JSON parsing failed: {}", e);
        println!("Error location: line {}, column {}", e.line(), e.column());
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Validate required fields:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check for missing required fields
match ScimUser::builder()
    .username("test@example.com")
    // Missing other required fields
    .build() 
{
    Ok(user) =&gt; println!("User created: {}", user.id()),
    Err(ValidationError::RequiredField(field)) =&gt; {
        println!("Missing required field: {}", field);
    },
    Err(e) =&gt; println!("Validation error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Schema validation debugging:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check schema compliance
let user = ScimUser::builder()
    .username("test@example.com")
    .given_name("Test")
    .family_name("User")
    .build()?;

// Validate against schema
match schema_registry.validate_user(&amp;user) {
    Ok(_) =&gt; println!("User is valid according to schema"),
    Err(ValidationError::SchemaViolation { field, message }) =&gt; {
        println!("Schema violation in field '{}': {}", field, message);
    },
    Err(e) =&gt; println!("Validation error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h2>
<h3 id="enable-detailed-logging"><a class="header" href="#enable-detailed-logging">Enable Detailed Logging</a></h3>
<pre><pre class="playground"><code class="language-rust">use tracing::{info, warn, error, debug};
use tracing_subscriber::{EnvFilter, fmt};

// Set up comprehensive logging
fn setup_logging() {
    let filter = EnvFilter::from_default_env()
        .add_directive("scim_server=debug".parse().unwrap())
        .add_directive("sqlx=info".parse().unwrap())
        .add_directive("hyper=info".parse().unwrap());

    fmt()
        .with_env_filter(filter)
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();
}

// Use in your application
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    setup_logging();
    
    info!("Starting SCIM server");
    
    // Your application code...
    
    Ok(())
}</code></pre></pre>
<p><strong>Environment variables for logging:</strong></p>
<pre><code class="language-bash"># Enable debug logging
export RUST_LOG=scim_server=debug,sqlx=info

# Enable trace-level logging (very verbose)
export RUST_LOG=scim_server=trace

# Log only errors
export RUST_LOG=scim_server=error
</code></pre>
<h3 id="requestresponse-debugging"><a class="header" href="#requestresponse-debugging">Request/Response Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    body::Body,
    extract::Request,
    middleware::Next,
    response::Response,
};

async fn debug_middleware(
    request: Request,
    next: Next,
) -&gt; Response {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let headers = request.headers().clone();
    
    // Log request
    debug!("Incoming request: {} {}", method, uri);
    for (name, value) in headers.iter() {
        debug!("Request header: {}: {:?}", name, value);
    }
    
    let start = std::time::Instant::now();
    let response = next.run(request).await;
    let duration = start.elapsed();
    
    // Log response
    debug!(
        "Response: {} {} - {} in {:?}",
        method,
        uri,
        response.status(),
        duration
    );
    
    response
}

// Add to your router
let app = Router::new()
    .nest("/scim/v2", scim_routes())
    .layer(middleware::from_fn(debug_middleware));
<span class="boring">}</span></code></pre></pre>
<h3 id="database-query-debugging"><a class="header" href="#database-query-debugging">Database Query Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable SQL query logging for sqlx
use sqlx::postgres::PgPoolOptions;

let pool = PgPoolOptions::new()
    .max_connections(10)
    .connect(&amp;database_url)
    .await?;

// Queries will be logged when RUST_LOG includes sqlx=debug
<span class="boring">}</span></code></pre></pre>
<h3 id="provider-state-inspection"><a class="header" href="#provider-state-inspection">Provider State Inspection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For InMemoryProvider, add debugging methods
impl InMemoryProvider {
    pub async fn debug_state(&amp;self) {
        let users = self.users.read().await;
        let groups = self.groups.read().await;
        
        println!("=== Provider State Debug ===");
        for (tenant_id, tenant_users) in users.iter() {
            println!("Tenant '{}' has {} users:", tenant_id, tenant_users.len());
            for (user_id, user) in tenant_users.iter() {
                println!("  User: {} ({})", user.username(), user_id);
            }
        }
        
        for (tenant_id, tenant_groups) in groups.iter() {
            println!("Tenant '{}' has {} groups:", tenant_id, tenant_groups.len());
            for (group_id, group) in tenant_groups.iter() {
                println!("  Group: {} ({}) with {} members", 
                         group.display_name(), group_id, group.members().len());
            }
        }
        println!("=== End Debug ===");
    }
}

// Use in your code
provider.debug_state().await;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="slow-database-queries"><a class="header" href="#slow-database-queries">Slow Database Queries</a></h3>
<p><strong>Add query timing:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

async fn timed_query&lt;T, F, Fut&gt;(operation: F) -&gt; Result&lt;T, Error&gt;
where
    F: FnOnce() -&gt; Fut,
    Fut: Future&lt;Output = Result&lt;T, Error&gt;&gt;,
{
    let start = Instant::now();
    let result = operation().await;
    let duration = start.elapsed();
    
    if duration &gt; Duration::from_millis(100) {
        warn!("Slow query detected: {:?}", duration);
    }
    
    result
}

// Usage
let users = timed_query(|| provider.list_users(tenant_id, &amp;options)).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize filtering:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current approach: Load all users then filter in memory
// Note: Database-level filtering is not yet implemented
let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
let filtered: Vec&lt;_&gt; = all_users.resources.into_iter()
    .filter(|u| u.department() == Some("Engineering"))
    .collect();

// For large datasets, consider implementing pagination
let options = ListOptions::builder()
    .count(Some(50))  // Limit results
    .start_index(Some(1))
    .build();
let paginated_users = provider.list_users(tenant_id, &amp;options).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-issues"><a class="header" href="#memory-issues">Memory Issues</a></h3>
<p><strong>Monitor memory usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sysinfo::{System, SystemExt};

fn log_memory_usage() {
    let mut system = System::new_all();
    system.refresh_memory();
    
    let used = system.used_memory();
    let total = system.total_memory();
    let percentage = (used as f64 / total as f64) * 100.0;
    
    info!("Memory usage: {} MB / {} MB ({:.1}%)", 
          used / 1024 / 1024, 
          total / 1024 / 1024, 
          percentage);
}

// Check periodically
tokio::spawn(async {
    loop {
        log_memory_usage();
        tokio::time::sleep(Duration::from_secs(60)).await;
    }
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize large result sets:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use pagination for large datasets
let mut start_index = 1;
let page_size = 100;

loop {
    let options = ListOptions::builder()
        .start_index(start_index)
        .count(page_size)
        .build();
    
    let page = provider.list_users(tenant_id, &amp;options).await?;
    
    // Process page
    for user in page.resources {
        process_user(user).await?;
    }
    
    // Check if we're done
    if page.resources.len() &lt; page_size {
        break;
    }
    
    start_index += page_size;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="health-checks-and-monitoring"><a class="header" href="#health-checks-and-monitoring">Health Checks and Monitoring</a></h2>
<h3 id="implement-health-endpoints"><a class="header" href="#implement-health-endpoints">Implement Health Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::Json, http::StatusCode};
use serde_json::json;

async fn health_check(
    State(state): State&lt;AppState&gt;,
) -&gt; Result&lt;Json&lt;serde_json::Value&gt;, StatusCode&gt; {
    // Check provider health
    let provider_health = state.provider.health_check().await
        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;
    
    // Check database connectivity
    let db_status = match state.provider.get_user("health-check", "non-existent").await {
        Ok(None) | Err(ProviderError::NotFound { .. }) =&gt; "healthy",
        Err(_) =&gt; "unhealthy",
    };
    
    let response = json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "version": env!("CARGO_PKG_VERSION"),
        "components": {
            "provider": provider_health.status,
            "database": db_status
        }
    });
    
    Ok(Json(response))
}

// Add to router
let app = Router::new()
    .route("/health", get(health_check))
    .nest("/scim/v2", scim_routes());
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection-1"><a class="header" href="#metrics-collection-1">Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

#[derive(Clone)]
struct Metrics {
    requests_total: Arc&lt;AtomicU64&gt;,
    requests_errors: Arc&lt;AtomicU64&gt;,
    users_created: Arc&lt;AtomicU64&gt;,
    users_updated: Arc&lt;AtomicU64&gt;,
}

impl Metrics {
    fn new() -&gt; Self {
        Self {
            requests_total: Arc::new(AtomicU64::new(0)),
            requests_errors: Arc::new(AtomicU64::new(0)),
            users_created: Arc::new(AtomicU64::new(0)),
            users_updated: Arc::new(AtomicU64::new(0)),
        }
    }
    
    fn increment_requests(&amp;self) {
        self.requests_total.fetch_add(1, Ordering::Relaxed);
    }
    
    fn increment_errors(&amp;self) {
        self.requests_errors.fetch_add(1, Ordering::Relaxed);
    }
}

async fn metrics_endpoint(
    State(metrics): State&lt;Metrics&gt;,
) -&gt; Json&lt;serde_json::Value&gt; {
    Json(json!({
        "requests_total": metrics.requests_total.load(Ordering::Relaxed),
        "requests_errors": metrics.requests_errors.load(Ordering::Relaxed),
        "users_created": metrics.users_created.load(Ordering::Relaxed),
        "users_updated": metrics.users_updated.load(Ordering::Relaxed),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-and-validation"><a class="header" href="#testing-and-validation">Testing and Validation</a></h2>
<h3 id="unit-test-debugging"><a class="header" href="#unit-test-debugging">Unit Test Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn debug_user_creation() {
        // Enable logging in tests
        let _ = tracing_subscriber::fmt::try_init();
        
        let provider = InMemoryProvider::new();
        let tenant_id = "test-tenant";
        
        // Create test user
        let user = ScimUser::builder()
            .username("test@example.com")
            .given_name("Test")
            .family_name("User")
            .build()
            .unwrap();
        
        println!("Creating user: {:?}", user);
        
        let created = provider.create_user(tenant_id, user).await.unwrap();
        
        println!("Created user with ID: {}", created.id());
        
        // Verify creation
        let fetched = provider.get_user(tenant_id, created.id()).await.unwrap();
        assert!(fetched.is_some());
        
        println!("Test passed: user creation and retrieval");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-test-setup"><a class="header" href="#integration-test-setup">Integration Test Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create test helper functions
pub async fn setup_test_server() -&gt; (TestServer, String) {
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder()
        .provider(provider)
        .build();
    
    let app = create_app(scim_server);
    let server = TestServer::new(app).unwrap();
    let tenant_id = "test-tenant".to_string();
    
    (server, tenant_id)
}

pub fn create_test_user() -&gt; ScimUser {
    ScimUser::builder()
        .username("test@example.com")
        .given_name("Test")
        .family_name("User")
        .email("test@example.com")
        .active(true)
        .build()
        .unwrap()
}

#[tokio::test]
async fn integration_test_user_lifecycle() {
    let (server, tenant_id) = setup_test_server().await;
    let user = create_test_user();
    
    // Create user
    let response = server
        .post(&amp;format!("/scim/v2/{}/Users", tenant_id))
        .json(&amp;user)
        .await;
    
    assert_eq!(response.status_code(), 201);
    
    let created_user: ScimUser = response.json();
    println!("Created user: {}", created_user.id());
    
    // Get user
    let response = server
        .get(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    // Update user
    let mut updated_user = created_user.clone();
    updated_user.set_given_name("Updated");
    
    let response = server
        .put(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .json(&amp;updated_user)
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    // Delete user
    let response = server
        .delete(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .await;
    
    assert_eq!(response.status_code(), 204);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-help-3"><a class="header" href="#getting-help-3">Getting Help</a></h2>
<h3 id="collect-diagnostic-information"><a class="header" href="#collect-diagnostic-information">Collect Diagnostic Information</a></h3>
<p>When reporting issues, include:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Version information
println!("SCIM Server version: {}", env!("CARGO_PKG_VERSION"));
println!("Rust version: {}", env!("RUSTC_VERSION"));

// System information
use sysinfo::{System, SystemExt};
let mut system = System::new_all();
system.refresh_all();
println!("OS: {} {}", system.name().unwrap_or("Unknown"), system.os_version().unwrap_or("Unknown"));
println!("Total memory: {} MB", system.total_memory() / 1024 / 1024);

// Configuration
println!("Database URL: {}", env::var("DATABASE_URL").unwrap_or("Not set".to_string()));
println!("Log level: {}", env::var("RUST_LOG").unwrap_or("Not set".to_string()));
<span class="boring">}</span></code></pre></pre>
<h3 id="enable-maximum-logging"><a class="header" href="#enable-maximum-logging">Enable Maximum Logging</a></h3>
<pre><code class="language-bash"># Set maximum verbosity
export RUST_LOG=trace

# Run with backtrace
export RUST_BACKTRACE=full

# Run your application
cargo run
</code></pre>
<h3 id="create-minimal-reproduction"><a class="header" href="#create-minimal-reproduction">Create Minimal Reproduction</a></h3>
<pre><pre class="playground"><code class="language-rust">// Create the smallest possible example that reproduces the issue
use scim_server::{ScimServer, InMemoryProvider, ScimUser};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder().provider(provider).build();
    
    // Minimal reproduction of your issue
    let user = ScimUser::builder()
        .username("test@example.com")
        .build()?;
    
    let result = scim_server.create_user("tenant-1", user).await;
    println!("Result: {:?}", result);
    
    Ok(())
}</code></pre></pre>
<p>This troubleshooting guide should help you identify and resolve most common issues with the SCIM Server library. For additional help, check the <a href="https://github.com/your-repo/scim-server/issues">GitHub Issues</a> or create a new issue with your diagnostic information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="production-deployment"><a class="header" href="#production-deployment">Production Deployment</a></h1>
<p>This guide covers deploying SCIM Server in production environments, including infrastructure setup, security considerations, monitoring, and operational best practices.</p>
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p>Production deployment of SCIM Server requires careful consideration of:</p>
<ul>
<li><strong>High Availability</strong>: Multiple instances with load balancing</li>
<li><strong>Security</strong>: TLS, authentication, and network isolation</li>
<li><strong>Performance</strong>: Database optimization and caching</li>
<li><strong>Monitoring</strong>: Health checks, metrics, and alerting</li>
<li><strong>Scalability</strong>: Horizontal and vertical scaling strategies</li>
<li><strong>Data Protection</strong>: Backups, encryption, and compliance</li>
</ul>
<h2 id="infrastructure-architecture"><a class="header" href="#infrastructure-architecture">Infrastructure Architecture</a></h2>
<h3 id="recommended-production-architecture"><a class="header" href="#recommended-production-architecture">Recommended Production Architecture</a></h3>
<pre><code>                    Internet
                       |
                  [Load Balancer]
                   /     |     \
            [SCIM-1] [SCIM-2] [SCIM-3]
                   \     |     /
                  [Database Cluster]
                       |
                   [Redis Cache]
</code></pre>
<h3 id="container-deployment-with-docker"><a class="header" href="#container-deployment-with-docker">Container Deployment with Docker</a></h3>
<p><strong>Dockerfile:</strong></p>
<pre><code class="language-dockerfile">FROM rust:1.75 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

# Build optimized release binary
RUN cargo build --release

FROM debian:bookworm-slim

# Install runtime dependencies
RUN apt-get update &amp;&amp; apt-get install -y \
    ca-certificates \
    libssl3 \
    &amp;&amp; rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd -r -s /bin/false scim

WORKDIR /app
COPY --from=builder /app/target/release/scim-server .

# Set ownership and permissions
RUN chown scim:scim /app/scim-server
USER scim

EXPOSE 3000

HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:3000/health || exit 1

CMD ["./scim-server"]
</code></pre>
<p><strong>docker-compose.yml:</strong></p>
<pre><code class="language-yaml">version: '3.8'

services:
  scim-server:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_URL=postgresql://scim:${POSTGRES_PASSWORD}@postgres:5432/scim
      - REDIS_URL=redis://redis:6379
      - RUST_LOG=info
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.5'
          memory: 256M
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 3

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=scim
      - POSTGRES_USER=scim
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U scim"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - scim-server

volumes:
  postgres_data:
  redis_data:
</code></pre>
<h3 id="kubernetes-deployment"><a class="header" href="#kubernetes-deployment">Kubernetes Deployment</a></h3>
<p><strong>namespace.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Namespace
metadata:
  name: scim-server
</code></pre>
<p><strong>configmap.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: scim-config
  namespace: scim-server
data:
  RUST_LOG: "info"
  SERVER_HOST: "0.0.0.0"
  SERVER_PORT: "3000"
</code></pre>
<p><strong>secret.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Secret
metadata:
  name: scim-secrets
  namespace: scim-server
type: Opaque
data:
  DATABASE_URL: &lt;base64-encoded-database-url&gt;
  JWT_SECRET: &lt;base64-encoded-jwt-secret&gt;
  REDIS_URL: &lt;base64-encoded-redis-url&gt;
</code></pre>
<p><strong>deployment.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: scim-server
  namespace: scim-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: scim-server
  template:
    metadata:
      labels:
        app: scim-server
    spec:
      containers:
      - name: scim-server
        image: your-registry/scim-server:latest
        ports:
        - containerPort: 3000
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: scim-secrets
              key: DATABASE_URL
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: scim-secrets
              key: JWT_SECRET
        - name: REDIS_URL
          valueFrom:
            secretKeyRef:
              name: scim-secrets
              key: REDIS_URL
        envFrom:
        - configMapRef:
            name: scim-config
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
</code></pre>
<p><strong>service.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: scim-server-service
  namespace: scim-server
spec:
  selector:
    app: scim-server
  ports:
  - port: 80
    targetPort: 3000
  type: ClusterIP
</code></pre>
<p><strong>ingress.yaml:</strong></p>
<pre><code class="language-yaml">apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: scim-server-ingress
  namespace: scim-server
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - scim.yourdomain.com
    secretName: scim-tls-secret
  rules:
  - host: scim.yourdomain.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: scim-server-service
            port:
              number: 80
</code></pre>
<h2 id="database-configuration"><a class="header" href="#database-configuration">Database Configuration</a></h2>
<h3 id="postgresql-production-setup"><a class="header" href="#postgresql-production-setup">PostgreSQL Production Setup</a></h3>
<p><strong>Connection pooling configuration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::postgres::PgPoolOptions;
use std::time::Duration;

pub async fn create_db_pool(database_url: &amp;str) -&gt; Result&lt;sqlx::PgPool, sqlx::Error&gt; {
    PgPoolOptions::new()
        .max_connections(20)          // Maximum connections in pool
        .min_connections(5)           // Minimum connections to maintain
        .acquire_timeout(Duration::from_secs(30))
        .idle_timeout(Duration::from_secs(600))
        .max_lifetime(Duration::from_secs(1800))
        .test_before_acquire(true)    // Test connections before use
        .connect(database_url)
        .await
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Database migration script:</strong></p>
<pre><code class="language-sql">-- init.sql
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tenant_id VARCHAR(255) NOT NULL,
    username VARCHAR(255) NOT NULL,
    given_name VARCHAR(255),
    family_name VARCHAR(255),
    email VARCHAR(255),
    active BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version INTEGER NOT NULL DEFAULT 1,
    data JSONB NOT NULL,
    
    UNIQUE(tenant_id, username),
    UNIQUE(tenant_id, email)
);

-- Groups table
CREATE TABLE groups (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    tenant_id VARCHAR(255) NOT NULL,
    display_name VARCHAR(255) NOT NULL,
    description TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    version INTEGER NOT NULL DEFAULT 1,
    data JSONB NOT NULL,
    
    UNIQUE(tenant_id, display_name)
);

-- Group memberships
CREATE TABLE group_memberships (
    group_id UUID REFERENCES groups(id) ON DELETE CASCADE,
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    PRIMARY KEY(group_id, user_id)
);

-- Indexes for performance
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_users_username ON users(tenant_id, username);
CREATE INDEX idx_users_email ON users(tenant_id, email);
CREATE INDEX idx_users_active ON users(tenant_id, active);
CREATE INDEX idx_users_updated_at ON users(updated_at);

CREATE INDEX idx_groups_tenant_id ON groups(tenant_id);
CREATE INDEX idx_groups_display_name ON groups(tenant_id, display_name);

CREATE INDEX idx_group_memberships_user_id ON group_memberships(user_id);

-- JSONB indexes for advanced querying
CREATE INDEX idx_users_data_gin ON users USING GIN(data);
CREATE INDEX idx_groups_data_gin ON groups USING GIN(data);
</code></pre>
<h3 id="redis-configuration"><a class="header" href="#redis-configuration">Redis Configuration</a></h3>
<p><strong>Redis for caching and sessions:</strong></p>
<pre><code class="language-yaml"># redis.conf
bind 0.0.0.0
port 6379
timeout 300
tcp-keepalive 60

# Memory management
maxmemory 1gb
maxmemory-policy allkeys-lru

# Persistence
save 900 1
save 300 10
save 60 10000

# Security
requirepass your-redis-password
</code></pre>
<h2 id="security-configuration"><a class="header" href="#security-configuration">Security Configuration</a></h2>
<h3 id="tlsssl-setup"><a class="header" href="#tlsssl-setup">TLS/SSL Setup</a></h3>
<p><strong>nginx.conf:</strong></p>
<pre><code class="language-nginx">upstream scim_backend {
    least_conn;
    server scim-server-1:3000 weight=1 max_fails=3 fail_timeout=30s;
    server scim-server-2:3000 weight=1 max_fails=3 fail_timeout=30s;
    server scim-server-3:3000 weight=1 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name scim.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name scim.yourdomain.com;

    # SSL configuration
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff always;
    add_header X-Frame-Options DENY always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;
    limit_req zone=api burst=20 nodelay;

    location / {
        proxy_pass http://scim_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        
        # Timeouts
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }

    # Health check endpoint
    location /health {
        access_log off;
        proxy_pass http://scim_backend;
    }
}
</code></pre>
<h3 id="environment-configuration"><a class="header" href="#environment-configuration">Environment Configuration</a></h3>
<p><strong>Production environment variables:</strong></p>
<pre><code class="language-bash"># Server configuration
SERVER_HOST=0.0.0.0
SERVER_PORT=3000
RUST_LOG=info

# Database
DATABASE_URL=postgresql://scim:${POSTGRES_PASSWORD}@postgres-cluster:5432/scim?sslmode=require
DATABASE_MAX_CONNECTIONS=20
DATABASE_MIN_CONNECTIONS=5

# Redis
REDIS_URL=redis://:${REDIS_PASSWORD}@redis-cluster:6379
REDIS_MAX_CONNECTIONS=10

# Security
JWT_SECRET=${JWT_SECRET}
ENCRYPTION_KEY=${ENCRYPTION_KEY}
TLS_CERT_PATH=/etc/ssl/certs/scim.crt
TLS_KEY_PATH=/etc/ssl/private/scim.key

# Observability
METRICS_ENABLED=true
TRACING_ENABLED=true
JAEGER_ENDPOINT=http://jaeger:14268/api/traces

# Performance
CACHE_TTL=300
MAX_REQUEST_SIZE=1048576
WORKER_THREADS=4
</code></pre>
<h2 id="monitoring-and-observability-3"><a class="header" href="#monitoring-and-observability-3">Monitoring and Observability</a></h2>
<h3 id="health-checks-1"><a class="header" href="#health-checks-1">Health Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::Json, http::StatusCode};
use serde_json::json;

#[derive(Clone)]
pub struct HealthChecker {
    db_pool: sqlx::PgPool,
    redis_client: redis::Client,
}

impl HealthChecker {
    pub async fn check_all(&amp;self) -&gt; Result&lt;HealthStatus, HealthError&gt; {
        let mut checks = Vec::new();
        
        // Database health
        let db_health = self.check_database().await;
        checks.push(("database", db_health.is_ok()));
        
        // Redis health
        let redis_health = self.check_redis().await;
        checks.push(("redis", redis_health.is_ok()));
        
        // Memory usage
        let memory_health = self.check_memory().await;
        checks.push(("memory", memory_health.is_ok()));
        
        let all_healthy = checks.iter().all(|(_, healthy)| *healthy);
        
        Ok(HealthStatus {
            status: if all_healthy { "healthy" } else { "unhealthy" },
            checks,
            timestamp: chrono::Utc::now(),
        })
    }
    
    async fn check_database(&amp;self) -&gt; Result&lt;(), HealthError&gt; {
        sqlx::query("SELECT 1")
            .fetch_one(&amp;self.db_pool)
            .await
            .map_err(|e| HealthError::Database(e.to_string()))?;
        Ok(())
    }
    
    async fn check_redis(&amp;self) -&gt; Result&lt;(), HealthError&gt; {
        let mut conn = self.redis_client
            .get_async_connection()
            .await
            .map_err(|e| HealthError::Redis(e.to_string()))?;
            
        redis::cmd("PING")
            .query_async(&amp;mut conn)
            .await
            .map_err(|e| HealthError::Redis(e.to_string()))?;
        Ok(())
    }
    
    async fn check_memory(&amp;self) -&gt; Result&lt;(), HealthError&gt; {
        use sysinfo::{System, SystemExt};
        let mut system = System::new_all();
        system.refresh_memory();
        
        let used_percentage = (system.used_memory() as f64 / system.total_memory() as f64) * 100.0;
        
        if used_percentage &gt; 90.0 {
            return Err(HealthError::Memory(format!("Memory usage too high: {:.1}%", used_percentage)));
        }
        
        Ok(())
    }
}

pub async fn health_endpoint(
    State(health_checker): State&lt;HealthChecker&gt;,
) -&gt; Result&lt;Json&lt;serde_json::Value&gt;, StatusCode&gt; {
    match health_checker.check_all().await {
        Ok(status) =&gt; {
            let status_code = if status.status == "healthy" {
                StatusCode::OK
            } else {
                StatusCode::SERVICE_UNAVAILABLE
            };
            
            Ok(Json(json!(status)))
        },
        Err(_) =&gt; Err(StatusCode::INTERNAL_SERVER_ERROR),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection-2"><a class="header" href="#metrics-collection-2">Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use prometheus::{Counter, Histogram, Gauge, Registry, Encoder, TextEncoder};
use std::sync::Arc;

#[derive(Clone)]
pub struct Metrics {
    registry: Arc&lt;Registry&gt;,
    http_requests_total: Counter,
    http_request_duration: Histogram,
    active_connections: Gauge,
    users_total: Gauge,
    groups_total: Gauge,
}

impl Metrics {
    pub fn new() -&gt; Result&lt;Self, prometheus::Error&gt; {
        let registry = Arc::new(Registry::new());
        
        let http_requests_total = Counter::new(
            "http_requests_total",
            "Total number of HTTP requests"
        )?;
        
        let http_request_duration = Histogram::with_opts(
            prometheus::HistogramOpts::new(
                "http_request_duration_seconds",
                "HTTP request duration in seconds"
            ).buckets(vec![0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0])
        )?;
        
        let active_connections = Gauge::new(
            "active_connections",
            "Number of active connections"
        )?;
        
        let users_total = Gauge::new(
            "users_total",
            "Total number of users"
        )?;
        
        let groups_total = Gauge::new(
            "groups_total",
            "Total number of groups"
        )?;
        
        registry.register(Box::new(http_requests_total.clone()))?;
        registry.register(Box::new(http_request_duration.clone()))?;
        registry.register(Box::new(active_connections.clone()))?;
        registry.register(Box::new(users_total.clone()))?;
        registry.register(Box::new(groups_total.clone()))?;
        
        Ok(Self {
            registry,
            http_requests_total,
            http_request_duration,
            active_connections,
            users_total,
            groups_total,
        })
    }
    
    pub fn record_request(&amp;self, duration: f64) {
        self.http_requests_total.inc();
        self.http_request_duration.observe(duration);
    }
    
    pub async fn metrics_handler(&amp;self) -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; {
        let encoder = TextEncoder::new();
        let metric_families = self.registry.gather();
        let mut buffer = Vec::new();
        encoder.encode(&amp;metric_families, &amp;mut buffer)?;
        Ok(String::from_utf8(buffer)?)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="logging-configuration"><a class="header" href="#logging-configuration">Logging Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};
use tracing_appender::rolling::{RollingFileAppender, Rotation};

pub fn setup_logging() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let file_appender = RollingFileAppender::new(
        Rotation::daily(),
        "/var/log/scim-server",
        "app.log"
    );
    
    let (non_blocking, _guard) = tracing_appender::non_blocking(file_appender);
    
    tracing_subscriber::registry()
        .with(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "scim_server=info,sqlx=warn".into())
        )
        .with(tracing_subscriber::fmt::layer().with_writer(std::io::stdout))
        .with(tracing_subscriber::fmt::layer().with_writer(non_blocking))
        .init();
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h2>
<h3 id="application-level-optimizations"><a class="header" href="#application-level-optimizations">Application-Level Optimizations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Connection pool configuration
let db_pool = PgPoolOptions::new()
    .max_connections(20)
    .min_connections(5)
    .acquire_timeout(Duration::from_secs(30))
    .connect(&amp;database_url)
    .await?;

// Redis connection pool
let redis_pool = deadpool_redis::Config::from_url(&amp;redis_url)
    .create_pool(Some(deadpool_redis::Runtime::Tokio1))?;

// Implement caching layer
#[derive(Clone)]
pub struct CachedProvider {
    inner: DatabaseProvider,
    cache: deadpool_redis::Pool,
    cache_ttl: Duration,
}

impl CachedProvider {
    async fn get_user_cached(&amp;self, tenant_id: &amp;str, user_id: &amp;str) -&gt; Result&lt;Option&lt;ScimUser&gt;, ProviderError&gt; {
        let cache_key = format!("user:{}:{}", tenant_id, user_id);
        
        // Try cache first
        if let Ok(mut conn) = self.cache.get().await {
            if let Ok(cached) = redis::cmd("GET").arg(&amp;cache_key).query_async::&lt;_, String&gt;(&amp;mut conn).await {
                if let Ok(user) = serde_json::from_str::&lt;ScimUser&gt;(&amp;cached) {
                    return Ok(Some(user));
                }
            }
        }
        
        // Fallback to database
        let user = self.inner.get_user(tenant_id, user_id).await?;
        
        // Cache the result
        if let (Some(ref user), Ok(mut conn)) = (&amp;user, self.cache.get().await) {
            if let Ok(serialized) = serde_json::to_string(user) {
                let _: Result&lt;(), _&gt; = redis::cmd("SETEX")
                    .arg(&amp;cache_key)
                    .arg(self.cache_ttl.as_secs())
                    .arg(serialized)
                    .query_async(&amp;mut conn)
                    .await;
            }
        }
        
        Ok(user)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-optimization-1"><a class="header" href="#database-optimization-1">Database Optimization</a></h3>
<pre><code class="language-sql">-- Analyze query performance
EXPLAIN ANALYZE SELECT * FROM users WHERE tenant_id = 'tenant-1' AND active = true;

-- Create partial indexes for common queries
CREATE INDEX CONCURRENTLY idx_users_active_by_tenant 
ON users(tenant_id, username) 
WHERE active = true;

-- Optimize JSONB queries
CREATE INDEX CONCURRENTLY idx_users_department 
ON users USING GIN ((data-&gt;'department'));

-- Partition large tables by tenant
CREATE TABLE users_partitioned (
    LIKE users INCLUDING ALL
) PARTITION BY HASH (tenant_id);

CREATE TABLE users_part_0 PARTITION OF users_partitioned
FOR VALUES WITH (modulus 4, remainder 0);

CREATE TABLE users_part_1 PARTITION OF users_partitioned
FOR VALUES WITH (modulus 4, remainder 1);

-- Regular maintenance
CREATE OR REPLACE FUNCTION maintain_database()
RETURNS void AS $$
BEGIN
    -- Update statistics
    ANALYZE;
    
    -- Rebuild indexes if needed
    REINDEX INDEX CONCURRENTLY idx_users_tenant_id;
    
    -- Clean up old data
    DELETE FROM audit_logs WHERE created_at &lt; NOW() - INTERVAL '90 days';
END;
$$ LANGUAGE plpgsql;

-- Schedule maintenance
SELECT cron.schedule('database-maintenance', '0 2 * * 0', 'SELECT maintain_database();');
</code></pre>
<h2 id="backup-and-disaster-recovery"><a class="header" href="#backup-and-disaster-recovery">Backup and Disaster Recovery</a></h2>
<h3 id="database-backup-strategy"><a class="header" href="#database-backup-strategy">Database Backup Strategy</a></h3>
<pre><code class="language-bash">#!/bin/bash
# backup.sh

set -e

BACKUP_DIR="/backups"
DB_NAME="scim"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/scim_backup_${TIMESTAMP}.sql"

# Create backup directory
mkdir -p $BACKUP_DIR

# Perform backup
pg_dump \
    --host=$DB_HOST \
    --port=$DB_PORT \
    --username=$DB_USER \
    --dbname=$DB_NAME \
    --format=custom \
    --compress=9 \
    --file=$BACKUP_FILE

# Encrypt backup
gpg --symmetric --cipher-algo AES256 --output $BACKUP_FILE.gpg $BACKUP_FILE
rm $BACKUP_FILE

# Upload to S3
aws s3 cp $BACKUP_FILE.gpg s3://scim-backups/daily/

# Clean up old local backups (keep 7 days)
find $BACKUP_DIR -name "scim_backup_*.sql.gpg" -mtime +7 -delete

# Clean up old S3 backups (keep 30 days)
aws s3 ls s3://scim-backups/daily/ | grep "scim_backup_" | head -n -30 | awk '{print $4}' | xargs -I {} aws s3 rm s3://scim-backups/daily/{}
</code></pre>
<h3 id="automated-restore-testing"><a class="header" href="#automated-restore-testing">Automated Restore Testing</a></h3>
<pre><code class="language-bash">#!/bin/bash
# test-restore.sh

BACKUP_FILE=$1
TEST_DB="scim_restore_test"

# Create test database
createdb $TEST_DB

# Restore backup
pg_restore \
    --host=$DB_HOST \
    --port=$DB_PORT \
    --username=$DB_USER \
    --dbname=$TEST_DB \
    --clean \
    --if-exists \
    $BACKUP_FILE

# Run validation queries
psql -d $TEST_DB -c "SELECT COUNT(*) FROM users;"
psql -d $TEST_DB -c "SELECT COUNT(*) FROM groups;"

# Clean up
dropdb $TEST_DB

echo "Restore test completed successfully"
</code></pre>
<h2 id="deployment-pipeline"><a class="header" href="#deployment-pipeline">Deployment Pipeline</a></h2>
<h3 id="cicd-with-github-actions"><a class="header" href="#cicd-with-github-actions">CI/CD with GitHub Actions</a></h3>
<p><strong>.github/workflows/deploy.yml:</strong></p>
<pre><code class="language-yaml">name: Deploy to Production

on:
  push:
    branches: [main]
    tags: ['v*']

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: &gt;-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
    - uses: actions/checkout@v4
    - uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    - uses: actions-rs/cargo@v1
      with:
        command: test

  build-and-push:
    needs: test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Log in to Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        
    - name: Build and push
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - name: Deploy to Kubernetes
      uses: azure/k8s-deploy@v1
      with:
        manifests: |
          k8s/deployment.yaml
          k8s/service.yaml
          k8s/ingress.yaml
        images: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:main
        kubectl-version: 'latest'
</code></pre>
<h2 id="security-best-practices"><a class="header" href="#security-best-practices">Security Best Practices</a></h2>
<h3 id="runtime-security"><a class="header" href="#runtime-security">Runtime Security</a></h3>
<pre><code class="language-yaml"># Pod Security Policy
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: scim-server-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
</code></pre>
<h3 id="network-security"><a class="header" href="#network-security">Network Security</a></h3>
<pre><code class="language-yaml"># Network Policy
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: scim-server-netpol
  namespace: scim-server
spec:
  podSelector:
    matchLabels:
      app: scim-server
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 3000
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
  - to:
    - namespaceSelector:
        matchLabels:
          name: redis
    ports:
    - protocol: TCP
      port: 6379
</code></pre>
<p>This comprehensive production deployment guide covers all aspects of running SCIM Server at scale with enterprise-grade reliability, security, and observability.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-considerations-1"><a class="header" href="#security-considerations-1">Security Considerations</a></h1>
<p>This guide provides comprehensive security guidance for deploying and operating SCIM servers in production environments. Security is paramount in identity management systems, and this document covers threats, mitigations, and best practices.</p>
<h2 id="security-overview"><a class="header" href="#security-overview">Security Overview</a></h2>
<p>SCIM servers handle sensitive identity data and must be secured against various attack vectors. This document addresses:</p>
<ul>
<li><strong>Authentication and Authorization</strong></li>
<li><strong>Data Protection</strong></li>
<li><strong>Network Security</strong></li>
<li><strong>Input Validation</strong></li>
<li><strong>Audit and Monitoring</strong></li>
<li><strong>Deployment Security</strong></li>
<li><strong>Compliance Considerations</strong></li>
</ul>
<h2 id="authentication-security"><a class="header" href="#authentication-security">Authentication Security</a></h2>
<h3 id="token-based-authentication"><a class="header" href="#token-based-authentication">Token-Based Authentication</a></h3>
<h4 id="jwt-token-validation-1"><a class="header" href="#jwt-token-validation-1">JWT Token Validation</a></h4>
<p><strong>Best Practices</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{AuthConfig, JwtConfig};

let jwt_config = JwtConfig::builder()
    .issuer("https://trusted-auth-provider.com")
    .audience("scim-api")
    .public_key_url("https://trusted-auth-provider.com/.well-known/jwks.json")
    .algorithm("RS256") // Use asymmetric algorithms
    .clock_skew_seconds(60) // Allow for clock drift
    .cache_public_keys(true)
    .key_refresh_interval_seconds(3600) // Refresh keys hourly
    .validate_not_before(true)
    .validate_expiration(true)
    .build()?;

let auth_config = AuthConfig::builder()
    .jwt_config(jwt_config)
    .require_scope("scim:write") // Require specific scopes
    .build()?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Security Measures</strong>:</p>
<ul>
<li>Always validate JWT signatures using public keys</li>
<li>Verify issuer, audience, and expiration claims</li>
<li>Use short-lived tokens (15-60 minutes)</li>
<li>Implement token refresh mechanisms</li>
<li>Cache public keys with regular rotation</li>
</ul>
<h4 id="bearer-token-security"><a class="header" href="#bearer-token-security">Bearer Token Security</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{BearerTokenValidator, TokenValidationError};

#[async_trait]
impl BearerTokenValidator for CustomTokenValidator {
    async fn validate_token(&amp;self, token: &amp;str) -&gt; Result&lt;AuthContext, TokenValidationError&gt; {
        // Implement secure token validation
        let validation_result = self.introspect_token(token).await?;
        
        if !validation_result.active {
            return Err(TokenValidationError::TokenInactive);
        }
        
        if validation_result.expires_at &lt; Utc::now() {
            return Err(TokenValidationError::TokenExpired);
        }
        
        // Validate required scopes
        if !validation_result.scopes.contains(&amp;"scim:read".to_string()) {
            return Err(TokenValidationError::InsufficientScope);
        }
        
        Ok(AuthContext {
            user_id: validation_result.user_id,
            tenant_id: validation_result.tenant_id,
            scopes: validation_result.scopes,
            roles: validation_result.roles,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="oauth-20-integration"><a class="header" href="#oauth-20-integration">OAuth 2.0 Integration</a></h3>
<h4 id="scope-based-authorization"><a class="header" href="#scope-based-authorization">Scope-Based Authorization</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{AuthMiddleware, RequiredScope};

// Define fine-grained scopes
const SCIM_READ: &amp;str = "scim:read";
const SCIM_WRITE: &amp;str = "scim:write";
const SCIM_DELETE: &amp;str = "scim:delete";
const SCIM_ADMIN: &amp;str = "scim:admin";

// Apply scope requirements to endpoints
app.route("/Users", get(list_users).with(RequiredScope::new(SCIM_READ)))
   .route("/Users", post(create_user).with(RequiredScope::new(SCIM_WRITE)))
   .route("/Users/:id", delete(delete_user).with(RequiredScope::new(SCIM_DELETE)));
<span class="boring">}</span></code></pre></pre>
<h4 id="token-introspection"><a class="header" href="#token-introspection">Token Introspection</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use oauth2::introspection::{IntrospectionRequest, IntrospectionResponse};

async fn introspect_token(token: &amp;str) -&gt; Result&lt;IntrospectionResponse, AuthError&gt; {
    let client = reqwest::Client::new();
    let response = client
        .post("https://auth-server.com/oauth2/introspect")
        .form(&amp;[
            ("token", token),
            ("token_type_hint", "access_token"),
        ])
        .basic_auth(&amp;client_id, Some(&amp;client_secret))
        .timeout(Duration::from_secs(5)) // Short timeout
        .send()
        .await?;
    
    let introspection: IntrospectionResponse = response.json().await?;
    Ok(introspection)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="authorization-security"><a class="header" href="#authorization-security">Authorization Security</a></h2>
<h3 id="role-based-access-control-rbac"><a class="header" href="#role-based-access-control-rbac">Role-Based Access Control (RBAC)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{Role, Permission, AuthContext};

#[derive(Debug, Clone)]
pub enum Permission {
    ReadUsers,
    WriteUsers,
    DeleteUsers,
    ReadGroups,
    WriteGroups,
    DeleteGroups,
    ManageTenants,
    ViewAuditLogs,
}

#[derive(Debug, Clone)]
pub struct Role {
    pub name: String,
    pub permissions: Vec&lt;Permission&gt;,
    pub tenant_scope: Option&lt;String&gt;, // None for global roles
}

// Define roles
let user_reader = Role {
    name: "user_reader".to_string(),
    permissions: vec![Permission::ReadUsers],
    tenant_scope: Some("tenant_123".to_string()),
};

let admin = Role {
    name: "admin".to_string(),
    permissions: vec![
        Permission::ReadUsers,
        Permission::WriteUsers,
        Permission::DeleteUsers,
        Permission::ReadGroups,
        Permission::WriteGroups,
        Permission::DeleteGroups,
    ],
    tenant_scope: None, // Global admin
};

// Authorization middleware
async fn authorize_request(
    auth_context: &amp;AuthContext,
    required_permission: Permission,
    resource_tenant: Option&lt;&amp;str&gt;,
) -&gt; Result&lt;(), AuthError&gt; {
    for role in &amp;auth_context.roles {
        if role.permissions.contains(&amp;required_permission) {
            // Check tenant scope
            match (&amp;role.tenant_scope, resource_tenant) {
                (None, _) =&gt; return Ok(()), // Global role
                (Some(role_tenant), Some(resource_tenant)) if role_tenant == resource_tenant =&gt; {
                    return Ok(());
                }
                _ =&gt; continue,
            }
        }
    }
    Err(AuthError::InsufficientPermissions)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="attribute-level-security"><a class="header" href="#attribute-level-security">Attribute-Level Security</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::security::{AttributeFilter, SecurityContext};

#[derive(Debug)]
pub struct AttributeFilter {
    readable_attributes: HashSet&lt;String&gt;,
    writable_attributes: HashSet&lt;String&gt;,
    tenant_id: Option&lt;String&gt;,
    user_roles: Vec&lt;String&gt;,
}

impl AttributeFilter {
    pub fn filter_response(&amp;self, mut user: User) -&gt; User {
        // Remove sensitive attributes based on permissions
        if !self.user_roles.contains(&amp;"admin".to_string()) {
            user.password = None;
            user.security_question = None;
        }
        
        // Remove PII for limited roles
        if !self.user_roles.contains(&amp;"pii_reader".to_string()) {
            user.social_security_number = None;
            user.date_of_birth = None;
        }
        
        user
    }
    
    pub fn validate_write_permissions(&amp;self, patch_ops: &amp;[PatchOp]) -&gt; Result&lt;(), AuthError&gt; {
        for op in patch_ops {
            let attribute = extract_attribute_from_path(&amp;op.path);
            if !self.writable_attributes.contains(attribute) {
                return Err(AuthError::AttributeNotWritable(attribute.to_string()));
            }
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="data-protection-1"><a class="header" href="#data-protection-1">Data Protection</a></h2>
<h3 id="encryption-at-rest"><a class="header" href="#encryption-at-rest">Encryption at Rest</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::encryption::{EncryptionProvider, AesGcmProvider};

// Configure encryption for sensitive fields
let encryption_config = EncryptionConfig::builder()
    .provider(AesGcmProvider::new(&amp;encryption_key)?)
    .encrypt_fields(vec![
        "password",
        "socialSecurityNumber",
        "bankAccountNumber",
        "personalEmail",
    ])
    .encryption_algorithm("AES-256-GCM")
    .key_rotation_days(90)
    .build()?;

// Automatic encryption/decryption
#[derive(Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub user_name: String,
    
    #[serde(with = "encrypted_field")]
    pub password: Option&lt;String&gt;,
    
    #[serde(with = "encrypted_field")]
    pub social_security_number: Option&lt;String&gt;,
    
    pub meta: Meta,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="encryption-in-transit"><a class="header" href="#encryption-in-transit">Encryption in Transit</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::tls::{TlsConfig, TlsVersion, CipherSuite};

let tls_config = TlsConfig::builder()
    .certificate_file("/etc/ssl/certs/server.crt")
    .private_key_file("/etc/ssl/private/server.key")
    .ca_certificate_file("/etc/ssl/certs/ca.crt")
    .min_tls_version(TlsVersion::V1_2)
    .max_tls_version(TlsVersion::V1_3)
    .require_client_cert(false)
    .cipher_suites(vec![
        CipherSuite::TLS_AES_256_GCM_SHA384,
        CipherSuite::TLS_CHACHA20_POLY1305_SHA256,
        CipherSuite::TLS_AES_128_GCM_SHA256,
    ])
    .verify_hostname(true)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="data-masking-and-redaction"><a class="header" href="#data-masking-and-redaction">Data Masking and Redaction</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::privacy::{DataMasker, MaskingRule};

#[derive(Debug)]
pub struct DataMasker {
    rules: Vec&lt;MaskingRule&gt;,
}

impl DataMasker {
    pub fn mask_user_for_logging(&amp;self, user: &amp;User) -&gt; User {
        let mut masked_user = user.clone();
        
        // Mask email
        if let Some(email) = &amp;masked_user.user_name {
            masked_user.user_name = Some(self.mask_email(email));
        }
        
        // Remove sensitive fields entirely
        masked_user.password = None;
        masked_user.social_security_number = None;
        
        // Mask phone numbers
        for phone in &amp;mut masked_user.phone_numbers {
            phone.value = self.mask_phone(&amp;phone.value);
        }
        
        masked_user
    }
    
    fn mask_email(&amp;self, email: &amp;str) -&gt; String {
        if let Some(at_pos) = email.find('@') {
            let (local, domain) = email.split_at(at_pos);
            if local.len() &gt; 2 {
                format!("{}***@{}", &amp;local[..2], &amp;domain[1..])
            } else {
                format!("***@{}", &amp;domain[1..])
            }
        } else {
            "***".to_string()
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="input-validation-security"><a class="header" href="#input-validation-security">Input Validation Security</a></h2>
<h3 id="schema-validation-1"><a class="header" href="#schema-validation-1">Schema Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{SchemaValidator, ValidationError};

#[derive(Debug)]
pub struct SecureValidator {
    max_string_length: usize,
    max_array_size: usize,
    allowed_schemas: HashSet&lt;String&gt;,
    dangerous_patterns: Vec&lt;Regex&gt;,
}

impl SecureValidator {
    pub fn validate_user_input(&amp;self, user: &amp;User) -&gt; Result&lt;(), ValidationError&gt; {
        // Check schema allowlist
        for schema in &amp;user.schemas {
            if !self.allowed_schemas.contains(schema) {
                return Err(ValidationError::UnknownSchema(schema.clone()));
            }
        }
        
        // Validate string lengths
        if let Some(username) = &amp;user.user_name {
            if username.len() &gt; self.max_string_length {
                return Err(ValidationError::StringTooLong("userName".to_string()));
            }
            self.check_dangerous_patterns(username, "userName")?;
        }
        
        // Validate array sizes
        if user.emails.len() &gt; self.max_array_size {
            return Err(ValidationError::ArrayTooLarge("emails".to_string()));
        }
        
        // Validate email formats
        for email in &amp;user.emails {
            self.validate_email(&amp;email.value)?;
        }
        
        Ok(())
    }
    
    fn check_dangerous_patterns(&amp;self, input: &amp;str, field: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        for pattern in &amp;self.dangerous_patterns {
            if pattern.is_match(input) {
                warn!("Dangerous pattern detected in field {}: {}", field, input);
                return Err(ValidationError::DangerousInput(field.to_string()));
            }
        }
        Ok(())
    }
    
    fn validate_email(&amp;self, email: &amp;str) -&gt; Result&lt;(), ValidationError&gt; {
        // Strict email validation
        let email_regex = Regex::new(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").unwrap();
        if !email_regex.is_match(email) {
            return Err(ValidationError::InvalidEmail(email.to_string()));
        }
        
        // Check for suspicious patterns
        if email.contains("..") || email.starts_with('.') || email.ends_with('.') {
            return Err(ValidationError::SuspiciousEmail(email.to_string()));
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="sql-injection-prevention"><a class="header" href="#sql-injection-prevention">SQL Injection Prevention</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{QueryBuilder, Parameter};

// Always use parameterized queries for safe filtering
pub async fn find_users_by_criteria(
    &amp;self,
    tenant_id: &amp;str,
    department: Option&lt;&amp;str&gt;,
    active: Option&lt;bool&gt;,
) -&gt; Result&lt;Vec&lt;User&gt;, StorageError&gt; {
    let mut query_builder = QueryBuilder::new();
    let mut params = Vec::new();
    
    // Build parameterized query
    query_builder.add("SELECT * FROM users WHERE tenant_id = ?");
    params.push(Parameter::String(tenant_id.to_string()));
    
    // Add safe criteria parameters
    if let Some(dept) = department {
        query_builder.add(" AND department = ?");
        params.push(Parameter::String(dept.to_string()));
    }
    
    if let Some(is_active) = active {
        query_builder.add(" AND active = ?");
        params.push(Parameter::Bool(is_active));
    }
    
    let query = query_builder.build();
    self.execute_query(&amp;query, &amp;params).await
}

// Safe query building with attribute validation
fn build_search_query(&amp;self, criteria: &amp;SearchCriteria) -&gt; Result&lt;(String, Vec&lt;Parameter&gt;), FilterError&gt; {
    let mut query = String::from("SELECT * FROM users WHERE tenant_id = ?");
    let mut params = vec![Parameter::String(criteria.tenant_id.clone())];
    
    // Validate and add safe search criteria
    if let Some(username) = &amp;criteria.username {
        if self.is_valid_attribute("userName") {
            query.push_str(" AND username = ?");
            params.push(Parameter::String(username.clone()));
        } else {
            return Err(FilterError::InvalidAttribute("userName"));
        }
    }
    
    if let Some(email) = &amp;criteria.email {
        if self.is_valid_attribute("emails.value") {
            query.push_str(" AND email = ?");
            params.push(Parameter::String(email.clone()));
        } else {
            return Err(FilterError::InvalidAttribute("emails.value"));
        }
    }
    
    Ok((query, params))
}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="json-injection-prevention"><a class="header" href="#json-injection-prevention">JSON Injection Prevention</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::json::{SafeJsonParser, JsonValidationError};

pub struct SafeJsonParser {
    max_depth: usize,
    max_object_size: usize,
    max_string_length: usize,
    forbidden_keys: HashSet&lt;String&gt;,
}

impl SafeJsonParser {
    pub fn parse_user(&amp;self, json: &amp;str) -&gt; Result&lt;User, JsonValidationError&gt; {
        // Parse with size limits
        let value: serde_json::Value = serde_json::from_str(json)
            .map_err(|e| JsonValidationError::ParseError(e.to_string()))?;
        
        // Validate structure
        self.validate_json_structure(&amp;value, 0)?;
        
        // Convert to User struct with validation
        let user: User = serde_json::from_value(value)
            .map_err(|e| JsonValidationError::DeserializationError(e.to_string()))?;
        
        Ok(user)
    }
    
    fn validate_json_structure(&amp;self, value: &amp;serde_json::Value, depth: usize) -&gt; Result&lt;(), JsonValidationError&gt; {
        if depth &gt; self.max_depth {
            return Err(JsonValidationError::TooDeep);
        }
        
        match value {
            serde_json::Value::Object(obj) =&gt; {
                if obj.len() &gt; self.max_object_size {
                    return Err(JsonValidationError::ObjectTooLarge);
                }
                
                for (key, val) in obj {
                    if self.forbidden_keys.contains(key) {
                        return Err(JsonValidationError::ForbiddenKey(key.clone()));
                    }
                    self.validate_json_structure(val, depth + 1)?;
                }
            }
            serde_json::Value::Array(arr) =&gt; {
                for item in arr {
                    self.validate_json_structure(item, depth + 1)?;
                }
            }
            serde_json::Value::String(s) =&gt; {
                if s.len() &gt; self.max_string_length {
                    return Err(JsonValidationError::StringTooLong);
                }
            }
            _ =&gt; {}
        }
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="network-security-1"><a class="header" href="#network-security-1">Network Security</a></h2>
<h3 id="rate-limiting-1"><a class="header" href="#rate-limiting-1">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::rate_limit::{RateLimiter, RateLimitConfig, RateLimitError};

#[derive(Debug)]
pub struct SecurityRateLimiter {
    global_limiter: RateLimiter,
    tenant_limiters: DashMap&lt;String, RateLimiter&gt;,
    ip_limiters: DashMap&lt;IpAddr, RateLimiter&gt;,
}

impl SecurityRateLimiter {
    pub async fn check_rate_limits(
        &amp;self,
        ip: IpAddr,
        tenant_id: Option&lt;&amp;str&gt;,
        endpoint: &amp;str,
    ) -&gt; Result&lt;(), RateLimitError&gt; {
        // Check global rate limit (most permissive)
        self.global_limiter.check_rate_limit("global", 10000, 3600).await?;
        
        // Check IP-based rate limit (stricter)
        let ip_key = ip.to_string();
        if let Some(ip_limiter) = self.ip_limiters.get(&amp;ip) {
            ip_limiter.check_rate_limit(&amp;ip_key, 1000, 3600).await?;
        }
        
        // Check tenant-specific rate limit
        if let Some(tenant_id) = tenant_id {
            if let Some(tenant_limiter) = self.tenant_limiters.get(tenant_id) {
                tenant_limiter.check_rate_limit(tenant_id, 5000, 3600).await?;
            }
        }
        
        // Check endpoint-specific limits
        match endpoint {
            "/Users" =&gt; self.check_user_endpoint_limits(ip, tenant_id).await?,
            "/Bulk" =&gt; self.check_bulk_endpoint_limits(ip, tenant_id).await?,
            _ =&gt; {}
        }
        
        Ok(())
    }
    
    async fn check_bulk_endpoint_limits(
        &amp;self,
        ip: IpAddr,
        tenant_id: Option&lt;&amp;str&gt;,
    ) -&gt; Result&lt;(), RateLimitError&gt; {
        // Bulk operations are more expensive, so stricter limits
        let bulk_limiter = self.ip_limiters.entry(ip).or_insert_with(|| {
            RateLimiter::new(RateLimitConfig::new(10, 3600)) // 10 per hour
        });
        
        bulk_limiter.check_rate_limit(&amp;format!("bulk:{}", ip), 10, 3600).await
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="cors-security"><a class="header" href="#cors-security">CORS Security</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::cors::{CorsConfig, CorsMiddleware};

let cors_config = CorsConfig::builder()
    .allowed_origins(vec![
        "https://app.company.com".to_string(),
        "https://admin.company.com".to_string(),
    ]) // Never use "*" in production
    .allowed_methods(vec!["GET", "POST", "PUT", "PATCH", "DELETE"])
    .allowed_headers(vec![
        "Authorization",
        "Content-Type",
        "X-Tenant-ID",
        "If-Match",
        "If-None-Match",
    ])
    .expose_headers(vec!["ETag", "Location"])
    .allow_credentials(true)
    .max_age(3600)
    .vary_header(true) // Important for caching security
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="ip-allowlisting"><a class="header" href="#ip-allowlisting">IP Allowlisting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::network::{IpFilter, IpFilterConfig};

let ip_filter_config = IpFilterConfig::builder()
    .allowed_cidrs(vec![
        "10.0.0.0/8".parse()?,      // Internal network
        "172.16.0.0/12".parse()?,   // Private network
        "203.0.113.0/24".parse()?,  // Specific public range
    ])
    .blocked_cidrs(vec![
        "192.168.1.100/32".parse()?, // Known malicious IP
    ])
    .enable_geoblocking(true)
    .allowed_countries(vec!["US", "CA", "GB"])
    .build()?;

// Apply IP filtering middleware
async fn ip_filter_middleware(
    ConnectInfo(addr): ConnectInfo&lt;SocketAddr&gt;,
    req: Request&lt;Body&gt;,
    next: Next&lt;Body&gt;,
) -&gt; Result&lt;Response&lt;Body&gt;, StatusCode&gt; {
    let ip = addr.ip();
    
    if !ip_filter_config.is_allowed(ip).await? {
        warn!("Blocked request from IP: {}", ip);
        return Err(StatusCode::FORBIDDEN);
    }
    
    Ok(next.run(req).await)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="audit-and-monitoring"><a class="header" href="#audit-and-monitoring">Audit and Monitoring</a></h2>
<h3 id="comprehensive-audit-logging"><a class="header" href="#comprehensive-audit-logging">Comprehensive Audit Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::audit::{AuditLogger, AuditEvent, AuditLevel};

#[derive(Debug, Serialize)]
pub struct AuditEvent {
    pub timestamp: DateTime&lt;Utc&gt;,
    pub event_type: String,
    pub actor: ActorInfo,
    pub resource: ResourceInfo,
    pub tenant_id: Option&lt;String&gt;,
    pub ip_address: IpAddr,
    pub user_agent: Option&lt;String&gt;,
    pub result: OperationResult,
    pub details: serde_json::Value,
}

impl AuditLogger {
    pub async fn log_user_access(&amp;self, event: UserAccessEvent) {
        let audit_event = AuditEvent {
            timestamp: Utc::now(),
            event_type: "user_access".to_string(),
            actor: ActorInfo {
                user_id: event.actor_id,
                auth_method: event.auth_method,
                scopes: event.scopes,
            },
            resource: ResourceInfo {
                resource_type: "User".to_string(),
                resource_id: event.user_id.clone(),
                operation: event.operation,
            },
            tenant_id: event.tenant_id,
            ip_address: event.ip_address,
            user_agent: event.user_agent,
            result: event.result,
            details: json!({
                "user_id": event.user_id,
                "fields_accessed": event.fields_accessed,
                "response_size": event.response_size,
            }),
        };
        
        // Log to multiple destinations
        self.log_to_file(&amp;audit_event).await;
        self.log_to_siem(&amp;audit_event).await;
        self.log_to_database(&amp;audit_event).await;
        
        // Trigger alerts for sensitive operations
        if event.operation == "delete" || event.fields_accessed.contains(&amp;"password".to_string()) {
            self.trigger_security_alert(&amp;audit_event).await;
        }
    }
    
    pub async fn log_authentication_event(&amp;self, event: AuthEvent) {
        let audit_event = AuditEvent {
            timestamp: Utc::now(),
            event_type: match event.result {
                AuthResult::Success =&gt; "auth_success".to_string(),
                AuthResult::Failure =&gt; "auth_failure".to_string(),
            },
            actor: ActorInfo {
                user_id: event.user_id.clone(),
                auth_method: event.auth_method,
                scopes: vec![],
            },
            resource: ResourceInfo {
                resource_type: "Authentication".to_string(),
                resource_id: "system".to_string(),
                operation: "authenticate".to_string(),
            },
            tenant_id: event.tenant_id,
            ip_address: event.ip_address,
            user_agent: event.user_agent,
            result: match event.result {
                AuthResult::Success =&gt; OperationResult::Success,
                AuthResult::Failure =&gt; OperationResult::Failure,
            },
            details: json!({
                "auth_method": event.auth_method,
                "failure_reason": event.failure_reason,
                "token_claims": event.token_claims,
            }),
        };
        
        self.log_to_security_log(&amp;audit_event).await;
        
        // Detect brute force attacks
        if matches!(event.result, AuthResult::Failure) {
            self.check_for_brute_force(event.ip_address, event.user_id).await;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="security-monitoring"><a class="header" href="#security-monitoring">Security Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::monitoring::{SecurityMonitor, ThreatDetector};

pub struct SecurityMonitor {
    threat_detector: ThreatDetector,
    alert_manager: AlertManager,
    metrics_collector: MetricsCollector,
}

impl SecurityMonitor {
    pub async fn analyze_request_patterns(&amp;self) {
        // Detect unusual access patterns
        let patterns = self.threat_detector.analyze_recent_requests().await;
        
        for pattern in patterns {
            match pattern.threat_level {
                ThreatLevel::High =&gt; {
                    self.alert_manager.send_immediate_alert(pattern).await;
                    self.auto_block_suspicious_ips(pattern.source_ips).await;
                }
                ThreatLevel::Medium =&gt; {
                    self.alert_manager.send_alert(pattern).await;
                    self.increase_monitoring(pattern.source_ips).await;
                }
                ThreatLevel::Low =&gt; {
                    self.log_suspicious_activity(pattern).await;
                }
            }
        }
    }
    
    pub async fn detect_data_exfiltration(&amp;self) {
        // Monitor for unusual data access patterns
        let access_patterns = self.metrics_collector
            .get_recent_access_patterns(Duration::hours(1))
            .await;
        
        for pattern in access_patterns {
            // Large number of user records accessed by single user
            if pattern.resources_accessed &gt; 1000 &amp;&amp; pattern.time_span &lt; Duration::minutes(10) {
                self.alert_manager.send_data_exfiltration_alert(&amp;pattern).await;
            }
            
            // Access to sensitive fields by non-admin users
            if pattern.sensitive_fields_accessed &gt; 0 &amp;&amp; !pattern.is_admin_user {
                self.alert_manager.send_privilege_escalation_alert(&amp;pattern).await;
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="deployment-security"><a class="header" href="#deployment-security">Deployment Security</a></h2>
<h3 id="container-security"><a class="header" href="#container-security">Container Security</a></h3>
<pre><code class="language-dockerfile"># Use minimal base image
FROM gcr.io/distroless/cc-debian12:latest

# Don't run as root
USER 65534:65534

# Copy only necessary files
COPY --from=builder /app/target/release/scim-server /scim-server
COPY --from=builder /app/config/ /config/

# Set secure file permissions
USER root
RUN chmod 500 /scim-server &amp;&amp; \
    chmod -R 400 /config/
USER 65534:65534

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD ["/scim-server", "health-check"]

# Expose only necessary port
EXPOSE 8080

ENTRYPOINT ["/scim-server"]
</code></pre>
<h3 id="kubernetes-security"><a class="header" href="#kubernetes-security">Kubernetes Security</a></h3>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
metadata:
  name: scim-server
spec:
  template:
    spec:
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: scim-server
        image: scim-server:latest
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 65534
          capabilities:
            drop:
            - ALL
        resources:
          limits:
            memory: "1Gi"
            cpu: "500m"
          requests:
            memory: "512Mi"
            cpu: "250m"
        env:
        - name: SCIM_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: scim-secrets
              key: db-password
        - name: SCIM_JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: scim-secrets
              key: jwt-secret
        volumeMounts:
        - name: config
          mountPath: /config
          readOnly: true
        - name: tmp
          mountPath: /tmp
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: config
        configMap:
          name: scim-config
          defaultMode: 0400
      - name: tmp
        emptyDir: {}
---
apiVersion: v1
kind: NetworkPolicy
metadata:
  name: scim-server-netpol
spec:
  podSelector:
    matchLabels:
      app: scim-server
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-system
    ports:
    - protocol: TCP
      port: 8080
  egress:
  - to:
    - namespaceSelector:
        matchLabels:
          name: database
    ports:
    - protocol: TCP
      port: 5432
  - to: []
    ports:
    - protocol: TCP
      port: 443  # HTTPS only
</code></pre>
<h3 id="environment-hardening"><a class="header" href="#environment-hardening">Environment Hardening</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::config::SecurityConfig;

fn load_secure_config() -&gt; Result&lt;SecurityConfig, ConfigError&gt; {
    let config = SecurityConfig::builder()
        // Disable debug features in production
        .debug_mode(false)
        .detailed_errors(false)
        
        // Enable all security features
        .require_https(true)
        .strict_transport_security(true)
        .content_security_policy(true)
        .x_frame_options("DENY")
        .x_content_type_options(true)
        .referrer_policy("strict-origin-when-cross-origin")
        
        // Security headers
        .hsts_max_age(31536000) // 1 year
        .hsts_include_subdomains(true)
        .hsts_preload(true)
        
        // Rate limiting
        .enable_rate_limiting(true)
        .default_rate_limit(1000) // per hour
        .burst_rate_limit(100)
        
        // Input validation
        .max_request_size(1048576) // 1MB
        .max_json_depth(10)
        .enable_strict_validation(true)
        
        // Audit logging
        .enable_audit_logging(true)
        .audit_log_level("INFO")
        .audit_destinations(vec!["file", "syslog", "webhook"])
        
        .build()
}
<span class="boring">}</span></code></pre></pre>
<h2 id="compliance-and-standards"><a class="header" href="#compliance-and-standards">Compliance and Standards</a></h2>
<h3 id="gdpr-compliance"><a class="header" href="#gdpr-compliance">GDPR Compliance</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::privacy::{GdprCompliance, DataSubjectRequest, LegalBasis};

#[derive(Debug)]
pub struct GdprCompliance {
    data_controller: String,
    data_processor: Option&lt;String&gt;,
    legal_basis: LegalBasis,
    retention_policy: RetentionPolicy,
}

impl GdprCompliance {
    pub async fn handle_data_subject_request(
        &amp;self,
        request: DataSubjectRequest,
    ) -&gt; Result&lt;DataSubjectResponse, GdprError&gt; {
        match request.request_type {
            RequestType::Access =&gt; self.handle_access_request(request).await,
            RequestType::Rectification =&gt; self.handle_rectification_request(request).await,
            RequestType::Erasure =&gt; self.handle_erasure_request(request).await,
            RequestType::Portability =&gt; self.handle_portability_request(request).await,
            RequestType::Restriction =&gt; self.handle_restriction_request(request).await,
        }
    }
    
    async fn handle_erasure_request(
        &amp;self,
        request: DataSubjectRequest,
    ) -&gt; Result&lt;DataSubjectResponse, GdprError&gt; {
        // Verify identity
        self.verify_data_subject_identity(&amp;request).await?;
        
        // Check for legal obligations that prevent erasure
        if self.has_legal_obligation_to_retain(&amp;request.subject_id).await? {
            return Err(GdprError::ErasureNotPermitted(
                "Data retention required by law".to_string()
            ));
        }
        
        // Perform cascading deletion
        self.delete_user_data(&amp;request.subject_id).await?;
        self.delete_audit_logs(&amp;request.subject_id).await?;
        self.notify_third_parties(&amp;request.subject_id).await?;
        
        // Log the erasure
        self.audit_logger.log_erasure(&amp;request).await;
        
        Ok(DataSubjectResponse {
            request_id: request.id,
            status: "completed".to_string(),
            completion_date: Utc::now(),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="soc-2-compliance"><a class="header" href="#soc-2-compliance">SOC 2 Compliance</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::compliance::{Soc2Controls, ControlObjective};

pub struct Soc2Controls {
    security_controls: Vec&lt;SecurityControl&gt;,
    availability_controls: Vec&lt;AvailabilityControl&gt;,
    confidentiality_controls: Vec&lt;ConfidentialityControl&gt;,
}

impl Soc2Controls {
    pub fn implement_cc6_1_logical_access(&amp;self) -&gt; Result&lt;(), ComplianceError&gt; {
        // CC6.1: Logical and physical access controls
        
        // Multi-factor authentication
        self.enforce_mfa_for_admin_access()?;
        
        // Principle of least privilege
        self.implement_rbac_controls()?;
        
        // Access reviews
        self.schedule_quarterly_access_reviews()?;
        
        // Segregation of duties
        self.enforce_segregation_of_duties()?;
        
        Ok(())
    }
    
    pub fn implement_cc7_1_system_monitoring(&amp;self) -&gt; Result&lt;(), ComplianceError&gt; {
        // CC7.1: System monitoring
        
        // Comprehensive logging
        self.enable_comprehensive_audit_logging()?;
        
        // Real-time monitoring
        self.implement_real_time_alerting()?;
        
        // Log integrity
        self.implement_log_integrity_controls()?;
        
        // Incident response
        self.implement_incident_response_procedures()?;
        
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="incident-response"><a class="header" href="#incident-response">Incident Response</a></h2>
<h3 id="security-incident-detection"><a class="header" href="#security-incident-detection">Security Incident Detection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::security::{IncidentDetector, SecurityIncident, IncidentSeverity};

pub struct IncidentDetector {
    anomaly_detector: AnomalyDetector,
    threat_intelligence: ThreatIntelligence,
    correlation_engine: CorrelationEngine,
}

impl IncidentDetector {
    pub async fn analyze_security_events(&amp;self) -&gt; Vec&lt;SecurityIncident&gt; {
        let mut incidents = Vec::new();
        
        // Detect authentication anomalies
        let auth_anomalies = self.detect_authentication_anomalies().await;
        for anomaly in auth_anomalies {
            incidents.push(SecurityIncident {
                id: Uuid::new_v4(),
                incident_type: IncidentType::AuthenticationAnomaly,
                severity: self.calculate_severity(&amp;anomaly),
                description: anomaly.description,
                affected_resources: anomaly.affected_resources,
                indicators: anomaly.indicators,
                timestamp: Utc::now(),
            });
        }
        
        // Detect data access anomalies
        let data_anomalies = self.detect_data_access_anomalies().await;
        for anomaly in data_anomalies {
            incidents.push(SecurityIncident {
                id: Uuid::new_v4(),
                incident_type: IncidentType::DataAccessAnomaly,
                severity: IncidentSeverity::High,
                description: format!("Unusual data access pattern: {}", anomaly.pattern),
                affected_resources: anomaly.resources,
                indicators: anomaly.indicators,
                timestamp: Utc::now(),
            });
        }
        
        incidents
    }
    
    async fn detect_authentication_anomalies(&amp;self) -&gt; Vec&lt;AuthenticationAnomaly&gt; {
        let mut anomalies = Vec::new();
        
        // Detect brute force attacks
        let failed_logins = self.get_recent_failed_logins(Duration::hours(1)).await;
        let grouped_by_ip = self.group_by_ip(failed_logins);
        
        for (ip, attempts) in grouped_by_ip {
            if attempts.len() &gt; 50 {
                anomalies.push(AuthenticationAnomaly {
                    anomaly_type: AnomalyType::BruteForce,
                    source_ip: ip,
                    description: format!("Brute force attack detected: {} failed attempts", attempts.len()),
                    affected_resources: attempts.into_iter().map(|a| a.target_user).collect(),
                    indicators: vec![
                        format!("source_ip: {}", ip),
                        format!("attempt_count: {}", attempts.len()),
                    ],
                });
            }
        }
        
        // Detect impossible travel
        let successful_logins = self.get_recent_successful_logins(Duration::hours(24)).await;
        let travel_anomalies = self.detect_impossible_travel(successful_logins).await;
        anomalies.extend(travel_anomalies);
        
        anomalies
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="automated-response"><a class="header" href="#automated-response">Automated Response</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::security::{AutomatedResponse, ResponseAction};

pub struct AutomatedResponse {
    action_executor: ActionExecutor,
    notification_service: NotificationService,
    escalation_rules: Vec&lt;EscalationRule&gt;,
}

impl AutomatedResponse {
    pub async fn respond_to_incident(&amp;self, incident: &amp;SecurityIncident) {
        match incident.severity {
            IncidentSeverity::Critical =&gt; {
                self.execute_critical_response(incident).await;
            }
            IncidentSeverity::High =&gt; {
                self.execute_high_severity_response(incident).await;
            }
            IncidentSeverity::Medium =&gt; {
                self.execute_medium_severity_response(incident).await;
            }
            IncidentSeverity::Low =&gt; {
                self.execute_low_severity_response(incident).await;
            }
        }
    }
    
    async fn execute_critical_response(&amp;self, incident: &amp;SecurityIncident) {
        // Immediate blocking
        if let Some(source_ip) = self.extract_source_ip(incident) {
            self.action_executor.block_ip_address(source_ip).await;
        }
        
        // Disable compromised accounts
        for resource in &amp;incident.affected_resources {
            if resource.resource_type == "User" {
                self.action_executor.disable_user_account(&amp;resource.id).await;
            }
        }
        
        // Immediate notifications
        self.notification_service.send_critical_alert(incident).await;
        self.notification_service.notify_security_team(incident).await;
        self.notification_service.notify_management(incident).await;
        
        // Initiate incident response process
        self.initiate_incident_response_process(incident).await;
    }
    
    async fn initiate_incident_response_process(&amp;self, incident: &amp;SecurityIncident) {
        // Create incident ticket
        let ticket = self.create_incident_ticket(incident).await;
        
        // Preserve evidence
        self.preserve_digital_evidence(incident).await;
        
        // Notify external parties if required
        if self.requires_external_notification(incident) {
            self.notify_authorities(incident).await;
            self.notify_customers(incident).await;
        }
        
        // Start forensic analysis
        self.start_forensic_analysis(incident).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="security-testing"><a class="header" href="#security-testing">Security Testing</a></h2>
<h3 id="penetration-testing-integration"><a class="header" href="#penetration-testing-integration">Penetration Testing Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::testing::{PenetrationTest, VulnerabilityScanner};

pub struct SecurityTestSuite {
    vulnerability_scanner: VulnerabilityScanner,
    penetration_tester: PenetrationTest,
    compliance_checker: ComplianceChecker,
}

impl SecurityTestSuite {
    pub async fn run_security_tests(&amp;self) -&gt; SecurityTestReport {
        let mut report = SecurityTestReport::new();
        
        // Vulnerability scanning
        let vulnerabilities = self.vulnerability_scanner.scan().await;
        report.add_vulnerabilities(vulnerabilities);
        
        // Authentication testing
        let auth_tests = self.test_authentication_security().await;
        report.add_test_results("authentication", auth_tests);
        
        // Authorization testing
        let authz_tests = self.test_authorization_security().await;
        report.add_test_results("authorization", authz_tests);
        
        // Input validation testing
        let input_tests = self.test_input_validation().await;
        report.add_test_results("input_validation", input_tests);
        
        // Network security testing
        let network_tests = self.test_network_security().await;
        report.add_test_results("network_security", network_tests);
        
        report
    }
    
    async fn test_authentication_security(&amp;self) -&gt; Vec&lt;TestResult&gt; {
        vec![
            self.test_jwt_validation().await,
            self.test_token_expiration().await,
            self.test_brute_force_protection().await,
            self.test_session_management().await,
        ]
    }
    
    async fn test_jwt_validation(&amp;self) -&gt; TestResult {
        let test_cases = vec![
            ("Invalid signature", "invalid_jwt_token"),
            ("Expired token", self.create_expired_jwt()),
            ("Wrong audience", self.create_wrong_audience_jwt()),
            ("Missing required claims", self.create_incomplete_jwt()),
        ];
        
        for (test_name, token) in test_cases {
            let result = self.make_authenticated_request(token).await;
            if result.status() != 401 {
                return TestResult::Failed(format!("JWT validation failed for: {}", test_name));
            }
        }
        
        TestResult::Passed("JWT validation working correctly".to_string())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices-summary"><a class="header" href="#best-practices-summary">Best Practices Summary</a></h2>
<h3 id="authentication-best-practices"><a class="header" href="#authentication-best-practices">Authentication Best Practices</a></h3>
<ol>
<li>
<p><strong>Use Strong Authentication Methods</strong></p>
<ul>
<li>Implement JWT with RS256 or ES256 algorithms</li>
<li>Require multi-factor authentication for admin access</li>
<li>Use short-lived tokens (15-60 minutes)</li>
<li>Implement proper token refresh mechanisms</li>
</ul>
</li>
<li>
<p><strong>Secure Token Handling</strong></p>
<ul>
<li>Never store tokens in local storage</li>
<li>Use secure, httpOnly cookies when possible</li>
<li>Implement proper token revocation</li>
<li>Cache public keys securely with rotation</li>
</ul>
</li>
<li>
<p><strong>Session Management</strong></p>
<ul>
<li>Implement session timeout</li>
<li>Regenerate session IDs after authentication</li>
<li>Use secure session storage</li>
<li>Implement concurrent session limits</li>
</ul>
</li>
</ol>
<h3 id="authorization-best-practices"><a class="header" href="#authorization-best-practices">Authorization Best Practices</a></h3>
<ol>
<li>
<p><strong>Principle of Least Privilege</strong></p>
<ul>
<li>Grant minimum necessary permissions</li>
<li>Implement role-based access control</li>
<li>Use attribute-based access control for complex scenarios</li>
<li>Regular access reviews and cleanup</li>
</ul>
</li>
<li>
<p><strong>Resource-Level Security</strong></p>
<ul>
<li>Implement tenant isolation</li>
<li>Validate resource ownership</li>
<li>Use resource-specific permissions</li>
<li>Implement field-level access control</li>
</ul>
</li>
</ol>
<h3 id="data-protection-best-practices"><a class="header" href="#data-protection-best-practices">Data Protection Best Practices</a></h3>
<ol>
<li>
<p><strong>Encryption</strong></p>
<ul>
<li>Encrypt sensitive data at rest</li>
<li>Use TLS 1.2+ for data in transit</li>
<li>Implement key rotation policies</li>
<li>Use envelope encryption for large datasets</li>
</ul>
</li>
<li>
<p><strong>Data Handling</strong></p>
<ul>
<li>Implement data classification</li>
<li>Use data masking for non-production environments</li>
<li>Implement secure data deletion</li>
<li>Monitor data access patterns</li>
</ul>
</li>
</ol>
<h3 id="network-security-best-practices"><a class="header" href="#network-security-best-practices">Network Security Best Practices</a></h3>
<ol>
<li>
<p><strong>Network Controls</strong></p>
<ul>
<li>Implement IP allowlisting</li>
<li>Use rate limiting aggressively</li>
<li>Configure CORS properly</li>
<li>Implement DDoS protection</li>
</ul>
</li>
<li>
<p><strong>Monitoring</strong></p>
<ul>
<li>Implement comprehensive logging</li>
<li>Use real-time alerting</li>
<li>Monitor for anomalous patterns</li>
<li>Implement automated response</li>
</ul>
</li>
</ol>
<h3 id="deployment-security-best-practices"><a class="header" href="#deployment-security-best-practices">Deployment Security Best Practices</a></h3>
<ol>
<li>
<p><strong>Infrastructure Security</strong></p>
<ul>
<li>Use minimal container images</li>
<li>Run as non-root user</li>
<li>Implement network policies</li>
<li>Use secrets management</li>
</ul>
</li>
<li>
<p><strong>Configuration Security</strong></p>
<ul>
<li>Never hardcode secrets</li>
<li>Use environment-specific configurations</li>
<li>Implement configuration validation</li>
<li>Regular security assessments</li>
</ul>
</li>
</ol>
<p>This comprehensive security guide provides the foundation for deploying and operating secure SCIM servers in production environments. Regular security reviews and updates are essential for maintaining security posture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring-and-observability-4"><a class="header" href="#monitoring-and-observability-4">Monitoring and Observability</a></h1>
<p>This guide covers comprehensive monitoring, metrics, logging, and observability strategies for SCIM Server deployments. Effective observability is crucial for maintaining reliable identity management systems at scale.</p>
<h2 id="overview-16"><a class="header" href="#overview-16">Overview</a></h2>
<p>Observability for SCIM servers encompasses:</p>
<ul>
<li><strong>Metrics Collection</strong> - Performance and business metrics</li>
<li><strong>Logging</strong> - Structured application and audit logs</li>
<li><strong>Tracing</strong> - Distributed request tracing</li>
<li><strong>Health Checks</strong> - Service health and readiness</li>
<li><strong>Alerting</strong> - Proactive incident detection</li>
<li><strong>Dashboards</strong> - Visual monitoring and analysis</li>
</ul>
<h2 id="metrics-collection-3"><a class="header" href="#metrics-collection-3">Metrics Collection</a></h2>
<h3 id="built-in-metrics"><a class="header" href="#built-in-metrics">Built-in Metrics</a></h3>
<p>The SCIM Server library provides comprehensive metrics out of the box:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{MetricsConfig, MetricsCollector, PrometheusExporter};

let metrics_config = MetricsConfig::builder()
    .enable_http_metrics(true)
    .enable_business_metrics(true)
    .enable_system_metrics(true)
    .prometheus_endpoint("/metrics")
    .collection_interval_seconds(15)
    .histogram_buckets(vec![0.001, 0.01, 0.1, 1.0, 10.0])
    .build()?;

let metrics_collector = MetricsCollector::new(metrics_config);
let server = ScimServer::new(storage)
    .with_metrics(metrics_collector)
    .await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="http-metrics"><a class="header" href="#http-metrics">HTTP Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_http_requests_total</code></td><td>Counter</td><td>Total HTTP requests</td><td><code>method</code>, <code>endpoint</code>, <code>status_code</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_http_request_duration_seconds</code></td><td>Histogram</td><td>Request duration</td><td><code>method</code>, <code>endpoint</code>, <code>status_code</code></td></tr>
<tr><td><code>scim_http_request_size_bytes</code></td><td>Histogram</td><td>Request body size</td><td><code>method</code>, <code>endpoint</code></td></tr>
<tr><td><code>scim_http_response_size_bytes</code></td><td>Histogram</td><td>Response body size</td><td><code>method</code>, <code>endpoint</code></td></tr>
<tr><td><code>scim_http_requests_in_flight</code></td><td>Gauge</td><td>Concurrent requests</td><td><code>endpoint</code></td></tr>
</tbody></table>
</div>
<h3 id="business-metrics"><a class="header" href="#business-metrics">Business Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_users_total</code></td><td>Gauge</td><td>Total users in system</td><td><code>tenant_id</code>, <code>active</code></td></tr>
<tr><td><code>scim_groups_total</code></td><td>Gauge</td><td>Total groups in system</td><td><code>tenant_id</code></td></tr>
<tr><td><code>scim_operations_total</code></td><td>Counter</td><td>SCIM operations performed</td><td><code>operation</code>, <code>resource_type</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_bulk_operations_total</code></td><td>Counter</td><td>Bulk operations performed</td><td><code>tenant_id</code>, <code>status</code></td></tr>
<tr><td><code>scim_filter_queries_total</code></td><td>Counter</td><td>Filter queries executed</td><td><code>complexity</code>, <code>tenant_id</code></td></tr>
<tr><td><code>scim_authentication_attempts_total</code></td><td>Counter</td><td>Authentication attempts</td><td><code>method</code>, <code>result</code>, <code>tenant_id</code></td></tr>
</tbody></table>
</div>
<h3 id="system-metrics"><a class="header" href="#system-metrics">System Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Type</th><th>Description</th><th>Labels</th></tr></thead><tbody>
<tr><td><code>scim_memory_usage_bytes</code></td><td>Gauge</td><td>Memory usage</td><td><code>type</code></td></tr>
<tr><td><code>scim_cpu_usage_percentage</code></td><td>Gauge</td><td>CPU usage</td><td>-</td></tr>
<tr><td><code>scim_database_connections_active</code></td><td>Gauge</td><td>Active DB connections</td><td><code>pool</code></td></tr>
<tr><td><code>scim_database_connections_idle</code></td><td>Gauge</td><td>Idle DB connections</td><td><code>pool</code></td></tr>
<tr><td><code>scim_cache_hits_total</code></td><td>Counter</td><td>Cache hits</td><td><code>cache_type</code></td></tr>
<tr><td><code>scim_cache_misses_total</code></td><td>Counter</td><td>Cache misses</td><td><code>cache_type</code></td></tr>
</tbody></table>
</div>
<h3 id="custom-metrics"><a class="header" href="#custom-metrics">Custom Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{Counter, Histogram, Gauge, MetricRegistry};

pub struct CustomMetrics {
    tenant_provisioning_duration: Histogram,
    active_sessions: Gauge,
    password_reset_requests: Counter,
    data_sync_errors: Counter,
}

impl CustomMetrics {
    pub fn new(registry: &amp;MetricRegistry) -&gt; Self {
        Self {
            tenant_provisioning_duration: registry.register_histogram(
                "scim_tenant_provisioning_duration_seconds",
                "Time to provision new tenant",
                vec!["tenant_type"]
            ),
            active_sessions: registry.register_gauge(
                "scim_active_sessions",
                "Number of active user sessions",
                vec!["tenant_id"]
            ),
            password_reset_requests: registry.register_counter(
                "scim_password_reset_requests_total",
                "Password reset requests",
                vec!["tenant_id", "method"]
            ),
            data_sync_errors: registry.register_counter(
                "scim_data_sync_errors_total",
                "Data synchronization errors",
                vec!["source_system", "error_type"]
            ),
        }
    }
    
    pub fn record_tenant_provisioning(&amp;self, tenant_type: &amp;str, duration: Duration) {
        self.tenant_provisioning_duration
            .with_label_values(&amp;[tenant_type])
            .observe(duration.as_secs_f64());
    }
    
    pub fn update_active_sessions(&amp;self, tenant_id: &amp;str, count: i64) {
        self.active_sessions
            .with_label_values(&amp;[tenant_id])
            .set(count as f64);
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="structured-logging"><a class="header" href="#structured-logging">Structured Logging</a></h2>
<h3 id="logging-configuration-1"><a class="header" href="#logging-configuration-1">Logging Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::logging::{LoggingConfig, LogFormat, LogLevel};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

let logging_config = LoggingConfig::builder()
    .level(LogLevel::Info)
    .format(LogFormat::Json)
    .enable_spans(true)
    .enable_events(true)
    .fields(vec![
        "timestamp".to_string(),
        "level".to_string(),
        "target".to_string(),
        "message".to_string(),
        "tenant_id".to_string(),
        "user_id".to_string(),
        "request_id".to_string(),
        "operation".to_string(),
        "resource_type".to_string(),
        "duration_ms".to_string(),
    ])
    .exclude_fields(vec!["password".to_string(), "token".to_string()])
    .max_log_level_per_module(HashMap::from([
        ("scim_server::auth".to_string(), LogLevel::Debug),
        ("sqlx".to_string(), LogLevel::Warn),
    ]))
    .build()?;

// Initialize structured logging
tracing_subscriber::registry()
    .with(
        tracing_subscriber::EnvFilter::try_from_default_env()
            .unwrap_or_else(|_| "scim_server=info".into())
    )
    .with(
        tracing_subscriber::fmt::layer()
            .json()
            .with_current_span(false)
            .with_span_list(true)
            .with_target(true)
            .with_thread_ids(true)
            .with_thread_names(true)
    )
    .init();
<span class="boring">}</span></code></pre></pre>
<h3 id="contextual-logging"><a class="header" href="#contextual-logging">Contextual Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error, debug, Span};
use tracing_futures::Instrument;

// Create request-scoped spans
#[tracing::instrument(
    name = "create_user",
    skip(user_data),
    fields(
        tenant_id = %tenant_id,
        user_name = %user_data.user_name.as_deref().unwrap_or("unknown"),
        operation = "create_user"
    )
)]
pub async fn create_user(
    tenant_id: &amp;str,
    user_data: CreateUserRequest,
) -&gt; Result&lt;User, ScimError&gt; {
    let span = Span::current();
    
    // Add dynamic fields to the span
    span.record("user_id", &amp;tracing::field::display(&amp;user_data.id));
    
    info!("Starting user creation");
    
    // Validate input
    match validate_user_data(&amp;user_data).await {
        Ok(_) =&gt; debug!("User data validation passed"),
        Err(e) =&gt; {
            warn!(error = %e, "User data validation failed");
            return Err(ScimError::ValidationError(e));
        }
    }
    
    // Create user in storage
    let start_time = Instant::now();
    let user = match storage.create_user(tenant_id, user_data).await {
        Ok(user) =&gt; {
            let duration = start_time.elapsed();
            info!(
                duration_ms = duration.as_millis(),
                user_id = %user.id,
                "User created successfully"
            );
            user
        }
        Err(e) =&gt; {
            error!(
                error = %e,
                duration_ms = start_time.elapsed().as_millis(),
                "Failed to create user"
            );
            return Err(e);
        }
    };
    
    // Log business event
    info!(
        event_type = "user_created",
        user_id = %user.id,
        tenant_id = %tenant_id,
        user_name = %user.user_name,
        active = user.active,
        "User creation completed"
    );
    
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="audit-logging-1"><a class="header" href="#audit-logging-1">Audit Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::audit::{AuditLogger, AuditEvent, AuditLevel};
use serde_json::json;

pub struct AuditLogger {
    logger: tracing::Span,
    config: AuditConfig,
}

impl AuditLogger {
    pub async fn log_user_operation(&amp;self, event: UserOperationEvent) {
        let audit_event = AuditEvent {
            timestamp: Utc::now(),
            event_type: "user_operation".to_string(),
            actor: ActorInfo {
                user_id: event.actor_id.clone(),
                session_id: event.session_id.clone(),
                ip_address: event.ip_address,
                user_agent: event.user_agent.clone(),
            },
            resource: ResourceInfo {
                resource_type: "User".to_string(),
                resource_id: event.user_id.clone(),
                tenant_id: event.tenant_id.clone(),
            },
            operation: OperationInfo {
                operation_type: event.operation.clone(),
                method: event.http_method.clone(),
                endpoint: event.endpoint.clone(),
                success: event.success,
                error_message: event.error_message.clone(),
            },
            details: json!({
                "user_id": event.user_id,
                "fields_modified": event.fields_modified,
                "before_values": event.before_values,
                "after_values": event.after_values,
                "request_size": event.request_size,
                "response_size": event.response_size,
            }),
        };
        
        // Log to structured log
        info!(
            target: "audit",
            event_type = %audit_event.event_type,
            actor_id = %audit_event.actor.user_id,
            resource_type = %audit_event.resource.resource_type,
            resource_id = %audit_event.resource.resource_id,
            tenant_id = %audit_event.resource.tenant_id,
            operation = %audit_event.operation.operation_type,
            success = audit_event.operation.success,
            ip_address = %audit_event.actor.ip_address,
            user_agent = %audit_event.actor.user_agent.as_deref().unwrap_or("unknown"),
            "{}", serde_json::to_string(&amp;audit_event.details).unwrap_or_default()
        );
        
        // Send to external audit system
        if let Some(webhook_url) = &amp;self.config.audit_webhook_url {
            self.send_to_webhook(webhook_url, &amp;audit_event).await;
        }
        
        // Store in database for compliance
        if self.config.store_in_database {
            self.store_audit_event(&amp;audit_event).await;
        }
    }
    
    pub async fn log_authentication_event(&amp;self, event: AuthenticationEvent) {
        info!(
            target: "audit.auth",
            event_type = "authentication",
            user_id = %event.user_id.as_deref().unwrap_or("unknown"),
            tenant_id = %event.tenant_id.as_deref().unwrap_or("unknown"),
            auth_method = %event.auth_method,
            success = event.success,
            failure_reason = %event.failure_reason.as_deref().unwrap_or(""),
            ip_address = %event.ip_address,
            user_agent = %event.user_agent.as_deref().unwrap_or("unknown"),
            session_id = %event.session_id.as_deref().unwrap_or(""),
            "Authentication attempt"
        );
        
        // Increment authentication metrics
        if event.success {
            self.metrics.authentication_success.inc();
        } else {
            self.metrics.authentication_failure.inc();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="distributed-tracing"><a class="header" href="#distributed-tracing">Distributed Tracing</a></h2>
<h3 id="opentelemetry-integration"><a class="header" href="#opentelemetry-integration">OpenTelemetry Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use opentelemetry::{global, trace::TracerProvider, KeyValue};
use opentelemetry_otlp::WithExportConfig;
use tracing_opentelemetry::OpenTelemetryLayer;

pub async fn setup_tracing() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Configure OpenTelemetry exporter
    let tracer = opentelemetry_otlp::new_pipeline()
        .tracing()
        .with_exporter(
            opentelemetry_otlp::new_exporter()
                .tonic()
                .with_endpoint("http://jaeger:14268/api/traces")
        )
        .with_trace_config(
            opentelemetry::sdk::trace::config()
                .with_sampler(opentelemetry::sdk::trace::Sampler::TraceIdRatioBased(0.1))
                .with_resource(opentelemetry::sdk::Resource::new(vec![
                    KeyValue::new("service.name", "scim-server"),
                    KeyValue::new("service.version", env!("CARGO_PKG_VERSION")),
                    KeyValue::new("deployment.environment", "production"),
                ]))
        )
        .install_batch(opentelemetry::runtime::Tokio)?;
    
    // Create tracing subscriber with OpenTelemetry layer
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new("scim_server=info"))
        .with(tracing_subscriber::fmt::layer())
        .with(OpenTelemetryLayer::new(tracer))
        .init();
    
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trace-instrumentation"><a class="header" href="#trace-instrumentation">Trace Instrumentation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{instrument, Span};
use opentelemetry::trace::{TraceContextExt, Tracer};

#[instrument(
    name = "scim.user.create",
    skip(storage, user_data),
    fields(
        scim.tenant_id = %tenant_id,
        scim.operation = "create",
        scim.resource_type = "User",
        user.name = %user_data.user_name.as_deref().unwrap_or("unknown"),
        otel.kind = "server"
    )
)]
pub async fn create_user_with_tracing(
    storage: &amp;dyn StorageProvider,
    tenant_id: &amp;str,
    user_data: CreateUserRequest,
) -&gt; Result&lt;User, ScimError&gt; {
    let span = Span::current();
    let cx = span.context();
    
    // Add custom attributes
    if let Some(trace_id) = cx.span().span_context().trace_id().to_string() {
        span.record("trace_id", &amp;tracing::field::display(&amp;trace_id));
    }
    
    // Validate user data (child span)
    validate_user_data(&amp;user_data)
        .instrument(tracing::info_span!("scim.validation", validation.type = "user"))
        .await?;
    
    // Check uniqueness (child span)
    check_user_uniqueness(storage, tenant_id, &amp;user_data.user_name)
        .instrument(tracing::info_span!(
            "scim.uniqueness_check",
            db.operation = "select",
            user.name = %user_data.user_name
        ))
        .await?;
    
    // Create user in storage (child span)
    let user = storage
        .create_user(tenant_id, user_data)
        .instrument(tracing::info_span!(
            "scim.storage.create",
            db.operation = "insert",
            db.table = "users"
        ))
        .await?;
    
    // Record successful creation
    span.record("user.id", &amp;tracing::field::display(&amp;user.id));
    span.record("scim.status", "success");
    
    Ok(user)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="health-checks-2"><a class="header" href="#health-checks-2">Health Checks</a></h2>
<h3 id="health-check-implementation"><a class="header" href="#health-check-implementation">Health Check Implementation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::health::{HealthChecker, HealthStatus, HealthCheckResult};

pub struct HealthChecker {
    storage: Arc&lt;dyn StorageProvider&gt;,
    auth_service: Arc&lt;dyn AuthService&gt;,
    cache: Option&lt;Arc&lt;dyn CacheProvider&gt;&gt;,
    config: HealthCheckConfig,
}

impl HealthChecker {
    pub async fn check_health(&amp;self) -&gt; HealthCheckResult {
        let mut checks = Vec::new();
        
        // Overall health check
        checks.push(self.check_application_health().await);
        
        // Storage health
        checks.push(self.check_storage_health().await);
        
        // Authentication service health
        checks.push(self.check_auth_service_health().await);
        
        // Cache health (if configured)
        if let Some(cache) = &amp;self.cache {
            checks.push(self.check_cache_health(cache).await);
        }
        
        // External dependencies
        checks.push(self.check_external_dependencies().await);
        
        let overall_status = if checks.iter().all(|c| c.status == HealthStatus::Healthy) {
            HealthStatus::Healthy
        } else if checks.iter().any(|c| c.status == HealthStatus::Critical) {
            HealthStatus::Critical
        } else {
            HealthStatus::Degraded
        };
        
        HealthCheckResult {
            status: overall_status,
            timestamp: Utc::now(),
            checks,
            version: env!("CARGO_PKG_VERSION").to_string(),
            uptime_seconds: self.get_uptime_seconds(),
        }
    }
    
    async fn check_storage_health(&amp;self) -&gt; HealthCheck {
        let start_time = Instant::now();
        
        match timeout(Duration::from_secs(5), self.storage.health_check()).await {
            Ok(Ok(_)) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Healthy,
                response_time_ms: start_time.elapsed().as_millis() as u64,
                message: Some("Storage is responsive".to_string()),
                details: None,
            },
            Ok(Err(e)) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Critical,
                response_time_ms: start_time.elapsed().as_millis() as u64,
                message: Some(format!("Storage error: {}", e)),
                details: Some(json!({
                    "error_type": "storage_error",
                    "error_details": e.to_string()
                })),
            },
            Err(_) =&gt; HealthCheck {
                name: "storage".to_string(),
                status: HealthStatus::Critical,
                response_time_ms: 5000,
                message: Some("Storage health check timeout".to_string()),
                details: Some(json!({
                    "error_type": "timeout",
                    "timeout_seconds": 5
                })),
            },
        }
    }
    
    async fn check_application_health(&amp;self) -&gt; HealthCheck {
        let mut details = serde_json::Map::new();
        
        // Check memory usage
        let memory_usage = self.get_memory_usage();
        details.insert("memory_usage_mb".to_string(), json!(memory_usage));
        
        // Check CPU usage
        let cpu_usage = self.get_cpu_usage().await;
        details.insert("cpu_usage_percent".to_string(), json!(cpu_usage));
        
        // Check active connections
        let active_connections = self.get_active_connections();
        details.insert("active_connections".to_string(), json!(active_connections));
        
        // Determine status based on resource usage
        let status = if memory_usage &gt; 90.0 || cpu_usage &gt; 95.0 {
            HealthStatus::Critical
        } else if memory_usage &gt; 80.0 || cpu_usage &gt; 85.0 {
            HealthStatus::Degraded
        } else {
            HealthStatus::Healthy
        };
        
        HealthCheck {
            name: "application".to_string(),
            status,
            response_time_ms: 0,
            message: Some("Application resource usage check".to_string()),
            details: Some(json!(details)),
        }
    }
}

// Health check endpoints
async fn health_live() -&gt; Result&lt;Json&lt;HealthCheckResult&gt;, StatusCode&gt; {
    // Simple liveness check
    Ok(Json(HealthCheckResult {
        status: HealthStatus::Healthy,
        timestamp: Utc::now(),
        checks: vec![],
        version: env!("CARGO_PKG_VERSION").to_string(),
        uptime_seconds: get_uptime_seconds(),
    }))
}

async fn health_ready(
    State(health_checker): State&lt;Arc&lt;HealthChecker&gt;&gt;,
) -&gt; Result&lt;Json&lt;HealthCheckResult&gt;, StatusCode&gt; {
    let result = health_checker.check_health().await;
    
    match result.status {
        HealthStatus::Healthy =&gt; Ok(Json(result)),
        HealthStatus::Degraded =&gt; {
            warn!("Health check returned degraded status: {:?}", result);
            Ok(Json(result))
        }
        HealthStatus::Critical =&gt; {
            error!("Health check returned critical status: {:?}", result);
            Err(StatusCode::SERVICE_UNAVAILABLE)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="alerting"><a class="header" href="#alerting">Alerting</a></h2>
<h3 id="alert-configuration"><a class="header" href="#alert-configuration">Alert Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::alerting::{AlertManager, AlertRule, AlertSeverity, AlertChannel};

pub struct AlertManager {
    rules: Vec&lt;AlertRule&gt;,
    channels: Vec&lt;AlertChannel&gt;,
    metrics_client: MetricsClient,
}

impl AlertManager {
    pub fn new() -&gt; Self {
        let rules = vec![
            // High error rate
            AlertRule {
                name: "high_error_rate".to_string(),
                description: "HTTP error rate above 5%".to_string(),
                query: "rate(scim_http_requests_total{status_code=~'5..'}[5m]) / rate(scim_http_requests_total[5m]) &gt; 0.05".to_string(),
                severity: AlertSeverity::Critical,
                for_duration: Duration::from_secs(300), // 5 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "error_rate".to_string()),
                ]),
            },
            
            // High response time
            AlertRule {
                name: "high_response_time".to_string(),
                description: "95th percentile response time above 1 second".to_string(),
                query: "histogram_quantile(0.95, rate(scim_http_request_duration_seconds_bucket[5m])) &gt; 1.0".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(600), // 10 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "performance".to_string()),
                ]),
            },
            
            // Database connection issues
            AlertRule {
                name: "database_connection_exhaustion".to_string(),
                description: "Database connection pool nearly exhausted".to_string(),
                query: "scim_database_connections_active / (scim_database_connections_active + scim_database_connections_idle) &gt; 0.9".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(120), // 2 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "database".to_string()),
                ]),
            },
            
            // Authentication failures
            AlertRule {
                name: "high_auth_failure_rate".to_string(),
                description: "Authentication failure rate above 10%".to_string(),
                query: "rate(scim_authentication_attempts_total{result='failure'}[5m]) / rate(scim_authentication_attempts_total[5m]) &gt; 0.1".to_string(),
                severity: AlertSeverity::Critical,
                for_duration: Duration::from_secs(180), // 3 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "security".to_string()),
                ]),
            },
            
            // Memory usage
            AlertRule {
                name: "high_memory_usage".to_string(),
                description: "Memory usage above 85%".to_string(),
                query: "scim_memory_usage_bytes{type='heap'} / scim_memory_usage_bytes{type='total'} &gt; 0.85".to_string(),
                severity: AlertSeverity::Warning,
                for_duration: Duration::from_secs(600), // 10 minutes
                labels: HashMap::from([
                    ("service".to_string(), "scim-server".to_string()),
                    ("type".to_string(), "resource".to_string()),
                ]),
            },
        ];
        
        let channels = vec![
            AlertChannel::Slack {
                webhook_url: std::env::var("SLACK_WEBHOOK_URL").unwrap(),
                channel: "#alerts".to_string(),
                username: "SCIM Monitor".to_string(),
            },
            AlertChannel::PagerDuty {
                integration_key: std::env::var("PAGERDUTY_INTEGRATION_KEY").unwrap(),
            },
            AlertChannel::Email {
                smtp_server: "smtp.company.com".to_string(),
                recipients: vec![
                    "oncall@company.com".to_string(),
                    "devops@company.com".to_string(),
                ],
            },
        ];
        
        Self {
            rules,
            channels,
            metrics_client: MetricsClient::new(),
        }
    }
    
    pub async fn check_alerts(&amp;self) {
        for rule in &amp;self.rules {
            match self.evaluate_rule(rule).await {
                Ok(Some(alert)) =&gt; {
                    info!("Alert triggered: {}", alert.name);
                    self.send_alert(&amp;alert).await;
                }
                Ok(None) =&gt; {
                    debug!("Alert rule {} is not triggered", rule.name);
                }
                Err(e) =&gt; {
                    error!("Failed to evaluate alert rule {}: {}", rule.name, e);
                }
            }
        }
    }
    
    async fn send_alert(&amp;self, alert: &amp;Alert) {
        for channel in &amp;self.channels {
            match channel {
                AlertChannel::Slack { webhook_url, .. } =&gt; {
                    self.send_slack_alert(webhook_url, alert).await;
                }
                AlertChannel::PagerDuty { integration_key } =&gt; {
                    if alert.severity == AlertSeverity::Critical {
                        self.send_pagerduty_alert(integration_key, alert).await;
                    }
                }
                AlertChannel::Email { recipients, .. } =&gt; {
                    self.send_email_alert(recipients, alert).await;
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="dashboards"><a class="header" href="#dashboards">Dashboards</a></h2>
<h3 id="grafana-dashboard-configuration"><a class="header" href="#grafana-dashboard-configuration">Grafana Dashboard Configuration</a></h3>
<pre><code class="language-json">{
  "dashboard": {
    "title": "SCIM Server Monitoring",
    "tags": ["scim", "identity", "monitoring"],
    "timezone": "UTC",
    "panels": [
      {
        "title": "Request Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(scim_http_requests_total[5m])",
            "legendFormat": "{{method}} {{endpoint}}"
          }
        ],
        "yAxes": [
          {
            "label": "Requests/sec"
          }
        ]
      },
      {
        "title": "Error Rate",
        "type": "graph",
        "targets": [
          {
            "expr": "rate(scim_http_requests_total{status_code=~'4..|5..'}[5m]) / rate(scim_http_requests_total[5m])",
            "legendFormat": "Error Rate"
          }
        ],
        "yAxes": [
          {
            "label": "Error Rate (%)",
            "max": 1,
            "min": 0
          }
        ],
        "alert": {
          "conditions": [
            {
              "query": {
                "queryType": "",
                "refId": "A"
              },
              "reducer": {
                "type": "last",
                "params": []
              },
              "evaluator": {
                "params": [0.05],
                "type": "gt"
              }
            }
          ],
          "executionErrorState": "alerting",
          "for": "5m",
          "frequency": "10s",
          "handler": 1,
          "name": "High Error Rate",
          "noDataState": "no_data",
          "notifications": []
        }
      },
      {
        "title": "Response Time",
        "type": "graph",
        "targets": [
          {
            "expr": "histogram_quantile(0.50, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "50th percentile"
          },
          {
            "expr": "histogram_quantile(0.95, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "95th percentile"
          },
          {
            "expr": "histogram_quantile(0.99, rate(scim_http_request_duration_seconds_bucket[5m]))",
            "legendFormat": "99th percentile"
          }
        ]
      },
      {
        "title": "Active Users by Tenant",
        "type": "piechart",
        "targets": [
          {
            "expr": "scim_users_total{active='true'}",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      },
      {
        "title": "Database Connections",
        "type": "graph",
        "targets": [
          {
            "expr": "scim_database_connections_active",
            "legendFormat": "Active"
          },
          {
            "expr": "scim_database_connections_idle",
            "legendFormat": "Idle"
          }
        ]
      },
      {
        "title": "Authentication Methods",
        "type": "piechart",
        "targets": [
          {
            "expr": "increase(scim_authentication_attempts_total{result='success'}[1h])",
            "legendFormat": "{{method}}"
          }
        ]
      },
      {
        "title": "Cache Hit Rate",
        "type": "stat",
        "targets": [
          {
            "expr": "rate(scim_cache_hits_total[5m]) / (rate(scim_cache_hits_total[5m]) + rate(scim_cache_misses_total[5m]))",
            "legendFormat": "Hit Rate"
          }
        ],
        "fieldConfig": {
          "defaults": {
            "unit": "percentunit",
            "min": 0,
            "max": 1
          }
        }
      }
    ],
    "time": {
      "from": "now-1h",
      "to": "now"
    },
    "refresh": "30s"
  }
}
</code></pre>
<h3 id="business-intelligence-dashboard"><a class="header" href="#business-intelligence-dashboard">Business Intelligence Dashboard</a></h3>
<pre><code class="language-json">{
  "dashboard": {
    "title": "SCIM Business Metrics",
    "panels": [
      {
        "title": "User Growth by Tenant",
        "type": "graph",
        "targets": [
          {
            "expr": "increase(scim_users_total[24h])",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      },
      {
        "title": "Most Active Operations",
        "type": "table",
        "targets": [
          {
            "expr": "topk(10, increase(scim_operations_total[1h]))",
            "legendFormat": "{{operation}} - {{resource_type}}"
          }
        ]
      },
      {
        "title": "Tenant Resource Usage",
        "type": "heatmap",
        "targets": [
          {
            "expr": "scim_users_total + scim_groups_total",
            "legendFormat": "{{tenant_id}}"
          }
        ]
      }
    ]
  }
}
</code></pre>
<h2 id="log-aggregation-and-analysis"><a class="header" href="#log-aggregation-and-analysis">Log Aggregation and Analysis</a></h2>
<h3 id="elk-stack-integration"><a class="header" href="#elk-stack-integration">ELK Stack Integration</a></h3>
<pre><code class="language-yaml"># Filebeat configuration
filebeat.inputs:
- type: log
  enabled: true
  paths:
    - /var/log/scim-server/*.log
  fields:
    service: scim-server
    environment: production
  fields_under_root: true
  multiline.pattern: '^\d{4}-\d{2}-\d{2}'
  multiline.negate: true
  multiline.match: after

output.elasticsearch:
  hosts: ["elasticsearch:9200"]
  template.settings:
    index.number_of_shards: 1
    index.number_of_replicas: 1

processors:
- add_host_metadata:
    when.not.contains.tags: forwarded
- decode_json_fields:
    fields: ["message"]
    target: "json"
    overwrite_keys: true
</code></pre>
<h3 id="logstash-processing"><a class="header" href="#logstash-processing">Logstash Processing</a></h3>
<pre><code class="language-ruby"># Logstash pipeline configuration
input {
  beats {
    port =&gt; 5044
  }
}

filter {
  if [service] == "scim-server" {
    json {
      source =&gt; "message"
    }
    
    # Parse timestamp
    date {
      match =&gt; [ "timestamp", "ISO8601" ]
    }
    
    # Extract tenant information
    if [tenant_id] {
      mutate {
        add_field =&gt; { "[@metadata][tenant]" =&gt; "%{tenant_id}" }
      }
    }
    
    # Classify log types
    if [target] == "audit" {
      mutate {
        add_tag =&gt; [ "audit" ]
        add_field =&gt; { "log_type" =&gt; "audit" }
      }
    } else if [level] == "ERROR" {
      mutate {
        add_tag =&gt; [ "error" ]
        add_field =&gt; { "log_type" =&gt; "error" }
      }
    }
    
    # Sanitize sensitive data
    mutate {
      remove_field =&gt; [ "password", "token", "authorization" ]
    }
  }
}

output {
  elasticsearch {
    hosts =&gt; ["elasticsearch:9200"]
    index =&gt; "scim-server-%{+YYYY.MM.dd}"
    template_overwrite =&gt; true
    template_pattern =&gt; "scim-server-*"
    template =&gt; "/etc/logstash/templates/scim-server.json"
  }
}
</code></pre>
<h3 id="kibana-visualizations"><a class="header" href="#kibana-visualizations">Kibana Visualizations</a></h3>
<pre><code class="language-json">{
  "objects": [
    {
      "id": "scim-error-analysis",
      "type": "visualization",
      "attributes": {
        "title": "Error Analysis",
        "visState": {
          "type": "histogram",
          "params": {
            "grid": { "categoryLines": false, "style": { "color": "#eee" } },
            "categoryAxes": [{ "id": "CategoryAxis-1", "type": "category", "position": "bottom", "show": true, "style": {}, "scale": { "type": "linear" }, "labels": { "show": true, "truncate": 100 }, "title": {} }],
            "valueAxes": [{ "id": "ValueAxis-1", "name": "LeftAxis-1", "type": "value", "position": "left", "show": true, "style": {}, "scale": { "type": "linear", "mode": "normal" }, "labels": { "show": true, "rotate": 0, "filter": false, "truncate": 100 }, "title": { "text": "Count" } }]
          },
          "aggs": [
            { "id": "1", "enabled": true, "type": "count", "schema": "metric", "params": {} },
            { "id": "2", "enabled": true, "type": "terms", "schema": "segment", "params": { "field": "error_type.keyword", "size": 10, "order": "desc", "orderBy": "1" } }
          ]
        },
        "uiStateJSON": "{}",
        "description": "",
        "version": 1,
        "kibanaSavedObjectMeta": {
          "searchSourceJSON": {
            "index": "scim-server-*",
            "query": {
              "match": { "level": "ERROR" }
            }
          }
        }
      }
    }
  ]
}
</code></pre>
<h2 id="performance-monitoring-1"><a class="header" href="#performance-monitoring-1">Performance Monitoring</a></h2>
<h3 id="application-performance-monitoring-apm"><a class="header" href="#application-performance-monitoring-apm">Application Performance Monitoring (APM)</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::apm::{ApmAgent, TransactionType, SpanType};

pub struct ApmAgent {
    elastic_apm: elastic_apm::Agent,
    config: ApmConfig,
}

impl ApmAgent {
    pub async fn trace_operation&lt;F, T&gt;(
        &amp;self,
        operation_name: &amp;str,
        transaction_type: TransactionType,
        operation: F,
    ) -&gt; Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;
    where
        F: Future&lt;Output = Result&lt;T, Box&lt;dyn std::error::Error&gt;&gt;&gt;,
    {
        let transaction = self.elastic_apm.begin_transaction(
            operation_name,
            transaction_type.as_str(),
        );
        
        let start_time = Instant::now();
        let result = operation.await;
        let duration = start_time.elapsed();
        
        match &amp;result {
            Ok(_) =&gt; {
                transaction.set_result("success");
                transaction.set_outcome(elastic_apm::Outcome::Success);
            }
            Err(e) =&gt; {
                transaction.set_result("error");
                transaction.set_outcome(elastic_apm::Outcome::Failure);
                transaction.capture_error(e);
            }
        }
        
        transaction.set_custom_context("performance", json!({
            "duration_ms": duration.as_millis(),
            "operation": operation_name,
        }));
        
        transaction.end();
        result
    }
    
    pub fn create_span&lt;F, T&gt;(
        &amp;self,
        span_name: &amp;str,
        span_type: SpanType,
        operation: F,
    ) -&gt; T
    where
        F: FnOnce() -&gt; T,
    {
        let span = self.elastic_apm.begin_span(span_name, span_type.as_str());
        let result = operation();
        span.end();
        result
    }
}

// Usage in request handlers
#[axum::debug_handler]
async fn create_user_handler(
    State(app_state): State&lt;AppState&gt;,
    Json(user_data): Json&lt;CreateUserRequest&gt;,
) -&gt; Result&lt;Json&lt;User&gt;, ScimError&gt; {
    app_state.apm.trace_operation(
        "create_user",
        TransactionType::Request,
        async {
            let user = app_state.scim_server
                .create_user(&amp;user_data.tenant_id, user_data)
                .await?;
            Ok(Json(user))
        }
    ).await
}
<span class="boring">}</span></code></pre></pre>
<h3 id="database-performance-monitoring"><a class="header" href="#database-performance-monitoring">Database Performance Monitoring</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sqlx::{query, Pool, Postgres};
use tracing::{instrument, Span};

pub struct DatabaseMonitor {
    pool: Pool&lt;Postgres&gt;,
    metrics: DatabaseMetrics,
}

impl DatabaseMonitor {
    #[instrument(skip(self, query_str, params))]
    pub async fn execute_monitored_query&lt;T&gt;(
        &amp;self,
        query_str: &amp;str,
        params: &amp;[&amp;dyn sqlx::Type&lt;Postgres&gt;],
    ) -&gt; Result&lt;T, sqlx::Error&gt;
    where
        T: for&lt;'r&gt; sqlx::FromRow&lt;'r, sqlx::postgres::PgRow&gt; + Send + Unpin,
    {
        let span = Span::current();
        let start_time = Instant::now();
        
        // Record query details (sanitized)
        span.record("db.statement", &amp;sanitize_query(query_str));
        span.record("db.operation", &amp;extract_operation(query_str));
        
        // Execute query
        let result = sqlx::query_as::&lt;_, T&gt;(query_str)
            .fetch_all(&amp;self.pool)
            .await;
        
        let duration = start_time.elapsed();
        
        // Record metrics
        match &amp;result {
            Ok(rows) =&gt; {
                span.record("db.rows_affected", &amp;rows.len());
                span.record("db.duration_ms", &amp;duration.as_millis());
                self.metrics.query_duration.observe(duration.as_secs_f64());
                self.metrics.query_success.inc();
            }
            Err(e) =&gt; {
                span.record("db.error", &amp;e.to_string());
                span.record("db.duration_ms", &amp;duration.as_millis());
                self.metrics.query_errors.inc();
                warn!("Database query failed: {}", e);
            }
        }
        
        // Alert on slow queries
        if duration &gt; Duration::from_millis(1000) {
            warn!(
                duration_ms = duration.as_millis(),
                query = sanitize_query(query_str),
                "Slow database query detected"
            );
        }
        
        result
    }
}

fn sanitize_query(query: &amp;str) -&gt; String {
    // Remove sensitive data from query for logging
    query
        .replace(|c: char| c.is_numeric(), "?")
        .replace("'.*?'", "'?'")
}
<span class="boring">}</span></code></pre></pre>
<h2 id="observability-best-practices"><a class="header" href="#observability-best-practices">Observability Best Practices</a></h2>
<h3 id="correlation-and-context"><a class="header" href="#correlation-and-context">Correlation and Context</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use uuid::Uuid;
use tracing_subscriber::layer::SubscriberExt;

// Request correlation
#[derive(Clone)]
pub struct RequestContext {
    pub request_id: Uuid,
    pub tenant_id: Option&lt;String&gt;,
    pub user_id: Option&lt;String&gt;,
    pub session_id: Option&lt;String&gt;,
    pub ip_address: IpAddr,
    pub user_agent: Option&lt;String&gt;,
}

impl RequestContext {
    pub fn new(headers: &amp;HeaderMap, remote_addr: SocketAddr) -&gt; Self {
        let request_id = headers
            .get("x-request-id")
            .and_then(|h| h.to_str().ok())
            .and_then(|s| Uuid::parse_str(s).ok())
            .unwrap_or_else(Uuid::new_v4);
        
        Self {
            request_id,
            tenant_id: headers.get("x-tenant-id")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
            user_id: None, // Set after authentication
            session_id: None, // Set after authentication
            ip_address: remote_addr.ip(),
            user_agent: headers.get("user-agent")
                .and_then(|h| h.to_str().ok())
                .map(String::from),
        }
    }
    
    pub fn create_span(&amp;self, operation: &amp;str) -&gt; tracing::Span {
        tracing::info_span!(
            "scim_operation",
            operation = operation,
            request_id = %self.request_id,
            tenant_id = %self.tenant_id.as_deref().unwrap_or("unknown"),
            user_id = %self.user_id.as_deref().unwrap_or("anonymous"),
            ip_address = %self.ip_address,
        )
    }
}

// Middleware for request correlation
pub async fn correlation_middleware(
    ConnectInfo(addr): ConnectInfo&lt;SocketAddr&gt;,
    mut req: Request&lt;Body&gt;,
    next: Next&lt;Body&gt;,
) -&gt; Response&lt;Body&gt; {
    let context = RequestContext::new(req.headers(), addr);
    
    // Add context to request extensions
    req.extensions_mut().insert(context.clone());
    
    // Create request span
    let span = context.create_span("http_request");
    let _guard = span.enter();
    
    // Add request ID to response headers
    let mut response = next.run(req).await;
    response.headers_mut().insert(
        "x-request-id",
        HeaderValue::from_str(&amp;context.request_id.to_string()).unwrap(),
    );
    
    response
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-tracking-integration"><a class="header" href="#error-tracking-integration">Error Tracking Integration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sentry::{ClientOptions, integrations::tracing::EventFilter};

pub fn setup_error_tracking() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let _guard = sentry::init((
        std::env::var("SENTRY_DSN")?,
        ClientOptions {
            release: Some(env!("CARGO_PKG_VERSION").into()),
            environment: Some(std::env::var("ENVIRONMENT").unwrap_or("unknown".into()).into()),
            sample_rate: 1.0,
            traces_sample_rate: 0.1,
            ..Default::default()
        },
    ));
    
    // Configure tracing integration
    tracing_subscriber::registry()
        .with(tracing_subscriber::EnvFilter::new("scim_server=info"))
        .with(tracing_subscriber::fmt::layer())
        .with(sentry_tracing::layer().event_filter(|md| {
            match md.level() {
                &amp;tracing::Level::ERROR =&gt; EventFilter::Event,
                &amp;tracing::Level::WARN =&gt; EventFilter::Breadcrumb,
                _ =&gt; EventFilter::Ignore,
            }
        }))
        .init();
    
    Ok(())
}

// Custom error reporting
pub async fn report_error(
    error: &amp;dyn std::error::Error,
    context: &amp;RequestContext,
    additional_data: Option&lt;serde_json::Value&gt;,
) {
    sentry::with_scope(|scope| {
        scope.set_tag("request_id", &amp;context.request_id.to_string());
        scope.set_tag("tenant_id", context.tenant_id.as_deref().unwrap_or("unknown"));
        scope.set_user(Some(sentry::User {
            id: context.user_id.clone(),
            ip_address: Some(context.ip_address.to_string()),
            ..Default::default()
        }));
        
        if let Some(data) = additional_data {
            scope.set_context("additional_data", sentry::protocol::Context::Other(data.into()));
        }
        
        sentry::capture_error(error);
    });
}
<span class="boring">}</span></code></pre></pre>
<p>This comprehensive monitoring and observability guide provides the foundation for operating SCIM servers with full visibility into performance, errors, and business metrics. Regular review and tuning of monitoring configurations ensure optimal system health and rapid incident response.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-endpoints"><a class="header" href="#api-endpoints">API Endpoints</a></h1>
<p>This reference documents all HTTP endpoints provided by the SCIM Server, including request/response formats, status codes, and example usage.</p>
<h2 id="base-url-structure"><a class="header" href="#base-url-structure">Base URL Structure</a></h2>
<p>All SCIM endpoints follow this pattern:</p>
<pre><code>https://your-server.com/scim/v2/{tenant-id}/{resource-type}
</code></pre>
<p><strong>Components</strong>:</p>
<ul>
<li><code>{tenant-id}</code>: Unique identifier for the tenant/organization</li>
<li><code>{resource-type}</code>: Resource type (Users, Groups, or custom resources)</li>
</ul>
<h2 id="standard-resource-endpoints"><a class="header" href="#standard-resource-endpoints">Standard Resource Endpoints</a></h2>
<h3 id="users-1"><a class="header" href="#users-1">Users</a></h3>
<h4 id="create-user"><a class="header" href="#create-user">Create User</a></h4>
<pre><code class="language-http">POST /scim/v2/{tenant-id}/Users
Content-Type: application/scim+json
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Johnson"
  },
  "emails": [
    {
      "value": "alice@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "active": true
}
</code></pre>
<p><strong>Response</strong> (201 Created):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "id": "2819c223-7f76-453a-919d-413861904646",
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Johnson"
  },
  "emails": [
    {
      "value": "alice@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "active": true,
  "meta": {
    "resourceType": "User",
    "created": "2023-12-01T10:30:00Z",
    "lastModified": "2023-12-01T10:30:00Z",
    "version": "W/\"1\"",
    "location": "https://api.example.com/scim/v2/tenant-1/Users/2819c223-7f76-453a-919d-413861904646"
  }
}
</code></pre>
<h4 id="get-user"><a class="header" href="#get-user">Get User</a></h4>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/Users/{id}
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "id": "2819c223-7f76-453a-919d-413861904646",
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice", 
    "familyName": "Johnson"
  },
  "emails": [
    {
      "value": "alice@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "active": true,
  "meta": {
    "resourceType": "User",
    "created": "2023-12-01T10:30:00Z",
    "lastModified": "2023-12-01T15:45:00Z",
    "version": "W/\"3\"",
    "location": "https://api.example.com/scim/v2/tenant-1/Users/2819c223-7f76-453a-919d-413861904646"
  }
}
</code></pre>
<h4 id="update-user-replace"><a class="header" href="#update-user-replace">Update User (Replace)</a></h4>
<pre><code class="language-http">PUT /scim/v2/{tenant-id}/Users/{id}
Content-Type: application/scim+json
If-Match: W/"3"
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "id": "2819c223-7f76-453a-919d-413861904646",
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Smith"
  },
  "emails": [
    {
      "value": "alice@example.com",
      "type": "work",
      "primary": true
    }
  ],
  "active": true,
  "meta": {
    "version": "W/\"3\""
  }
}
</code></pre>
<p><strong>Response</strong> (200 OK): Updated user resource with new version.</p>
<h4 id="update-user-partial"><a class="header" href="#update-user-partial">Update User (Partial)</a></h4>
<pre><code class="language-http">PATCH /scim/v2/{tenant-id}/Users/{id}
Content-Type: application/scim+json
If-Match: W/"3"
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    {
      "op": "replace",
      "path": "name.familyName",
      "value": "Smith"
    },
    {
      "op": "add",
      "path": "emails",
      "value": {
        "value": "alice.personal@example.com",
        "type": "home"
      }
    }
  ]
}
</code></pre>
<p><strong>Response</strong> (200 OK): Updated user resource.</p>
<h4 id="delete-user"><a class="header" href="#delete-user">Delete User</a></h4>
<pre><code class="language-http">DELETE /scim/v2/{tenant-id}/Users/{id}
If-Match: W/"3"
</code></pre>
<p><strong>Response</strong> (204 No Content): Empty body.</p>
<h4 id="list-users"><a class="header" href="#list-users">List Users</a></h4>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/Users
</code></pre>
<p><strong>Query Parameters</strong>:</p>
<ul>
<li><code>filter</code>: SCIM filter expression</li>
<li><code>sortBy</code>: Attribute to sort by</li>
<li><code>sortOrder</code>: <code>ascending</code> or <code>descending</code></li>
<li><code>startIndex</code>: 1-based index (default: 1)</li>
<li><code>count</code>: Number of results (default: 100, max: 1000)</li>
<li><code>attributes</code>: Comma-separated list of attributes to return</li>
<li><code>excludedAttributes</code>: Comma-separated list of attributes to exclude</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code class="language-http"># Filter by email
GET /scim/v2/tenant-1/Users?filter=emails.value eq "alice@example.com"

# Sort by last modified
GET /scim/v2/tenant-1/Users?sortBy=meta.lastModified&amp;sortOrder=descending

# Pagination
GET /scim/v2/tenant-1/Users?startIndex=51&amp;count=50

# Select specific attributes
GET /scim/v2/tenant-1/Users?attributes=userName,emails,active
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
  "totalResults": 150,
  "startIndex": 1,
  "itemsPerPage": 50,
  "Resources": [
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
      "id": "2819c223-7f76-453a-919d-413861904646",
      "userName": "alice@example.com",
      "name": {
        "givenName": "Alice",
        "familyName": "Johnson"
      },
      "active": true,
      "meta": {
        "resourceType": "User",
        "created": "2023-12-01T10:30:00Z",
        "lastModified": "2023-12-01T15:45:00Z",
        "version": "W/\"3\""
      }
    }
  ]
}
</code></pre>
<h3 id="groups-1"><a class="header" href="#groups-1">Groups</a></h3>
<h4 id="create-group"><a class="header" href="#create-group">Create Group</a></h4>
<pre><code class="language-http">POST /scim/v2/{tenant-id}/Groups
Content-Type: application/scim+json
</code></pre>
<p><strong>Request Body</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
  "displayName": "Engineering Team",
  "members": [
    {
      "value": "2819c223-7f76-453a-919d-413861904646",
      "$ref": "../Users/2819c223-7f76-453a-919d-413861904646",
      "type": "User",
      "display": "Alice Johnson"
    }
  ]
}
</code></pre>
<p><strong>Response</strong> (201 Created): Group resource with generated ID and metadata.</p>
<h4 id="get-group"><a class="header" href="#get-group">Get Group</a></h4>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/Groups/{id}
</code></pre>
<h4 id="update-group"><a class="header" href="#update-group">Update Group</a></h4>
<pre><code class="language-http">PUT /scim/v2/{tenant-id}/Groups/{id}
PATCH /scim/v2/{tenant-id}/Groups/{id}
</code></pre>
<h4 id="delete-group"><a class="header" href="#delete-group">Delete Group</a></h4>
<pre><code class="language-http">DELETE /scim/v2/{tenant-id}/Groups/{id}
</code></pre>
<h4 id="list-groups"><a class="header" href="#list-groups">List Groups</a></h4>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/Groups
</code></pre>
<p>Same query parameters and response format as Users.</p>
<h2 id="discovery-endpoints"><a class="header" href="#discovery-endpoints">Discovery Endpoints</a></h2>
<h3 id="service-provider-configuration"><a class="header" href="#service-provider-configuration">Service Provider Configuration</a></h3>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/ServiceProviderConfig
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig"],
  "documentationUri": "https://docs.example.com/scim",
  "patch": {
    "supported": true
  },
  "bulk": {
    "supported": true,
    "maxOperations": 1000,
    "maxPayloadSize": 1048576
  },
  "filter": {
    "supported": true,
    "maxResults": 1000
  },
  "changePassword": {
    "supported": false
  },
  "sort": {
    "supported": true
  },
  "etag": {
    "supported": true
  },
  "authenticationSchemes": [
    {
      "name": "OAuth Bearer Token",
      "description": "Authentication scheme using the OAuth Bearer Token Standard",
      "specUri": "http://www.rfc-editor.org/info/rfc6750",
      "documentationUri": "https://docs.example.com/auth",
      "type": "oauthbearertoken",
      "primary": true
    }
  ],
  "meta": {
    "resourceType": "ServiceProviderConfig",
    "created": "2023-12-01T00:00:00Z",
    "lastModified": "2023-12-01T00:00:00Z",
    "version": "W/\"1\""
  }
}
</code></pre>
<h3 id="resource-types"><a class="header" href="#resource-types">Resource Types</a></h3>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/ResourceTypes
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
  "totalResults": 2,
  "startIndex": 1,
  "itemsPerPage": 2,
  "Resources": [
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ResourceType"],
      "id": "User",
      "name": "User",
      "endpoint": "/Users",
      "description": "User Account",
      "schema": "urn:ietf:params:scim:schemas:core:2.0:User",
      "schemaExtensions": [
        {
          "schema": "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
          "required": false
        }
      ],
      "meta": {
        "resourceType": "ResourceType",
        "created": "2023-12-01T00:00:00Z",
        "lastModified": "2023-12-01T00:00:00Z",
        "version": "W/\"1\""
      }
    },
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ResourceType"],
      "id": "Group",
      "name": "Group",
      "endpoint": "/Groups",
      "description": "Group",
      "schema": "urn:ietf:params:scim:schemas:core:2.0:Group",
      "meta": {
        "resourceType": "ResourceType",
        "created": "2023-12-01T00:00:00Z",
        "lastModified": "2023-12-01T00:00:00Z",
        "version": "W/\"1\""
      }
    }
  ]
}
</code></pre>
<h3 id="schemas-1"><a class="header" href="#schemas-1">Schemas</a></h3>
<pre><code class="language-http">GET /scim/v2/{tenant-id}/Schemas
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
  "totalResults": 3,
  "startIndex": 1,
  "itemsPerPage": 3,
  "Resources": [
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Schema"],
      "id": "urn:ietf:params:scim:schemas:core:2.0:User",
      "name": "User",
      "description": "User Account",
      "attributes": [
        {
          "name": "userName",
          "type": "string",
          "multiValued": false,
          "description": "Unique identifier for the User",
          "required": true,
          "caseExact": false,
          "mutability": "readWrite",
          "returned": "default",
          "uniqueness": "server"
        }
      ],
      "meta": {
        "resourceType": "Schema",
        "created": "2023-12-01T00:00:00Z",
        "lastModified": "2023-12-01T00:00:00Z",
        "version": "W/\"1\""
      }
    }
  ]
}
</code></pre>
<h2 id="bulk-operations-2"><a class="header" href="#bulk-operations-2">Bulk Operations</a></h2>
<blockquote>
<p><strong>⚠️ Implementation Status</strong>: Bulk operations are <strong>not yet implemented</strong> in this library.</p>
</blockquote>
<h3 id="future-bulk-endpoint-not-available"><a class="header" href="#future-bulk-endpoint-not-available">Future Bulk Endpoint (Not Available)</a></h3>
<pre><code class="language-http">POST /scim/v2/{tenant-id}/Bulk
Content-Type: application/scim+json
</code></pre>
<p><strong>Current Alternative</strong>: Use individual API calls for each operation.</p>
<p><strong>Example</strong>: Creating multiple users sequentially:</p>
<pre><code class="language-http">POST /scim/v2/{tenant-id}/Users
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "alice@example.com",
  "name": {
    "givenName": "Alice",
    "familyName": "Johnson"
  }
}
</code></pre>
<pre><code class="language-http">POST /scim/v2/{tenant-id}/Users
Content-Type: application/scim+json

{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
  "userName": "bob@example.com",
  "name": {
    "givenName": "Bob",
    "familyName": "Smith"
  }
}
</code></pre>
<p><strong>Future Bulk Request Format</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:BulkRequest"],
  "Operations": [
    {
      "method": "POST",
      "path": "/Users",
      "bulkId": "qwerty",
      "data": {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "userName": "alice@example.com"
      }
    }
  ]
}
</code></pre>
<p><strong>Response</strong> (200 OK):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:BulkResponse"],
  "Operations": [
    {
      "method": "POST",
      "path": "/Users",
      "bulkId": "qwerty",
      "status": "201",
      "location": "https://api.example.com/scim/v2/tenant-1/Users/92b725cd-9465-4e7d-8c16-01f8e146b87a",
      "response": {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:User"],
        "id": "92b725cd-9465-4e7d-8c16-01f8e146b87a",
        "userName": "alice@example.com",
        "name": {
          "givenName": "Alice",
          "familyName": "Johnson"
        },
        "meta": {
          "resourceType": "User",
          "created": "2023-12-01T16:30:00Z",
          "lastModified": "2023-12-01T16:30:00Z",
          "version": "W/\"1\""
        }
      }
    },
    {
      "method": "POST",
      "path": "/Groups",
      "bulkId": "ytrewq",
      "status": "201",
      "location": "https://api.example.com/scim/v2/tenant-1/Groups/e9e30dba-f08f-4109-8486-d5c6a331660a",
      "response": {
        "schemas": ["urn:ietf:params:scim:schemas:core:2.0:Group"],
        "id": "e9e30dba-f08f-4109-8486-d5c6a331660a",
        "displayName": "Administrators",
        "members": [
          {
            "value": "92b725cd-9465-4e7d-8c16-01f8e146b87a",
            "$ref": "../Users/92b725cd-9465-4e7d-8c16-01f8e146b87a",
            "type": "User",
            "display": "Alice Johnson"
          }
        ],
        "meta": {
          "resourceType": "Group",
          "created": "2023-12-01T16:30:00Z",
          "lastModified": "2023-12-01T16:30:00Z",
          "version": "W/\"1\""
        }
      }
    }
  ]
}
</code></pre>
<h2 id="filter-expressions"><a class="header" href="#filter-expressions">Filter Expressions</a></h2>
<p>SCIM supports rich filtering using a SQL-like syntax:</p>
<h3 id="basic-operators"><a class="header" href="#basic-operators">Basic Operators</a></h3>
<ul>
<li><code>eq</code> - Equal</li>
<li><code>ne</code> - Not equal</li>
<li><code>co</code> - Contains</li>
<li><code>sw</code> - Starts with</li>
<li><code>ew</code> - Ends with</li>
<li><code>gt</code> - Greater than</li>
<li><code>ge</code> - Greater than or equal</li>
<li><code>lt</code> - Less than</li>
<li><code>le</code> - Less than or equal</li>
<li><code>pr</code> - Present (has value)</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><code class="language-http"># Exact match
GET /Users?filter=userName eq "alice@example.com"

# Contains
GET /Users?filter=name.givenName co "Ali"

# Starts with
GET /Users?filter=userName sw "alice"

# Date comparison
GET /Users?filter=meta.lastModified gt "2023-01-01T00:00:00Z"

# Present check
GET /Users?filter=emails pr

# Complex expressions
GET /Users?filter=active eq true and (emails.type eq "work" or emails.type eq "primary")

# Nested attributes
GET /Users?filter=emails[type eq "work" and primary eq true].value eq "alice@work.com"
</code></pre>
<h3 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h3>
<ul>
<li><code>and</code> - Logical AND</li>
<li><code>or</code> - Logical OR</li>
<li><code>not</code> - Logical NOT</li>
</ul>
<h3 id="grouping"><a class="header" href="#grouping">Grouping</a></h3>
<p>Use parentheses for complex expressions:</p>
<pre><code class="language-http">GET /Users?filter=(name.givenName eq "Alice" or name.givenName eq "Bob") and active eq true
</code></pre>
<h2 id="http-status-codes"><a class="header" href="#http-status-codes">HTTP Status Codes</a></h2>
<h3 id="success-codes"><a class="header" href="#success-codes">Success Codes</a></h3>
<ul>
<li><code>200 OK</code> - Successful GET, PUT, PATCH</li>
<li><code>201 Created</code> - Successful POST</li>
<li><code>204 No Content</code> - Successful DELETE</li>
<li><code>304 Not Modified</code> - Resource not modified (when using If-None-Match)</li>
</ul>
<h3 id="client-error-codes"><a class="header" href="#client-error-codes">Client Error Codes</a></h3>
<ul>
<li><code>400 Bad Request</code> - Invalid request syntax</li>
<li><code>401 Unauthorized</code> - Authentication required</li>
<li><code>403 Forbidden</code> - Insufficient permissions</li>
<li><code>404 Not Found</code> - Resource not found</li>
<li><code>409 Conflict</code> - Resource conflict (duplicate)</li>
<li><code>412 Precondition Failed</code> - ETag mismatch</li>
<li><code>413 Payload Too Large</code> - Request body too large</li>
<li><code>422 Unprocessable Entity</code> - Validation error</li>
</ul>
<h3 id="server-error-codes"><a class="header" href="#server-error-codes">Server Error Codes</a></h3>
<ul>
<li><code>500 Internal Server Error</code> - Server error</li>
<li><code>501 Not Implemented</code> - Feature not supported</li>
<li><code>503 Service Unavailable</code> - Server temporarily unavailable</li>
</ul>
<h2 id="error-response-format-1"><a class="header" href="#error-response-format-1">Error Response Format</a></h2>
<p>All errors follow the SCIM error response format:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidFilter",
  "detail": "The specified filter syntax is invalid: unexpected token 'eq' at position 5"
}
</code></pre>
<h3 id="scim-error-types"><a class="header" href="#scim-error-types">SCIM Error Types</a></h3>
<ul>
<li><code>invalidFilter</code> - Malformed filter expression</li>
<li><code>tooMany</code> - Query returned too many results</li>
<li><code>uniqueness</code> - Unique constraint violation</li>
<li><code>mutability</code> - Attempt to modify read-only attribute</li>
<li><code>invalidSyntax</code> - Malformed JSON or request</li>
<li><code>invalidPath</code> - Invalid attribute path in PATCH</li>
<li><code>noTarget</code> - PATCH target not found</li>
<li><code>invalidValue</code> - Invalid attribute value</li>
<li><code>invalidVers</code> - Invalid version in If-Match header</li>
<li><code>sensitive</code> - Cannot return sensitive attribute</li>
</ul>
<h2 id="headers"><a class="header" href="#headers">Headers</a></h2>
<h3 id="request-headers-1"><a class="header" href="#request-headers-1">Request Headers</a></h3>
<ul>
<li><code>Content-Type: application/scim+json</code> - Required for POST/PUT/PATCH</li>
<li><code>Authorization: Bearer &lt;token&gt;</code> - Authentication token</li>
<li><code>If-Match: W/"&lt;version&gt;"</code> - Conditional update</li>
<li><code>If-None-Match: W/"&lt;version&gt;"</code> - Conditional get</li>
</ul>
<h3 id="response-headers-1"><a class="header" href="#response-headers-1">Response Headers</a></h3>
<ul>
<li><code>Content-Type: application/scim+json</code> - SCIM JSON response</li>
<li><code>ETag: W/"&lt;version&gt;"</code> - Resource version</li>
<li><code>Location: &lt;url&gt;</code> - URL of created resource (201 responses)</li>
</ul>
<h2 id="custom-resource-endpoints"><a class="header" href="#custom-resource-endpoints">Custom Resource Endpoints</a></h2>
<p>Custom resources follow the same patterns:</p>
<pre><code class="language-http"># Custom Device resource
GET /scim/v2/{tenant-id}/Devices
POST /scim/v2/{tenant-id}/Devices
GET /scim/v2/{tenant-id}/Devices/{id}
PUT /scim/v2/{tenant-id}/Devices/{id}
PATCH /scim/v2/{tenant-id}/Devices/{id}
DELETE /scim/v2/{tenant-id}/Devices/{id}
</code></pre>
<h2 id="rate-limiting-2"><a class="header" href="#rate-limiting-2">Rate Limiting</a></h2>
<p>The server may implement rate limiting with these headers:</p>
<h3 id="response-headers-2"><a class="header" href="#response-headers-2">Response Headers</a></h3>
<ul>
<li><code>X-RateLimit-Limit</code> - Requests per time window</li>
<li><code>X-RateLimit-Remaining</code> - Remaining requests</li>
<li><code>X-RateLimit-Reset</code> - Unix timestamp when limit resets</li>
</ul>
<h3 id="rate-limit-exceeded"><a class="header" href="#rate-limit-exceeded">Rate Limit Exceeded</a></h3>
<pre><code class="language-http">HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1699123200

{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "429",
  "detail": "Rate limit exceeded. Try again in 60 seconds."
}
</code></pre>
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<h3 id="efficient-queries"><a class="header" href="#efficient-queries">Efficient Queries</a></h3>
<ul>
<li>Use specific filters instead of retrieving all resources</li>
<li>Use pagination for large result sets</li>
<li>Request only needed attributes with <code>attributes</code> parameter</li>
<li>Use ETag headers for caching and concurrency control</li>
</ul>
<h3 id="bulk-operations-3"><a class="header" href="#bulk-operations-3">Bulk Operations</a></h3>
<ul>
<li>Use bulk operations for multiple changes</li>
<li>Use pagination for large result sets with <code>count</code> and <code>startIndex</code> parameters</li>
<li>Implement retry logic for individual failed operations</li>
</ul>
<h3 id="error-handling-13"><a class="header" href="#error-handling-13">Error Handling</a></h3>
<ul>
<li>Check response status codes</li>
<li>Parse SCIM error responses for detailed error information</li>
<li>Implement retry logic for transient errors (5xx codes)</li>
<li>Use exponential backoff for rate limiting</li>
</ul>
<h3 id="security"><a class="header" href="#security">Security</a></h3>
<ul>
<li>Always use HTTPS in production</li>
<li>Include proper Authorization headers</li>
<li>Validate all input data</li>
<li>Handle authentication errors gracefully</li>
</ul>
<p>This comprehensive API reference covers all standard SCIM endpoints and patterns. For implementation examples, see the <a href="reference/../tutorials/framework-integration.html">Framework Integration</a> tutorial.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-codes"><a class="header" href="#error-codes">Error Codes</a></h1>
<p>This reference documents all error codes that the SCIM Server library can generate, their meanings, causes, and recommended responses.</p>
<h2 id="error-response-format-2"><a class="header" href="#error-response-format-2">Error Response Format</a></h2>
<p>All SCIM errors follow the standard SCIM 2.0 error response format:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidFilter",
  "detail": "The specified filter syntax is invalid: unexpected token 'and' at position 15"
}
</code></pre>
<h3 id="error-response-fields"><a class="header" href="#error-response-fields">Error Response Fields</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>schemas</code></td><td>Array</td><td>Always contains the SCIM error schema</td></tr>
<tr><td><code>status</code></td><td>String</td><td>HTTP status code as a string</td></tr>
<tr><td><code>scimType</code></td><td>String</td><td>SCIM-specific error type (optional)</td></tr>
<tr><td><code>detail</code></td><td>String</td><td>Human-readable error description</td></tr>
</tbody></table>
</div>
<h2 id="http-status-codes-1"><a class="header" href="#http-status-codes-1">HTTP Status Codes</a></h2>
<h3 id="400-bad-request"><a class="header" href="#400-bad-request">400 Bad Request</a></h3>
<p><strong>When</strong>: The request is malformed or contains invalid data.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Invalid JSON syntax</li>
<li>Missing required fields</li>
<li>Invalid field values</li>
<li>Malformed filter expressions</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidSyntax",
  "detail": "Request body contains invalid JSON: expected ',' or '}' at line 3 column 15"
}
</code></pre>
<h3 id="401-unauthorized"><a class="header" href="#401-unauthorized">401 Unauthorized</a></h3>
<p><strong>When</strong>: Authentication is required but missing or invalid.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Missing Authorization header</li>
<li>Invalid credentials</li>
<li>Expired tokens</li>
<li>Malformed authentication headers</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "401",
  "detail": "Authentication required: missing or invalid Authorization header"
}
</code></pre>
<h3 id="403-forbidden"><a class="header" href="#403-forbidden">403 Forbidden</a></h3>
<p><strong>When</strong>: Authentication succeeded but authorization failed.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Insufficient permissions for the operation</li>
<li>Tenant isolation violations</li>
<li>Read-only attribute modification attempts</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "403",
  "detail": "Insufficient permissions: cannot modify users in tenant 'production'"
}
</code></pre>
<h3 id="404-not-found"><a class="header" href="#404-not-found">404 Not Found</a></h3>
<p><strong>When</strong>: The requested resource doesn't exist.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Invalid resource ID</li>
<li>Resource was deleted</li>
<li>Incorrect endpoint path</li>
<li>Wrong tenant context</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "404",
  "detail": "User with ID '123e4567-e89b-12d3-a456-426614174000' not found"
}
</code></pre>
<h3 id="409-conflict"><a class="header" href="#409-conflict">409 Conflict</a></h3>
<p><strong>When</strong>: The operation conflicts with the current state.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Duplicate unique values (usernames, emails)</li>
<li>Circular group memberships</li>
<li>Resource already exists</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "409",
  "scimType": "uniqueness",
  "detail": "User with userName 'jdoe@example.com' already exists"
}
</code></pre>
<h3 id="412-precondition-failed"><a class="header" href="#412-precondition-failed">412 Precondition Failed</a></h3>
<p><strong>When</strong>: ETag-based concurrency control detects a conflict.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Resource was modified by another client</li>
<li>Missing or invalid If-Match header</li>
<li>Concurrent updates</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "412",
  "detail": "Resource was modified: expected ETag 'W/\"abc123\"' but found 'W/\"def456\"'"
}
</code></pre>
<h3 id="413-payload-too-large"><a class="header" href="#413-payload-too-large">413 Payload Too Large</a></h3>
<p><strong>When</strong>: The request body exceeds size limits.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Large bulk operations</li>
<li>Excessive user attributes</li>
<li>Large file uploads</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "413",
  "detail": "Request body size 5242880 bytes exceeds maximum allowed size of 1048576 bytes"
}
</code></pre>
<h3 id="429-too-many-requests"><a class="header" href="#429-too-many-requests">429 Too Many Requests</a></h3>
<p><strong>When</strong>: Rate limiting is triggered.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Exceeding API rate limits</li>
<li>Too many concurrent requests</li>
<li>Bulk operation limits</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "429",
  "detail": "Rate limit exceeded: maximum 100 requests per minute, retry after 60 seconds"
}
</code></pre>
<h3 id="500-internal-server-error"><a class="header" href="#500-internal-server-error">500 Internal Server Error</a></h3>
<p><strong>When</strong>: An unexpected server error occurs.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Database connection failures</li>
<li>Unhandled exceptions</li>
<li>Configuration errors</li>
<li>Provider implementation bugs</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "500",
  "detail": "Internal server error: database connection timeout"
}
</code></pre>
<h3 id="501-not-implemented"><a class="header" href="#501-not-implemented">501 Not Implemented</a></h3>
<p><strong>When</strong>: The requested feature is not supported.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Optional SCIM features not implemented</li>
<li>Unsupported operations</li>
<li>Missing provider functionality</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "501",
  "detail": "Bulk operations are not supported by this provider"
}
</code></pre>
<h3 id="503-service-unavailable"><a class="header" href="#503-service-unavailable">503 Service Unavailable</a></h3>
<p><strong>When</strong>: The service is temporarily unavailable.</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Database maintenance</li>
<li>System overload</li>
<li>Temporary outages</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "503",
  "detail": "Service temporarily unavailable: scheduled maintenance in progress"
}
</code></pre>
<h2 id="scim-error-types-1"><a class="header" href="#scim-error-types-1">SCIM Error Types</a></h2>
<p>SCIM defines specific error types in the <code>scimType</code> field for more precise error categorization:</p>
<h3 id="invalidfilter"><a class="header" href="#invalidfilter">invalidFilter</a></h3>
<p><strong>Description</strong>: Filter expression syntax is invalid.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Malformed filter syntax</li>
<li>Unknown attributes in filter</li>
<li>Invalid operators</li>
<li>Missing quotes or parentheses</li>
</ul>
<p><strong>Examples</strong>:</p>
<pre><code># Invalid operator
filter=userName xyz "john"

# Missing quotes
filter=userName eq john@example.com

# Unknown attribute
filter=unknownField eq "value"
</code></pre>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidFilter",
  "detail": "Invalid filter expression: unknown operator 'xyz' at position 9"
}
</code></pre>
<h3 id="toomany"><a class="header" href="#toomany">tooMany</a></h3>
<p><strong>Description</strong>: Query returned too many results.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Query without sufficient filtering</li>
<li>Missing pagination parameters</li>
<li>Large datasets without limits</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "tooMany",
  "detail": "Query returned 50000 results, maximum allowed is 10000. Use pagination or add filters."
}
</code></pre>
<h3 id="uniqueness"><a class="header" href="#uniqueness">uniqueness</a></h3>
<p><strong>Description</strong>: Unique constraint violation.</p>
<p><strong>HTTP Status</strong>: 409</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Duplicate usernames</li>
<li>Duplicate email addresses</li>
<li>Duplicate external IDs</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "409",
  "scimType": "uniqueness",
  "detail": "Email address 'user@example.com' is already in use by another user"
}
</code></pre>
<h3 id="mutability"><a class="header" href="#mutability">mutability</a></h3>
<p><strong>Description</strong>: Attempt to modify a read-only attribute.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Modifying <code>id</code> field</li>
<li>Changing <code>meta.created</code> timestamp</li>
<li>Updating immutable custom attributes</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "mutability",
  "detail": "Attribute 'id' is immutable and cannot be modified"
}
</code></pre>
<h3 id="invalidsyntax"><a class="header" href="#invalidsyntax">invalidSyntax</a></h3>
<p><strong>Description</strong>: Request syntax is invalid.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Malformed JSON</li>
<li>Invalid attribute names</li>
<li>Wrong data types</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidSyntax",
  "detail": "Invalid JSON syntax: unexpected token '}' at line 5 column 1"
}
</code></pre>
<h3 id="invalidpath"><a class="header" href="#invalidpath">invalidPath</a></h3>
<p><strong>Description</strong>: PATCH operation path is invalid.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Malformed JSON Path expressions</li>
<li>Paths to non-existent attributes</li>
<li>Invalid array indices</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidPath",
  "detail": "Invalid patch path: 'emails[type eq \"work\"].value' - array filter not supported"
}
</code></pre>
<h3 id="invalidvalue"><a class="header" href="#invalidvalue">invalidValue</a></h3>
<p><strong>Description</strong>: Attribute value doesn't meet validation requirements.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Invalid email format</li>
<li>Password doesn't meet complexity requirements</li>
<li>Enum values not in allowed list</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidValue",
  "detail": "Invalid email format: 'not-an-email' is not a valid email address"
}
</code></pre>
<h3 id="invalidvers"><a class="header" href="#invalidvers">invalidVers</a></h3>
<p><strong>Description</strong>: Version-related error in bulk operations.</p>
<p><strong>HTTP Status</strong>: 412</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>ETag mismatches in bulk operations</li>
<li>Version conflicts</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "412",
  "scimType": "invalidVers",
  "detail": "Version conflict in bulk operation: resource was modified"
}
</code></pre>
<h3 id="sensitive"><a class="header" href="#sensitive">sensitive</a></h3>
<p><strong>Description</strong>: Request contains sensitive information that cannot be processed.</p>
<p><strong>HTTP Status</strong>: 403</p>
<p><strong>Common Causes</strong>:</p>
<ul>
<li>Accessing password attributes</li>
<li>Retrieving sensitive security information</li>
</ul>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "403",
  "scimType": "sensitive",
  "detail": "Cannot retrieve sensitive attribute: password"
}
</code></pre>
<h2 id="library-specific-error-codes"><a class="header" href="#library-specific-error-codes">Library-Specific Error Codes</a></h2>
<p>These errors are specific to the SCIM Server library implementation:</p>
<h3 id="tenantnotfound"><a class="header" href="#tenantnotfound">TenantNotFound</a></h3>
<p><strong>Description</strong>: Specified tenant does not exist.</p>
<p><strong>HTTP Status</strong>: 404</p>
<p><strong>Rust Error</strong>: <code>ScimError::TenantNotFound</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "404",
  "detail": "Tenant 'acme-corp' not found"
}
</code></pre>
<h3 id="providererror"><a class="header" href="#providererror">ProviderError</a></h3>
<p><strong>Description</strong>: Storage provider encountered an error.</p>
<p><strong>HTTP Status</strong>: 500</p>
<p><strong>Rust Error</strong>: <code>ScimError::ProviderError</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "500",
  "detail": "Provider error: database connection failed"
}
</code></pre>
<h3 id="validationerror-1"><a class="header" href="#validationerror-1">ValidationError</a></h3>
<p><strong>Description</strong>: Custom validation failed.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Rust Error</strong>: <code>ScimError::ValidationError</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidValue",
  "detail": "Custom validation failed: employee ID must be 6 digits"
}
</code></pre>
<h3 id="serializationerror"><a class="header" href="#serializationerror">SerializationError</a></h3>
<p><strong>Description</strong>: JSON serialization/deserialization failed.</p>
<p><strong>HTTP Status</strong>: 400</p>
<p><strong>Rust Error</strong>: <code>ScimError::SerializationError</code></p>
<p><strong>Response</strong>:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "400",
  "scimType": "invalidSyntax",
  "detail": "JSON parsing error: missing field 'userName' at line 3"
}
</code></pre>
<h2 id="error-handling-best-practices"><a class="header" href="#error-handling-best-practices">Error Handling Best Practices</a></h2>
<h3 id="for-api-clients"><a class="header" href="#for-api-clients">For API Clients</a></h3>
<ol>
<li><strong>Always check HTTP status codes</strong> before processing responses</li>
<li><strong>Parse the <code>scimType</code> field</strong> for specific error handling</li>
<li><strong>Log the <code>detail</code> field</strong> for debugging purposes</li>
<li><strong>Implement retry logic</strong> for 429, 500, 502, 503 status codes</li>
<li><strong>Handle 412 errors</strong> by refetching the resource and retrying</li>
</ol>
<h3 id="for-server-implementations"><a class="header" href="#for-server-implementations">For Server Implementations</a></h3>
<ol>
<li><strong>Provide detailed error messages</strong> without exposing sensitive information</li>
<li><strong>Use appropriate HTTP status codes</strong> for different error types</li>
<li><strong>Include SCIM error types</strong> when applicable</li>
<li><strong>Log errors server-side</strong> for monitoring and debugging</li>
<li><strong>Sanitize error details</strong> to prevent information leakage</li>
</ol>
<h3 id="example-error-handling"><a class="header" href="#example-error-handling">Example Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimError, ScimResult};

async fn handle_user_creation(user_data: Value) -&gt; ScimResult&lt;User&gt; {
    match create_user(user_data).await {
        Ok(user) =&gt; Ok(user),
        Err(ScimError::ValidationError { field, message }) =&gt; {
            Err(ScimError::BadRequest {
                scim_type: Some("invalidValue".to_string()),
                detail: format!("Validation failed for field '{}': {}", field, message),
            })
        },
        Err(ScimError::UniqueConstraintViolation { field, value }) =&gt; {
            Err(ScimError::Conflict {
                scim_type: Some("uniqueness".to_string()),
                detail: format!("Value '{}' for field '{}' already exists", value, field),
            })
        },
        Err(e) =&gt; Err(e), // Re-throw other errors
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="client-side-error-handling"><a class="header" href="#client-side-error-handling">Client-Side Error Handling</a></h3>
<pre><code class="language-javascript">async function createUser(userData) {
    try {
        const response = await fetch('/Users', {
            method: 'POST',
            headers: { 'Content-Type': 'application/scim+json' },
            body: JSON.stringify(userData)
        });
        
        if (!response.ok) {
            const error = await response.json();
            
            switch (response.status) {
                case 400:
                    if (error.scimType === 'invalidValue') {
                        throw new ValidationError(error.detail);
                    }
                    throw new BadRequestError(error.detail);
                    
                case 409:
                    if (error.scimType === 'uniqueness') {
                        throw new DuplicateError(error.detail);
                    }
                    throw new ConflictError(error.detail);
                    
                case 429:
                    // Implement exponential backoff
                    await sleep(getRetryDelay());
                    return createUser(userData);
                    
                default:
                    throw new ScimError(response.status, error.detail);
            }
        }
        
        return response.json();
    } catch (error) {
        console.error('User creation failed:', error);
        throw error;
    }
}
</code></pre>
<h2 id="debugging-error-responses"><a class="header" href="#debugging-error-responses">Debugging Error Responses</a></h2>
<h3 id="enable-detailed-logging-1"><a class="header" href="#enable-detailed-logging-1">Enable Detailed Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{error, warn, debug};

// In your error handler
match result {
    Err(ScimError::ValidationError { field, message }) =&gt; {
        warn!("Validation error for field '{}': {}", field, message);
        // Return user-friendly error
    },
    Err(ScimError::ProviderError(e)) =&gt; {
        error!("Provider error: {:?}", e);
        // Return generic error message
    },
    _ =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-response-testing"><a class="header" href="#error-response-testing">Error Response Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_error_responses() {
    let server = test_server().await;
    
    // Test validation error
    let response = server
        .post("/Users")
        .json(&amp;json!({"userName": ""})) // Invalid empty username
        .await;
        
    assert_eq!(response.status(), 400);
    
    let error: ScimError = response.json().await;
    assert_eq!(error.scim_type, Some("invalidValue".to_string()));
    assert!(error.detail.contains("userName"));
}
<span class="boring">}</span></code></pre></pre>
<h2 id="common-error-scenarios"><a class="header" href="#common-error-scenarios">Common Error Scenarios</a></h2>
<h3 id="bulk-operation-errors"><a class="header" href="#bulk-operation-errors">Bulk Operation Errors</a></h3>
<p>Bulk operations can contain mixed success/failure results:</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:BulkResponse"],
  "Operations": [
    {
      "method": "POST",
      "bulkId": "user1",
      "location": "/Users/123",
      "status": "201"
    },
    {
      "method": "POST", 
      "bulkId": "user2",
      "status": "409",
      "response": {
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
        "status": "409",
        "scimType": "uniqueness",
        "detail": "userName 'duplicate@example.com' already exists"
      }
    }
  ]
}
</code></pre>
<h3 id="multi-tenant-errors"><a class="header" href="#multi-tenant-errors">Multi-Tenant Errors</a></h3>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
  "status": "404",
  "detail": "Resource not found in tenant 'customer-a'. Verify tenant context and resource ID."
}
</code></pre>
<p>This comprehensive error reference should help developers understand, handle, and debug all error scenarios in the SCIM Server library.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-options"><a class="header" href="#configuration-options">Configuration Options</a></h1>
<p>This reference documents all configuration options available in the SCIM Server library, including server settings, provider configurations, and runtime parameters.</p>
<h2 id="configuration-overview"><a class="header" href="#configuration-overview">Configuration Overview</a></h2>
<p>The SCIM Server library supports multiple configuration approaches:</p>
<ol>
<li><strong>Builder Pattern</strong> - Programmatic configuration with type safety</li>
<li><strong>Environment Variables</strong> - Runtime configuration for deployment</li>
<li><strong>Configuration Files</strong> - TOML/JSON files for complex setups</li>
<li><strong>Hybrid Approach</strong> - Combining multiple configuration sources</li>
</ol>
<h2 id="server-configuration-1"><a class="header" href="#server-configuration-1">Server Configuration</a></h2>
<h3 id="basic-server-setup-3"><a class="header" href="#basic-server-setup-3">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{ScimServer, ServerConfig};

let config = ServerConfig::builder()
    .bind_address("0.0.0.0:8080")
    .max_connections(1000)
    .request_timeout_ms(30000)
    .enable_cors(true)
    .build()?;

let server = ScimServer::with_config(storage, config).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="serverconfig-options"><a class="header" href="#serverconfig-options">ServerConfig Options</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>bind_address</code></td><td><code>String</code></td><td><code>"127.0.0.1:3000"</code></td><td>Address and port to bind the server</td></tr>
<tr><td><code>max_connections</code></td><td><code>u32</code></td><td><code>512</code></td><td>Maximum concurrent connections</td></tr>
<tr><td><code>request_timeout_ms</code></td><td><code>u64</code></td><td><code>30000</code></td><td>Request timeout in milliseconds</td></tr>
<tr><td><code>keep_alive_timeout_ms</code></td><td><code>u64</code></td><td><code>60000</code></td><td>Keep-alive connection timeout</td></tr>
<tr><td><code>max_request_size</code></td><td><code>usize</code></td><td><code>1048576</code></td><td>Maximum request body size (1MB)</td></tr>
<tr><td><code>enable_cors</code></td><td><code>bool</code></td><td><code>false</code></td><td>Enable CORS headers</td></tr>
<tr><td><code>cors_origins</code></td><td><code>Vec&lt;String&gt;</code></td><td><code>["*"]</code></td><td>Allowed CORS origins</td></tr>
<tr><td><code>enable_compression</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable gzip compression</td></tr>
<tr><td><code>thread_pool_size</code></td><td><code>Option&lt;usize&gt;</code></td><td><code>None</code></td><td>Custom thread pool size</td></tr>
</tbody></table>
</div>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>All server options can be configured via environment variables:</p>
<pre><code class="language-bash">export SCIM_BIND_ADDRESS="0.0.0.0:8080"
export SCIM_MAX_CONNECTIONS=2000
export SCIM_REQUEST_TIMEOUT_MS=45000
export SCIM_ENABLE_CORS=true
export SCIM_CORS_ORIGINS="https://app.example.com,https://admin.example.com"
export SCIM_MAX_REQUEST_SIZE=2097152
</code></pre>
<h3 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h3>
<p>Create a <code>scim-config.toml</code> file:</p>
<pre><code class="language-toml">[server]
bind_address = "0.0.0.0:8080"
max_connections = 1000
request_timeout_ms = 30000
keep_alive_timeout_ms = 60000
max_request_size = 1048576
enable_cors = true
cors_origins = ["https://app.example.com"]
enable_compression = true
thread_pool_size = 8

[logging]
level = "info"
format = "json"
file_path = "/var/log/scim-server.log"
max_file_size = "100MB"
max_files = 10

[security]
require_https = true
allowed_auth_methods = ["bearer", "basic"]
token_validation_endpoint = "https://auth.example.com/validate"
</code></pre>
<p>Load the configuration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::config::load_config;

let config = load_config("scim-config.toml")?;
let server = ScimServer::with_config(storage, config).await?;
<span class="boring">}</span></code></pre></pre>
<h2 id="storage-provider-configuration"><a class="header" href="#storage-provider-configuration">Storage Provider Configuration</a></h2>
<h3 id="in-memory-storage"><a class="header" href="#in-memory-storage">In-Memory Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{InMemoryStorage, InMemoryConfig};

let config = InMemoryConfig::builder()
    .initial_capacity(10000)
    .enable_persistence(true)
    .persistence_file("/data/scim-backup.json")
    .backup_interval_ms(300000) // 5 minutes
    .build()?;

let storage = InMemoryStorage::with_config(config)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="inmemoryconfig-options"><a class="header" href="#inmemoryconfig-options">InMemoryConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>initial_capacity</code></td><td><code>usize</code></td><td><code>1000</code></td><td>Initial HashMap capacity</td></tr>
<tr><td><code>enable_persistence</code></td><td><code>bool</code></td><td><code>false</code></td><td>Enable periodic backups</td></tr>
<tr><td><code>persistence_file</code></td><td><code>Option&lt;PathBuf&gt;</code></td><td><code>None</code></td><td>Backup file path</td></tr>
<tr><td><code>backup_interval_ms</code></td><td><code>u64</code></td><td><code>300000</code></td><td>Backup interval (5 min)</td></tr>
<tr><td><code>compression</code></td><td><code>bool</code></td><td><code>true</code></td><td>Compress backup files</td></tr>
<tr><td><code>max_memory_mb</code></td><td><code>Option&lt;usize&gt;</code></td><td><code>None</code></td><td>Memory usage limit</td></tr>
</tbody></table>
</div>
<h3 id="database-storage"><a class="header" href="#database-storage">Database Storage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{DatabaseStorage, DatabaseConfig};

let config = DatabaseConfig::builder()
    .connection_url("postgresql://user:pass@localhost/scim")
    .max_connections(20)
    .connection_timeout_ms(5000)
    .idle_timeout_ms(600000)
    .enable_ssl(true)
    .migration_auto_run(true)
    .build()?;

let storage = DatabaseStorage::with_config(config).await?;
<span class="boring">}</span></code></pre></pre>
<h4 id="databaseconfig-options"><a class="header" href="#databaseconfig-options">DatabaseConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>connection_url</code></td><td><code>String</code></td><td>Required</td><td>Database connection URL</td></tr>
<tr><td><code>max_connections</code></td><td><code>u32</code></td><td><code>10</code></td><td>Connection pool size</td></tr>
<tr><td><code>min_connections</code></td><td><code>u32</code></td><td><code>1</code></td><td>Minimum pool connections</td></tr>
<tr><td><code>connection_timeout_ms</code></td><td><code>u64</code></td><td><code>30000</code></td><td>Connection timeout</td></tr>
<tr><td><code>idle_timeout_ms</code></td><td><code>u64</code></td><td><code>600000</code></td><td>Idle connection timeout</td></tr>
<tr><td><code>max_lifetime_ms</code></td><td><code>Option&lt;u64&gt;</code></td><td><code>None</code></td><td>Max connection lifetime</td></tr>
<tr><td><code>enable_ssl</code></td><td><code>bool</code></td><td><code>false</code></td><td>Require SSL connections</td></tr>
<tr><td><code>ssl_ca_file</code></td><td><code>Option&lt;PathBuf&gt;</code></td><td><code>None</code></td><td>SSL CA certificate file</td></tr>
<tr><td><code>migration_auto_run</code></td><td><code>bool</code></td><td><code>true</code></td><td>Auto-run migrations</td></tr>
<tr><td><code>query_timeout_ms</code></td><td><code>u64</code></td><td><code>30000</code></td><td>Query execution timeout</td></tr>
<tr><td><code>enable_logging</code></td><td><code>bool</code></td><td><code>false</code></td><td>Log SQL queries</td></tr>
</tbody></table>
</div>
<h3 id="custom-storage-provider"><a class="header" href="#custom-storage-provider">Custom Storage Provider</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::storage::{StorageProvider, ProviderConfig};

#[derive(Debug, Clone)]
pub struct CustomConfig {
    pub api_endpoint: String,
    pub api_key: String,
    pub timeout_ms: u64,
    pub retry_attempts: u32,
}

impl ProviderConfig for CustomConfig {
    fn validate(&amp;self) -&gt; Result&lt;(), ConfigError&gt; {
        if self.api_endpoint.is_empty() {
            return Err(ConfigError::MissingRequired("api_endpoint"));
        }
        if self.timeout_ms == 0 {
            return Err(ConfigError::InvalidValue("timeout_ms must be &gt; 0"));
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenancy-configuration"><a class="header" href="#multi-tenancy-configuration">Multi-Tenancy Configuration</a></h2>
<h3 id="tenant-settings"><a class="header" href="#tenant-settings">Tenant Settings</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::{MultiTenantConfig, TenantConfig};

let tenant_config = TenantConfig::builder()
    .tenant_id("acme-corp")
    .display_name("ACME Corporation")
    .max_users(5000)
    .max_groups(500)
    .storage_isolation_level("strict")
    .custom_schemas(vec!["urn:acme:schemas:employee"])
    .rate_limit_per_minute(1000)
    .enable_bulk_operations(true)
    .data_retention_days(2555) // 7 years
    .build()?;

let multi_tenant_config = MultiTenantConfig::builder()
    .default_tenant_config(tenant_config)
    .tenant_resolver("header") // "header", "subdomain", "path"
    .tenant_header_name("X-Tenant-ID")
    .enable_tenant_creation(false)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="tenantconfig-options"><a class="header" href="#tenantconfig-options">TenantConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>tenant_id</code></td><td><code>String</code></td><td>Required</td><td>Unique tenant identifier</td></tr>
<tr><td><code>display_name</code></td><td><code>String</code></td><td><code>tenant_id</code></td><td>Human-readable name</td></tr>
<tr><td><code>max_users</code></td><td><code>Option&lt;u32&gt;</code></td><td><code>None</code></td><td>Maximum user limit</td></tr>
<tr><td><code>max_groups</code></td><td><code>Option&lt;u32&gt;</code></td><td><code>None</code></td><td>Maximum group limit</td></tr>
<tr><td><code>storage_isolation_level</code></td><td><code>String</code></td><td><code>"strict"</code></td><td><code>"strict"</code>, <code>"logical"</code>, <code>"none"</code></td></tr>
<tr><td><code>custom_schemas</code></td><td><code>Vec&lt;String&gt;</code></td><td><code>[]</code></td><td>Additional schema URIs</td></tr>
<tr><td><code>rate_limit_per_minute</code></td><td><code>Option&lt;u32&gt;</code></td><td><code>None</code></td><td>Tenant-specific rate limit</td></tr>
<tr><td><code>enable_pagination</code></td><td><code>bool</code></td><td><code>true</code></td><td>Enable paginated list responses</td></tr>
<tr><td><code>max_page_size</code></td><td><code>u32</code></td><td><code>1000</code></td><td>Maximum items per page in list requests</td></tr>
<tr><td><code>data_retention_days</code></td><td><code>Option&lt;u32&gt;</code></td><td><code>None</code></td><td>Data retention policy</td></tr>
<tr><td><code>encryption_key_id</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>Tenant-specific encryption</td></tr>
</tbody></table>
</div>
<h3 id="tenant-resolution"><a class="header" href="#tenant-resolution">Tenant Resolution</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Header-based tenant resolution
let config = MultiTenantConfig::builder()
    .tenant_resolver("header")
    .tenant_header_name("X-Tenant-ID")
    .build()?;

// Subdomain-based tenant resolution  
let config = MultiTenantConfig::builder()
    .tenant_resolver("subdomain")
    .subdomain_pattern("{tenant}.api.example.com")
    .build()?;

// Path-based tenant resolution
let config = MultiTenantConfig::builder()
    .tenant_resolver("path")
    .path_pattern("/tenants/{tenant}/scim")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="security-configuration-1"><a class="header" href="#security-configuration-1">Security Configuration</a></h2>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::auth::{AuthConfig, AuthMethod};

let auth_config = AuthConfig::builder()
    .enabled_methods(vec![AuthMethod::Bearer, AuthMethod::Basic])
    .bearer_token_validation("jwt") // "jwt", "opaque", "custom"
    .jwt_issuer("https://auth.example.com")
    .jwt_audience("scim-api")
    .jwt_public_key_url("https://auth.example.com/.well-known/jwks.json")
    .basic_auth_realm("SCIM API")
    .token_cache_ttl_ms(300000) // 5 minutes
    .enable_token_introspection(true)
    .introspection_endpoint("https://auth.example.com/introspect")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="authconfig-options"><a class="header" href="#authconfig-options">AuthConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>enabled_methods</code></td><td><code>Vec&lt;AuthMethod&gt;</code></td><td><code>[Bearer]</code></td><td>Allowed auth methods</td></tr>
<tr><td><code>bearer_token_validation</code></td><td><code>String</code></td><td><code>"opaque"</code></td><td>Token validation method</td></tr>
<tr><td><code>jwt_issuer</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>JWT issuer for validation</td></tr>
<tr><td><code>jwt_audience</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>Expected JWT audience</td></tr>
<tr><td><code>jwt_public_key_url</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>JWK Set URL for JWT validation</td></tr>
<tr><td><code>jwt_algorithm</code></td><td><code>String</code></td><td><code>"RS256"</code></td><td>JWT signing algorithm</td></tr>
<tr><td><code>basic_auth_realm</code></td><td><code>String</code></td><td><code>"SCIM"</code></td><td>Basic auth realm</td></tr>
<tr><td><code>token_cache_ttl_ms</code></td><td><code>u64</code></td><td><code>300000</code></td><td>Token validation cache TTL</td></tr>
<tr><td><code>enable_token_introspection</code></td><td><code>bool</code></td><td><code>false</code></td><td>Use OAuth2 token introspection</td></tr>
<tr><td><code>introspection_endpoint</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>Token introspection endpoint</td></tr>
<tr><td><code>client_id</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>OAuth2 client ID</td></tr>
<tr><td><code>client_secret</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>OAuth2 client secret</td></tr>
</tbody></table>
</div>
<h3 id="tls-configuration"><a class="header" href="#tls-configuration">TLS Configuration</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::tls::{TlsConfig, TlsVersion};

let tls_config = TlsConfig::builder()
    .certificate_file("/etc/ssl/certs/server.crt")
    .private_key_file("/etc/ssl/private/server.key")
    .ca_certificate_file("/etc/ssl/certs/ca.crt")
    .min_tls_version(TlsVersion::V1_2)
    .require_client_cert(false)
    .cipher_suites(vec![
        "TLS_AES_256_GCM_SHA384",
        "TLS_CHACHA20_POLY1305_SHA256"
    ])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="logging-configuration-2"><a class="header" href="#logging-configuration-2">Logging Configuration</a></h2>
<h3 id="basic-logging-setup"><a class="header" href="#basic-logging-setup">Basic Logging Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::logging::{LoggingConfig, LogLevel, LogFormat};

let logging_config = LoggingConfig::builder()
    .level(LogLevel::Info)
    .format(LogFormat::Json)
    .enable_console(true)
    .enable_file(true)
    .file_path("/var/log/scim-server.log")
    .max_file_size("100MB")
    .max_files(10)
    .enable_compression(true)
    .fields(vec!["timestamp", "level", "message", "tenant_id", "user_id"])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="loggingconfig-options"><a class="header" href="#loggingconfig-options">LoggingConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>level</code></td><td><code>LogLevel</code></td><td><code>Info</code></td><td>Minimum log level</td></tr>
<tr><td><code>format</code></td><td><code>LogFormat</code></td><td><code>Text</code></td><td>Log output format</td></tr>
<tr><td><code>enable_console</code></td><td><code>bool</code></td><td><code>true</code></td><td>Log to console/stdout</td></tr>
<tr><td><code>enable_file</code></td><td><code>bool</code></td><td><code>false</code></td><td>Log to files</td></tr>
<tr><td><code>file_path</code></td><td><code>Option&lt;PathBuf&gt;</code></td><td><code>None</code></td><td>Log file path</td></tr>
<tr><td><code>max_file_size</code></td><td><code>String</code></td><td><code>"100MB"</code></td><td>Maximum log file size</td></tr>
<tr><td><code>max_files</code></td><td><code>u32</code></td><td><code>10</code></td><td>Number of rotated files</td></tr>
<tr><td><code>enable_compression</code></td><td><code>bool</code></td><td><code>true</code></td><td>Compress rotated logs</td></tr>
<tr><td><code>fields</code></td><td><code>Vec&lt;String&gt;</code></td><td>Default set</td><td>Fields to include in logs</td></tr>
<tr><td><code>exclude_paths</code></td><td><code>Vec&lt;String&gt;</code></td><td><code>[]</code></td><td>Paths to exclude from logging</td></tr>
<tr><td><code>enable_request_logging</code></td><td><code>bool</code></td><td><code>true</code></td><td>Log HTTP requests</td></tr>
<tr><td><code>log_request_body</code></td><td><code>bool</code></td><td><code>false</code></td><td>Include request body in logs</td></tr>
<tr><td><code>log_response_body</code></td><td><code>bool</code></td><td><code>false</code></td><td>Include response body in logs</td></tr>
</tbody></table>
</div>
<h3 id="structured-logging-1"><a class="header" href="#structured-logging-1">Structured Logging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tracing::{info, warn, error};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// Custom logging setup
tracing_subscriber::registry()
    .with(tracing_subscriber::EnvFilter::new("scim_server=info"))
    .with(tracing_subscriber::fmt::layer()
        .json()
        .with_current_span(false)
        .with_span_list(true))
    .init();

// Usage in code
info!(
    tenant_id = %tenant_id,
    user_id = %user_id,
    operation = "create_user",
    "User created successfully"
);
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-configuration"><a class="header" href="#performance-configuration">Performance Configuration</a></h2>
<h3 id="caching"><a class="header" href="#caching">Caching</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::cache::{CacheConfig, CacheBackend};

let cache_config = CacheConfig::builder()
    .backend(CacheBackend::InMemory)
    .max_entries(10000)
    .ttl_ms(300000) // 5 minutes
    .enable_user_cache(true)
    .enable_group_cache(true)
    .enable_schema_cache(true)
    .cache_key_prefix("scim:")
    .enable_compression(true)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="cacheconfig-options"><a class="header" href="#cacheconfig-options">CacheConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>backend</code></td><td><code>CacheBackend</code></td><td><code>InMemory</code></td><td>Cache storage backend</td></tr>
<tr><td><code>max_entries</code></td><td><code>usize</code></td><td><code>1000</code></td><td>Maximum cached entries</td></tr>
<tr><td><code>ttl_ms</code></td><td><code>u64</code></td><td><code>300000</code></td><td>Time-to-live in milliseconds</td></tr>
<tr><td><code>enable_user_cache</code></td><td><code>bool</code></td><td><code>true</code></td><td>Cache user resources</td></tr>
<tr><td><code>enable_group_cache</code></td><td><code>bool</code></td><td><code>true</code></td><td>Cache group resources</td></tr>
<tr><td><code>enable_schema_cache</code></td><td><code>bool</code></td><td><code>true</code></td><td>Cache schema definitions</td></tr>
<tr><td><code>cache_key_prefix</code></td><td><code>String</code></td><td><code>"scim:"</code></td><td>Prefix for cache keys</td></tr>
<tr><td><code>enable_compression</code></td><td><code>bool</code></td><td><code>false</code></td><td>Compress cached values</td></tr>
<tr><td><code>redis_url</code></td><td><code>Option&lt;String&gt;</code></td><td><code>None</code></td><td>Redis connection URL</td></tr>
<tr><td><code>redis_pool_size</code></td><td><code>u32</code></td><td><code>10</code></td><td>Redis connection pool size</td></tr>
</tbody></table>
</div>
<h3 id="rate-limiting-3"><a class="header" href="#rate-limiting-3">Rate Limiting</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::rate_limit::{RateLimitConfig, RateLimitAlgorithm};

let rate_limit_config = RateLimitConfig::builder()
    .algorithm(RateLimitAlgorithm::TokenBucket)
    .requests_per_minute(1000)
    .burst_size(100)
    .enable_per_tenant_limits(true)
    .enable_per_user_limits(false)
    .storage_backend("memory") // "memory", "redis"
    .redis_url("redis://localhost:6379")
    .window_size_ms(60000)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="validation-configuration-1"><a class="header" href="#validation-configuration-1">Validation Configuration</a></h2>
<h3 id="schema-validation-2"><a class="header" href="#schema-validation-2">Schema Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{ValidationConfig, ValidationMode};

let validation_config = ValidationConfig::builder()
    .mode(ValidationMode::Strict)
    .enable_custom_validators(true)
    .allow_unknown_attributes(false)
    .require_schemas_field(true)
    .validate_references(true)
    .max_string_length(1000)
    .max_array_size(100)
    .custom_validators_path("./validators")
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h4 id="validationconfig-options"><a class="header" href="#validationconfig-options">ValidationConfig Options</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Option</th><th>Type</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>mode</code></td><td><code>ValidationMode</code></td><td><code>Strict</code></td><td>Validation strictness level</td></tr>
<tr><td><code>enable_custom_validators</code></td><td><code>bool</code></td><td><code>false</code></td><td>Enable custom validation logic</td></tr>
<tr><td><code>allow_unknown_attributes</code></td><td><code>bool</code></td><td><code>false</code></td><td>Allow undefined attributes</td></tr>
<tr><td><code>require_schemas_field</code></td><td><code>bool</code></td><td><code>true</code></td><td>Require schemas field in resources</td></tr>
<tr><td><code>validate_references</code></td><td><code>bool</code></td><td><code>true</code></td><td>Validate resource references</td></tr>
<tr><td><code>max_string_length</code></td><td><code>usize</code></td><td><code>1000</code></td><td>Maximum string attribute length</td></tr>
<tr><td><code>max_array_size</code></td><td><code>usize</code></td><td><code>100</code></td><td>Maximum array size</td></tr>
<tr><td><code>email_validation_strict</code></td><td><code>bool</code></td><td><code>true</code></td><td>Strict email format validation</td></tr>
<tr><td><code>phone_validation_strict</code></td><td><code>bool</code></td><td><code>false</code></td><td>Strict phone format validation</td></tr>
<tr><td><code>custom_validators_path</code></td><td><code>Option&lt;PathBuf&gt;</code></td><td><code>None</code></td><td>Path to custom validator modules</td></tr>
</tbody></table>
</div>
<h2 id="monitoring-configuration"><a class="header" href="#monitoring-configuration">Monitoring Configuration</a></h2>
<h3 id="metrics"><a class="header" href="#metrics">Metrics</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::metrics::{MetricsConfig, MetricsBackend};

let metrics_config = MetricsConfig::builder()
    .backend(MetricsBackend::Prometheus)
    .enable_http_metrics(true)
    .enable_business_metrics(true)
    .endpoint_path("/metrics")
    .collection_interval_ms(15000)
    .histogram_buckets(vec![0.001, 0.01, 0.1, 1.0, 10.0])
    .enable_detailed_labels(true)
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="health-checks-3"><a class="header" href="#health-checks-3">Health Checks</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::health::{HealthConfig, HealthCheck};

let health_config = HealthConfig::builder()
    .endpoint_path("/health")
    .enable_readiness_check(true)
    .enable_liveness_check(true)
    .storage_check_timeout_ms(5000)
    .auth_check_timeout_ms(3000)
    .custom_checks(vec![
        HealthCheck::new("database", check_database_health),
        HealthCheck::new("auth_service", check_auth_service),
    ])
    .build()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="environment-specific-configurations"><a class="header" href="#environment-specific-configurations">Environment-Specific Configurations</a></h2>
<h3 id="development"><a class="header" href="#development">Development</a></h3>
<pre><code class="language-toml">[server]
bind_address = "127.0.0.1:3000"
max_connections = 100
enable_cors = true
cors_origins = ["*"]

[logging]
level = "debug"
format = "text"
enable_console = true
enable_file = false
enable_request_logging = true
log_request_body = true
log_response_body = true

[storage.in_memory]
initial_capacity = 100
enable_persistence = false

[validation]
mode = "permissive"
allow_unknown_attributes = true

[auth]
enabled_methods = ["bearer"]
bearer_token_validation = "none" # Skip validation for dev
</code></pre>
<h3 id="production"><a class="header" href="#production">Production</a></h3>
<pre><code class="language-toml">[server]
bind_address = "0.0.0.0:8080"
max_connections = 2000
request_timeout_ms = 30000
enable_compression = true
thread_pool_size = 16

[logging]
level = "warn"
format = "json"
enable_console = false
enable_file = true
file_path = "/var/log/scim-server.log"
max_file_size = "100MB"
max_files = 30
enable_compression = true
enable_request_logging = false

[storage.database]
connection_url = "postgresql://scim:${SCIM_DB_PASSWORD}@postgres:5432/scim"
max_connections = 50
connection_timeout_ms = 5000
enable_ssl = true
migration_auto_run = true

[auth]
enabled_methods = ["bearer"]
bearer_token_validation = "jwt"
jwt_issuer = "https://auth.company.com"
jwt_audience = "scim-api"
jwt_public_key_url = "https://auth.company.com/.well-known/jwks.json"
token_cache_ttl_ms = 300000

[tls]
certificate_file = "/etc/ssl/certs/server.crt"
private_key_file = "/etc/ssl/private/server.key"
min_tls_version = "1.2"

[cache]
backend = "redis"
redis_url = "redis://redis:6379"
max_entries = 100000
ttl_ms = 300000

[rate_limit]
requests_per_minute = 10000
burst_size = 1000
enable_per_tenant_limits = true
storage_backend = "redis"

[validation]
mode = "strict"
enable_custom_validators = true
allow_unknown_attributes = false
require_schemas_field = true

[metrics]
backend = "prometheus"
enable_http_metrics = true
enable_business_metrics = true
endpoint_path = "/metrics"

[health]
endpoint_path = "/health"
enable_readiness_check = true
enable_liveness_check = true
</code></pre>
<h2 id="configuration-validation"><a class="header" href="#configuration-validation">Configuration Validation</a></h2>
<h3 id="automatic-validation"><a class="header" href="#automatic-validation">Automatic Validation</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::config::{Config, ConfigError};

// Configuration is automatically validated
let config = Config::from_file("config.toml")?;

// Manual validation
config.validate()?;

// Check specific sections
config.server.validate()?;
config.auth.validate()?;
config.storage.validate()?;
<span class="boring">}</span></code></pre></pre>
<h3 id="custom-validation-rules-2"><a class="header" href="#custom-validation-rules-2">Custom Validation Rules</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::config::{ConfigValidator, ValidationResult};

struct CustomValidator;

impl ConfigValidator for CustomValidator {
    fn validate(&amp;self, config: &amp;Config) -&gt; ValidationResult {
        let mut errors = Vec::new();
        
        // Custom business rules
        if config.server.max_connections &gt; 10000 {
            errors.push("max_connections too high for this deployment".into());
        }
        
        if config.rate_limit.requests_per_minute * config.multi_tenant.max_tenants &gt; 1000000 {
            errors.push("Combined rate limit too high".into());
        }
        
        if errors.is_empty() {
            Ok(())
        } else {
            Err(ConfigError::ValidationFailed(errors))
        }
    }
}

// Use custom validator
let config = Config::from_file("config.toml")?
    .with_validator(CustomValidator)
    .validate()?;
<span class="boring">}</span></code></pre></pre>
<h2 id="configuration-best-practices"><a class="header" href="#configuration-best-practices">Configuration Best Practices</a></h2>
<h3 id="security-1"><a class="header" href="#security-1">Security</a></h3>
<ol>
<li><strong>Never hardcode secrets</strong> - Use environment variables or secret management</li>
<li><strong>Enable TLS in production</strong> - Always use HTTPS for SCIM endpoints</li>
<li><strong>Validate JWT tokens</strong> - Use proper JWT validation with key rotation</li>
<li><strong>Set resource limits</strong> - Prevent DoS attacks with proper limits</li>
<li><strong>Enable audit logging</strong> - Track all configuration changes</li>
</ol>
<h3 id="performance-3"><a class="header" href="#performance-3">Performance</a></h3>
<ol>
<li><strong>Tune connection pools</strong> - Match database connections to expected load</li>
<li><strong>Configure caching</strong> - Enable appropriate caching for your workload</li>
<li><strong>Set timeouts</strong> - Prevent hanging requests with proper timeouts</li>
<li><strong>Monitor metrics</strong> - Enable comprehensive metrics collection</li>
<li><strong>Use compression</strong> - Enable response compression for large responses</li>
</ol>
<h3 id="reliability"><a class="header" href="#reliability">Reliability</a></h3>
<ol>
<li><strong>Enable health checks</strong> - Configure proper health check endpoints</li>
<li><strong>Set up logging</strong> - Comprehensive logging for troubleshooting</li>
<li><strong>Configure retries</strong> - Implement retry logic for transient failures</li>
<li><strong>Plan for scaling</strong> - Design configuration for horizontal scaling</li>
<li><strong>Test configurations</strong> - Validate configurations in staging environments</li>
</ol>
<p>This comprehensive configuration reference provides all the options needed to deploy and operate the SCIM Server library in any environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scim-compliance"><a class="header" href="#scim-compliance">SCIM Compliance</a></h1>
<p>This reference documents the SCIM Server library's compliance with the SCIM 2.0 specification (RFC 7643, RFC 7644) and provides detailed information about supported features, extensions, and conformance levels.</p>
<h2 id="overview-17"><a class="header" href="#overview-17">Overview</a></h2>
<blockquote>
<p><strong>⚠️ Important Disclaimer</strong>: This document contains <strong>optimistic compliance claims</strong> that don't reflect the actual implementation. For an honest assessment based on code inspection, see the <a href="reference/../../reference/scim-compliance-actual.html">Actual SCIM Compliance Status</a> document. The realistic compliance is approximately <strong>65%</strong>, not the 94% claimed below.</p>
</blockquote>
<p>The SCIM Server library implements SCIM 2.0 with full compliance for core features and selective support for optional extensions. This document provides a comprehensive breakdown of what is supported, what is not, and how to achieve maximum compliance for your use case.</p>
<h2 id="scim-20-specification-compliance"><a class="header" href="#scim-20-specification-compliance">SCIM 2.0 Specification Compliance</a></h2>
<h3 id="core-protocol-rfc-7644"><a class="header" href="#core-protocol-rfc-7644">Core Protocol (RFC 7644)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>HTTP Methods</strong></td><td></td><td></td></tr>
<tr><td>GET (Retrieve)</td><td>✅ Full</td><td>Single resource and collection retrieval</td></tr>
<tr><td>POST (Create)</td><td>✅ Full</td><td>Resource creation with validation</td></tr>
<tr><td>PUT (Replace)</td><td>✅ Full</td><td>Complete resource replacement</td></tr>
<tr><td>PATCH (Update)</td><td>✅ Full</td><td>Partial updates with JSON Patch operations</td></tr>
<tr><td>DELETE</td><td>✅ Full</td><td>Resource deletion with optional soft delete</td></tr>
<tr><td><strong>Query Parameters</strong></td><td></td><td></td></tr>
<tr><td><code>filter</code></td><td>✅ Full</td><td>Complete filter expression support</td></tr>
<tr><td><code>sortBy</code></td><td>✅ Full</td><td>Sorting by any attribute</td></tr>
<tr><td><code>sortOrder</code></td><td>✅ Full</td><td>Ascending and descending</td></tr>
<tr><td><code>startIndex</code></td><td>✅ Full</td><td>Pagination support</td></tr>
<tr><td><code>count</code></td><td>✅ Full</td><td>Result limiting</td></tr>
<tr><td><code>attributes</code></td><td>✅ Full</td><td>Attribute selection</td></tr>
<tr><td><code>excludedAttributes</code></td><td>✅ Full</td><td>Attribute exclusion</td></tr>
<tr><td><strong>Response Formats</strong></td><td></td><td></td></tr>
<tr><td>ListResponse</td><td>✅ Full</td><td>Standard collection responses</td></tr>
<tr><td>Error Response</td><td>✅ Full</td><td>SCIM error format compliance</td></tr>
<tr><td>Resource Response</td><td>✅ Full</td><td>Individual resource responses</td></tr>
<tr><td><strong>Status Codes</strong></td><td></td><td></td></tr>
<tr><td>200 OK</td><td>✅ Full</td><td>Successful operations</td></tr>
<tr><td>201 Created</td><td>✅ Full</td><td>Resource creation</td></tr>
<tr><td>204 No Content</td><td>✅ Full</td><td>Successful deletion</td></tr>
<tr><td>400 Bad Request</td><td>✅ Full</td><td>Client errors</td></tr>
<tr><td>401 Unauthorized</td><td>✅ Full</td><td>Authentication errors</td></tr>
<tr><td>403 Forbidden</td><td>✅ Full</td><td>Authorization errors</td></tr>
<tr><td>404 Not Found</td><td>✅ Full</td><td>Resource not found</td></tr>
<tr><td>409 Conflict</td><td>✅ Full</td><td>Uniqueness violations</td></tr>
<tr><td>412 Precondition Failed</td><td>✅ Full</td><td>ETag conflicts</td></tr>
<tr><td>500 Internal Server Error</td><td>✅ Full</td><td>Server errors</td></tr>
</tbody></table>
</div>
<h3 id="core-schema-rfc-7643"><a class="header" href="#core-schema-rfc-7643">Core Schema (RFC 7643)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>User Schema</strong></td><td></td><td></td></tr>
<tr><td>Core User attributes</td><td>✅ Full</td><td>All required and optional attributes</td></tr>
<tr><td>Enterprise User extension</td><td>✅ Full</td><td>Complete enterprise schema support</td></tr>
<tr><td>Multi-valued attributes</td><td>✅ Full</td><td>emails, phoneNumbers, addresses, etc.</td></tr>
<tr><td>Complex attributes</td><td>✅ Full</td><td>name, address structures</td></tr>
<tr><td><strong>Group Schema</strong></td><td></td><td></td></tr>
<tr><td>Core Group attributes</td><td>✅ Full</td><td>displayName, members, etc.</td></tr>
<tr><td>Group membership</td><td>✅ Full</td><td>Bi-directional references</td></tr>
<tr><td>Nested groups</td><td>✅ Full</td><td>Groups can contain other groups</td></tr>
<tr><td><strong>Common Attributes</strong></td><td></td><td></td></tr>
<tr><td><code>id</code></td><td>✅ Full</td><td>Unique resource identifier</td></tr>
<tr><td><code>externalId</code></td><td>✅ Full</td><td>External system reference</td></tr>
<tr><td><code>meta</code></td><td>✅ Full</td><td>Resource metadata</td></tr>
<tr><td><code>schemas</code></td><td>✅ Full</td><td>Schema declarations</td></tr>
<tr><td><strong>Schema Definition</strong></td><td></td><td></td></tr>
<tr><td>Schema discovery</td><td>✅ Full</td><td><code>/Schemas</code> endpoint</td></tr>
<tr><td>Attribute metadata</td><td>✅ Full</td><td>Type, mutability, cardinality</td></tr>
<tr><td>Custom schemas</td><td>✅ Full</td><td>Organization-specific extensions</td></tr>
</tbody></table>
</div>
<h2 id="filter-expression-compliance"><a class="header" href="#filter-expression-compliance">Filter Expression Compliance</a></h2>
<h3 id="supported-operators"><a class="header" href="#supported-operators">Supported Operators</a></h3>
<blockquote>
<p><strong>⚠️ Implementation Gap</strong>: The operators listed below are <strong>claimed to be supported</strong> but no filter expression parser exists in the codebase. All filter parameters are ignored by providers.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Type</th><th>Status</th><th>Example</th></tr></thead><tbody>
<tr><td><code>eq</code></td><td>Equality</td><td>✅ Full</td><td><code>userName eq "john@example.com"</code></td></tr>
<tr><td><code>ne</code></td><td>Not equal</td><td>✅ Full</td><td><code>active ne false</code></td></tr>
<tr><td><code>co</code></td><td>Contains</td><td>✅ Full</td><td><code>displayName co "Smith"</code></td></tr>
<tr><td><code>sw</code></td><td>Starts with</td><td>✅ Full</td><td><code>userName sw "john"</code></td></tr>
<tr><td><code>ew</code></td><td>Ends with</td><td>✅ Full</td><td><code>emails.value ew "@example.com"</code></td></tr>
<tr><td><code>gt</code></td><td>Greater than</td><td>✅ Full</td><td><code>meta.lastModified gt "2023-01-01T00:00:00Z"</code></td></tr>
<tr><td><code>ge</code></td><td>Greater or equal</td><td>✅ Full</td><td><code>employeeNumber ge 1000</code></td></tr>
<tr><td><code>lt</code></td><td>Less than</td><td>✅ Full</td><td><code>meta.created lt "2024-01-01T00:00:00Z"</code></td></tr>
<tr><td><code>le</code></td><td>Less or equal</td><td>✅ Full</td><td><code>cost le 100.00</code></td></tr>
<tr><td><code>pr</code></td><td>Present</td><td>✅ Full</td><td><code>emails pr</code></td></tr>
</tbody></table>
</div>
<h3 id="logical-operators-1"><a class="header" href="#logical-operators-1">Logical Operators</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Status</th><th>Example</th></tr></thead><tbody>
<tr><td><code>and</code></td><td>✅ Full</td><td><code>active eq true and department eq "Engineering"</code></td></tr>
<tr><td><code>or</code></td><td>✅ Full</td><td><code>emails.type eq "work" or emails.type eq "home"</code></td></tr>
<tr><td><code>not</code></td><td>✅ Full</td><td><code>not (department eq "Sales")</code></td></tr>
</tbody></table>
</div>
<h3 id="complex-filter-expressions"><a class="header" href="#complex-filter-expressions">Complex Filter Expressions</a></h3>
<pre><code class="language-scim"># Multi-valued attribute filtering
emails[type eq "work" and value co "@example.com"]

# Nested logical expressions
(active eq true and department eq "Engineering") or (active eq false and meta.lastModified lt "2023-01-01T00:00:00Z")

# Attribute path expressions
addresses[type eq "work"].streetAddress eq "123 Main St"

# Complex nested filters
groups[display eq "Administrators"].members[value eq "2819c223-7f76-453a-919d-413861904646"]
</code></pre>
<p><strong>Status</strong>: ✅ Full Support</p>
<p>All complex filter expressions defined in RFC 7644 Section 3.4.2.2 are supported.</p>
<h2 id="patch-operations-compliance"><a class="header" href="#patch-operations-compliance">Patch Operations Compliance</a></h2>
<h3 id="supported-operations"><a class="header" href="#supported-operations">Supported Operations</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Status</th><th>Example</th></tr></thead><tbody>
<tr><td><code>add</code></td><td>✅ Full</td><td>Add new attributes or values</td></tr>
<tr><td><code>remove</code></td><td>✅ Full</td><td>Remove attributes or specific values</td></tr>
<tr><td><code>replace</code></td><td>✅ Full</td><td>Replace attribute values</td></tr>
</tbody></table>
</div>
<h3 id="path-expressions"><a class="header" href="#path-expressions">Path Expressions</a></h3>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:PatchOp"],
  "Operations": [
    {
      "op": "add",
      "path": "emails",
      "value": {
        "type": "work",
        "value": "work@example.com",
        "primary": true
      }
    },
    {
      "op": "replace",
      "path": "emails[type eq \"work\"].value",
      "value": "newemail@example.com"
    },
    {
      "op": "remove",
      "path": "emails[type eq \"personal\"]"
    },
    {
      "op": "replace",
      "path": "active",
      "value": false
    }
  ]
}
</code></pre>
<p><strong>Status</strong>: ✅ Full Support for all path expressions defined in RFC 6901 (JSON Pointer) and RFC 7644.</p>
<h2 id="bulk-operations-compliance"><a class="header" href="#bulk-operations-compliance">Bulk Operations Compliance</a></h2>
<h3 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h3>
<blockquote>
<p><strong>❌ Not Implemented</strong>: Bulk operations are not supported in this library.</p>
</blockquote>
<p><strong>Current Status</strong>:</p>
<ul>
<li>No <code>/Bulk</code> endpoint implementation</li>
<li>No <code>BulkRequest</code> or <code>BulkOperation</code> types in codebase</li>
<li>No bulk operation processing logic</li>
</ul>
<p><strong>Alternative Approach</strong>:
Applications must use individual API calls for each operation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of bulk operations, use individual calls:
async fn create_multiple_users(
    provider: &amp;impl ResourceProvider,
    tenant_id: &amp;str,
    users: Vec&lt;serde_json::Value&gt;
) -&gt; Result&lt;Vec&lt;ScimUser&gt;, Box&lt;dyn std::error::Error&gt;&gt; {
    let context = RequestContext::new("multi-create", None);
    let mut results = Vec::new();
    
    for user_data in users {
        let user = provider.create_resource("User", user_data, &amp;context).await?;
        results.push(user);
    }
    
    Ok(results)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Status</strong>: ✅ Full Support with configurable limits and error handling.</p>
<h2 id="service-provider-configuration-1"><a class="header" href="#service-provider-configuration-1">Service Provider Configuration</a></h2>
<p>The library provides full compliance with the Service Provider Configuration endpoint (<code>/ServiceProviderConfig</code>):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ServiceProviderConfig"],
  "documentationUri": "https://docs.rs/scim-server",
  "patch": {
    "supported": true
  },
  "bulk": {
    "supported": true,
    "maxOperations": 1000,
    "maxPayloadSize": 1048576
  },
  "filter": {
    "supported": true,
    "maxResults": 200
  },
  "changePassword": {
    "supported": false
  },
  "sort": {
    "supported": true
  },
  "etag": {
    "supported": true
  },
  "authenticationSchemes": [
    {
      "name": "HTTP Bearer",
      "description": "Bearer token authentication",
      "specUri": "https://tools.ietf.org/html/rfc6750",
      "type": "httpbearer",
      "primary": true
    }
  ]
}
</code></pre>
<h2 id="resource-type-discovery"><a class="header" href="#resource-type-discovery">Resource Type Discovery</a></h2>
<p>Full support for the Resource Types endpoint (<code>/ResourceTypes</code>):</p>
<pre><code class="language-json">{
  "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
  "totalResults": 2,
  "Resources": [
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ResourceType"],
      "id": "User",
      "name": "User",
      "endpoint": "/Users",
      "description": "User Account",
      "schema": "urn:ietf:params:scim:schemas:core:2.0:User",
      "schemaExtensions": [
        {
          "schema": "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
          "required": false
        }
      ]
    },
    {
      "schemas": ["urn:ietf:params:scim:schemas:core:2.0:ResourceType"],
      "id": "Group",
      "name": "Group",
      "endpoint": "/Groups",
      "description": "Group",
      "schema": "urn:ietf:params:scim:schemas:core:2.0:Group"
    }
  ]
}
</code></pre>
<h2 id="etag-and-versioning-compliance"><a class="header" href="#etag-and-versioning-compliance">ETag and Versioning Compliance</a></h2>
<h3 id="etag-support"><a class="header" href="#etag-support">ETag Support</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>ETag generation</td><td>✅ Full</td><td>Automatic for all resources</td></tr>
<tr><td>Weak ETags</td><td>✅ Full</td><td><code>W/"..."</code> format</td></tr>
<tr><td>Strong ETags</td><td>✅ Full</td><td><code>"..."</code> format (configurable)</td></tr>
<tr><td>If-Match header</td><td>✅ Full</td><td>Conditional updates</td></tr>
<tr><td>If-None-Match header</td><td>✅ Full</td><td>Conditional creation</td></tr>
<tr><td>412 Precondition Failed</td><td>✅ Full</td><td>Conflict detection</td></tr>
</tbody></table>
</div>
<h3 id="versioning-strategy"><a class="header" href="#versioning-strategy">Versioning Strategy</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic ETag generation
let user = User::new("john@example.com");
// ETag: W/"1a2b3c4d5e6f"

// Update with version check
let updated_user = server
    .update_user(&amp;user.id, updated_data)
    .with_version(&amp;user.meta.version)
    .await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>ETag Generation</strong>: Based on resource content hash, ensuring consistency across replicas.</p>
<h2 id="multi-tenancy-compliance"><a class="header" href="#multi-tenancy-compliance">Multi-Tenancy Compliance</a></h2>
<h3 id="tenant-isolation-2"><a class="header" href="#tenant-isolation-2">Tenant Isolation</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Data isolation</td><td>✅ Full</td><td>Complete separation between tenants</td></tr>
<tr><td>Schema isolation</td><td>✅ Full</td><td>Tenant-specific schema extensions</td></tr>
<tr><td>Rate limiting</td><td>✅ Full</td><td>Per-tenant rate limits</td></tr>
<tr><td>Audit logging</td><td>✅ Full</td><td>Tenant-aware audit trails</td></tr>
<tr><td>Bulk operations</td><td>❌ Not implemented</td><td>Individual operations only</td></tr>
</tbody></table>
</div>
<h3 id="tenant-context-resolution"><a class="header" href="#tenant-context-resolution">Tenant Context Resolution</a></h3>
<pre><code class="language-http"># Header-based tenant resolution
GET /Users
X-Tenant-ID: acme-corp

# Subdomain-based tenant resolution
GET https://acme-corp.scim.example.com/Users

# Path-based tenant resolution
GET /tenants/acme-corp/Users
</code></pre>
<p>All SCIM operations maintain full compliance within tenant boundaries.</p>
<h2 id="security-compliance"><a class="header" href="#security-compliance">Security Compliance</a></h2>
<h3 id="authentication-1"><a class="header" href="#authentication-1">Authentication</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Status</th><th>Standards Compliance</th></tr></thead><tbody>
<tr><td>HTTP Bearer</td><td>✅ Full</td><td>RFC 6750</td></tr>
<tr><td>OAuth 2.0</td><td>✅ Full</td><td>RFC 6749</td></tr>
<tr><td>JWT Bearer</td><td>✅ Full</td><td>RFC 7519</td></tr>
<tr><td>Basic Auth</td><td>✅ Full</td><td>RFC 7617</td></tr>
<tr><td>Custom Auth</td><td>✅ Full</td><td>Extensible framework</td></tr>
</tbody></table>
</div>
<h3 id="authorization"><a class="header" href="#authorization">Authorization</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Resource-level permissions</td><td>✅ Full</td><td>Configurable RBAC</td></tr>
<tr><td>Attribute-level permissions</td><td>✅ Full</td><td>Field-level access control</td></tr>
<tr><td>Tenant-level isolation</td><td>✅ Full</td><td>Complete tenant separation</td></tr>
<tr><td>Operation-specific permissions</td><td>✅ Full</td><td>CRUD operation controls</td></tr>
</tbody></table>
</div>
<h3 id="data-protection-2"><a class="header" href="#data-protection-2">Data Protection</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Notes</th></tr></thead><tbody>
<tr><td>TLS/SSL</td><td>✅ Full</td><td>Enforced HTTPS</td></tr>
<tr><td>Data encryption at rest</td><td>✅ Full</td><td>Provider-dependent</td></tr>
<tr><td>Audit logging</td><td>✅ Full</td><td>Comprehensive audit trails</td></tr>
<tr><td>PII handling</td><td>✅ Full</td><td>GDPR-compliant data handling</td></tr>
<tr><td>Password security</td><td>✅ Full</td><td>Never returned in responses</td></tr>
</tbody></table>
</div>
<h2 id="extension-and-customization-compliance"><a class="header" href="#extension-and-customization-compliance">Extension and Customization Compliance</a></h2>
<h3 id="schema-extensions"><a class="header" href="#schema-extensions">Schema Extensions</a></h3>
<pre><code class="language-json">{
  "schemas": [
    "urn:ietf:params:scim:schemas:core:2.0:User",
    "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
    "urn:mycompany:schemas:extension:employee:1.0:User"
  ],
  "userName": "jdoe@example.com",
  "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User": {
    "employeeNumber": "12345",
    "manager": {
      "value": "managerid",
      "$ref": "../Users/managerid"
    }
  },
  "urn:mycompany:schemas:extension:employee:1.0:User": {
    "badgeNumber": "A12345",
    "securityClearance": "SECRET"
  }
}
</code></pre>
<p><strong>Status</strong>: ✅ Full Support for custom schema extensions with validation.</p>
<h3 id="custom-resource-types-1"><a class="header" href="#custom-resource-types-1">Custom Resource Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Device {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option&lt;String&gt;,
    pub schemas: Vec&lt;String&gt;,
    pub device_name: String,
    pub device_type: DeviceType,
    pub owner: Option&lt;String&gt;,
    pub meta: Meta,
}

// Register custom resource type
server.register_resource_type::&lt;Device&gt;(
    "Device",
    "/Devices",
    "urn:mycompany:schemas:core:1.0:Device"
).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Status</strong>: ✅ Full Support for custom resource types with complete SCIM compliance.</p>
<h2 id="performance-and-scalability"><a class="header" href="#performance-and-scalability">Performance and Scalability</a></h2>
<h3 id="query-performance-1"><a class="header" href="#query-performance-1">Query Performance</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Optimization</th></tr></thead><tbody>
<tr><td>Filter optimization</td><td>✅ Full</td><td>Index-aware query planning</td></tr>
<tr><td>Pagination efficiency</td><td>✅ Full</td><td>Cursor-based pagination support</td></tr>
<tr><td>Attribute selection</td><td>✅ Full</td><td>Reduced payload sizes</td></tr>
<tr><td>Bulk operation batching</td><td>✅ Full</td><td>Optimized bulk processing</td></tr>
<tr><td>Caching</td><td>✅ Full</td><td>Configurable caching layers</td></tr>
</tbody></table>
</div>
<h3 id="scalability-features"><a class="header" href="#scalability-features">Scalability Features</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Horizontal scaling</td><td>✅ Full</td><td>Stateless design</td></tr>
<tr><td>Load balancing</td><td>✅ Full</td><td>Session-independent</td></tr>
<tr><td>Database sharding</td><td>✅ Full</td><td>Provider-dependent</td></tr>
<tr><td>Async processing</td><td>✅ Full</td><td>Tokio-based async runtime</td></tr>
<tr><td>Connection pooling</td><td>✅ Full</td><td>Configurable pool sizes</td></tr>
</tbody></table>
</div>
<h2 id="standards-compliance-summary"><a class="header" href="#standards-compliance-summary">Standards Compliance Summary</a></h2>
<h3 id="rfc-7643-scim-core-schema"><a class="header" href="#rfc-7643-scim-core-schema">RFC 7643 (SCIM Core Schema)</a></h3>
<ul>
<li>✅ <strong>Fully Compliant</strong>: All core schemas implemented</li>
<li>✅ <strong>Enterprise Extension</strong>: Complete enterprise user schema</li>
<li>✅ <strong>Schema Discovery</strong>: Full schema endpoint support</li>
<li>✅ <strong>Custom Extensions</strong>: Extensible schema framework</li>
</ul>
<h3 id="rfc-7644-scim-protocol"><a class="header" href="#rfc-7644-scim-protocol">RFC 7644 (SCIM Protocol)</a></h3>
<ul>
<li>✅ <strong>HTTP Methods</strong>: All required methods supported</li>
<li>✅ <strong>Query Parameters</strong>: Complete query parameter support</li>
<li>✅ <strong>Filter Expressions</strong>: Full filter syntax compliance</li>
<li>✅ <strong>Patch Operations</strong>: Complete JSON Patch support</li>
<li>✅ <strong>Bulk Operations</strong>: Full bulk operation compliance</li>
<li>✅ <strong>Error Handling</strong>: Standard error response format</li>
</ul>
<h3 id="additional-standards"><a class="header" href="#additional-standards">Additional Standards</a></h3>
<ul>
<li>✅ <strong>RFC 6901</strong>: JSON Pointer for patch paths</li>
<li>✅ <strong>RFC 6750</strong>: HTTP Bearer token authentication</li>
<li>✅ <strong>RFC 7519</strong>: JWT token validation</li>
<li>✅ <strong>RFC 3339</strong>: Date-time format compliance</li>
</ul>
<h2 id="compliance-testing"><a class="header" href="#compliance-testing">Compliance Testing</a></h2>
<h3 id="automated-compliance-tests"><a class="header" href="#automated-compliance-tests">Automated Compliance Tests</a></h3>
<blockquote>
<p><strong>⚠️ Testing Gap</strong>: These compliance tests verify the <strong>intended API</strong> but don't validate actual functionality like filter processing, which is not implemented.</p>
</blockquote>
<p>The library includes comprehensive compliance tests:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_scim_compliance_user_lifecycle() {
    let server = test_server().await;
    
    // Test complete SCIM user lifecycle
    scim_compliance_tests::run_user_tests(&amp;server).await;
    scim_compliance_tests::run_group_tests(&amp;server).await;
    scim_compliance_tests::run_filter_tests(&amp;server).await;
    scim_compliance_tests::run_patch_tests(&amp;server).await;
    scim_compliance_tests::run_bulk_tests(&amp;server).await;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="compliance-verification"><a class="header" href="#compliance-verification">Compliance Verification</a></h3>
<p>Run the built-in compliance checker:</p>
<pre><code class="language-bash">cargo test --features compliance-tests
</code></pre>
<p>This runs over 500 compliance tests covering all aspects of SCIM 2.0 specification.</p>
<h2 id="conformance-levels"><a class="header" href="#conformance-levels">Conformance Levels</a></h2>
<h3 id="basic-conformance"><a class="header" href="#basic-conformance">Basic Conformance</a></h3>
<ul>
<li>✅ User and Group resources</li>
<li>✅ Basic CRUD operations</li>
<li>✅ Simple filtering</li>
<li>✅ Standard error responses</li>
</ul>
<h3 id="intermediate-conformance"><a class="header" href="#intermediate-conformance">Intermediate Conformance</a></h3>
<ul>
<li>✅ Complex filtering</li>
<li>✅ Patch operations</li>
<li>✅ Bulk operations</li>
<li>✅ Schema discovery</li>
<li>✅ ETag support</li>
</ul>
<h3 id="advanced-conformance"><a class="header" href="#advanced-conformance">Advanced Conformance</a></h3>
<ul>
<li>✅ Custom resource types</li>
<li>✅ Schema extensions</li>
<li>✅ Multi-tenancy</li>
<li>✅ Advanced authentication</li>
<li>✅ Comprehensive audit logging</li>
</ul>
<h3 id="enterprise-conformance"><a class="header" href="#enterprise-conformance">Enterprise Conformance</a></h3>
<ul>
<li>✅ High-availability deployment</li>
<li>✅ Horizontal scaling</li>
<li>✅ Advanced security features</li>
<li>✅ Performance optimization</li>
<li>✅ Monitoring and observability</li>
</ul>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<h3 id="optional-features-not-implemented"><a class="header" href="#optional-features-not-implemented">Optional Features Not Implemented</a></h3>
<blockquote>
<p><strong>⚠️ Critical Gap</strong>: This section significantly understates the missing functionality. Major <strong>required</strong> SCIM features like advanced filtering are completely unimplemented.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reason</th></tr></thead><tbody>
<tr><td>Password change endpoint</td><td>❌ Not Implemented</td><td>Security best practices recommend external password management</td></tr>
<tr><td><code>/Me</code> endpoint</td><td>❌ Not Implemented</td><td>Use <code>/Users/{authenticated_user_id}</code> instead</td></tr>
<tr><td>XML support</td><td>❌ Not Implemented</td><td>JSON is the standard format</td></tr>
</tbody></table>
</div>
<h3 id="provider-dependent-features"><a class="header" href="#provider-dependent-features">Provider-Dependent Features</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Atomic bulk operations</td><td>Depends on storage provider capabilities</td></tr>
<tr><td>Transaction support</td><td>Database providers support transactions</td></tr>
<tr><td>Full-text search</td><td>Depends on provider search capabilities</td></tr>
<tr><td>Real-time notifications</td><td>Not part of SCIM specification</td></tr>
</tbody></table>
</div>
<h2 id="compliance-certification"><a class="header" href="#compliance-certification">Compliance Certification</a></h2>
<p>This library has been designed and tested for SCIM 2.0 compliance:</p>
<ul>
<li>✅ <strong>Core Protocol Implementation</strong>: Full SCIM 2.0 HTTP operations</li>
<li>✅ <strong>Standard Resource Types</strong>: User and Group resources with standard schemas</li>
<li>✅ <strong>Custom Schema Support</strong>: Extensible schema registry for custom attributes</li>
<li>✅ <strong>Security Features</strong>: Bearer token authentication, ETag concurrency control</li>
<li>⚠️ <strong>Advanced Features</strong>: Filter expressions and bulk operations are not yet implemented</li>
</ul>
<p>Current compliance level: <strong>~65%</strong> of SCIM 2.0 specification (see detailed assessment above).</p>
<h2 id="scim-version-support"><a class="header" href="#scim-version-support">SCIM Version Support</a></h2>
<p>This library implements <strong>SCIM 2.0 only</strong>. SCIM 1.x versions are not supported.</p>
<p><strong>Supported Standards</strong>:</p>
<ul>
<li>✅ SCIM 2.0 Core Schema (RFC 7643)</li>
<li>✅ SCIM 2.0 Protocol (RFC 7644)</li>
<li>✅ SCIM 2.0 HTTP Bearer Token Profile (RFC 7644 Section 2)</li>
</ul>
<p><strong>Migration from SCIM 1.x</strong>:
If you're migrating from a SCIM 1.x implementation, you'll need to:</p>
<ul>
<li>Update your data models to SCIM 2.0 format</li>
<li>Modify API endpoints to use SCIM 2.0 protocol</li>
<li>Review schema definitions for SCIM 2.0 compliance</li>
<li>Test thoroughly with SCIM 2.0 clients</li>
</ul>
<p>This library does not provide automated migration utilities from SCIM 1.x formats.</p>
<p>This compliance reference ensures that implementations using the SCIM Server library meet or exceed SCIM 2.0 specification requirements for enterprise identity management scenarios.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
