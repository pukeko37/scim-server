<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Testing - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="provider-testing"><a class="header" href="#provider-testing">Provider Testing</a></h1>
<p>This guide covers comprehensive testing strategies for storage and resource providers in the SCIM Server library. Testing ensures your providers work correctly, handle edge cases gracefully, and perform well under load.</p>
<h2 id="testing-architecture"><a class="header" href="#testing-architecture">Testing Architecture</a></h2>
<p>The SCIM Server's two-layer architecture requires testing at both levels:</p>
<ul>
<li><strong>Storage Provider Tests</strong>: Test data persistence, retrieval, and tenant isolation</li>
<li><strong>Resource Provider Tests</strong>: Test SCIM protocol logic, validation, and metadata handling</li>
<li><strong>Integration Tests</strong>: Test the complete stack working together</li>
</ul>
<h2 id="storage-provider-testing"><a class="header" href="#storage-provider-testing">Storage Provider Testing</a></h2>
<h3 id="basic-crud-operations"><a class="header" href="#basic-crud-operations">Basic CRUD Operations</a></h3>
<p>Test fundamental storage operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod storage_tests {
    use super::*;
    use scim_server::storage::{StorageProvider, StorageKey, StoragePrefix, StorageError};
    use serde_json::json;
    use tokio_test;

    async fn test_storage_crud&lt;S: StorageProvider&gt;(storage: S) 
    where 
        S::Error: std::fmt::Debug,
    {
        let key = StorageKey::new("test-tenant", "User", "user-123");
        let data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });

        // Test put operation
        let stored = storage.put(key.clone(), data.clone()).await.unwrap();
        assert_eq!(stored, data);

        // Test get operation
        let retrieved = storage.get(key.clone()).await.unwrap();
        assert_eq!(retrieved, Some(data.clone()));

        // Test exists operation
        let exists = storage.exists(key.clone()).await.unwrap();
        assert!(exists);

        // Test delete operation
        let deleted = storage.delete(key.clone()).await.unwrap();
        assert!(deleted);

        // Verify deletion
        let after_delete = storage.get(key.clone()).await.unwrap();
        assert_eq!(after_delete, None);

        // Test delete non-existent
        let not_deleted = storage.delete(key).await.unwrap();
        assert!(!not_deleted);
    }

    #[tokio::test]
    async fn test_inmemory_storage_crud() {
        let storage = InMemoryStorage::new();
        test_storage_crud(storage).await;
    }

    #[tokio::test]
    async fn test_custom_storage_crud() {
        let storage = MyCustomStorage::new();
        test_storage_crud(storage).await;
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="tenant-isolation-testing"><a class="header" href="#tenant-isolation-testing">Tenant Isolation Testing</a></h3>
<p>Verify that tenant data is properly isolated:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_tenant_isolation() {
    let storage = InMemoryStorage::new();
    
    // Create resources in different tenants
    let tenant1_key = StorageKey::new("tenant-1", "User", "user-123");
    let tenant2_key = StorageKey::new("tenant-2", "User", "user-123");
    
    let tenant1_data = json!({"userName": "alice@tenant1.com"});
    let tenant2_data = json!({"userName": "alice@tenant2.com"});
    
    storage.put(tenant1_key.clone(), tenant1_data.clone()).await.unwrap();
    storage.put(tenant2_key.clone(), tenant2_data.clone()).await.unwrap();
    
    // Verify isolation - same resource ID but different tenants
    let retrieved1 = storage.get(tenant1_key).await.unwrap();
    let retrieved2 = storage.get(tenant2_key).await.unwrap();
    
    assert_eq!(retrieved1, Some(tenant1_data));
    assert_eq!(retrieved2, Some(tenant2_data));
    
    // Verify list operations are also isolated
    let prefix1 = StorageKey::prefix("tenant-1", "User");
    let prefix2 = StorageKey::prefix("tenant-2", "User");
    
    let list1 = storage.list(prefix1, 0, 100).await.unwrap();
    let list2 = storage.list(prefix2, 0, 100).await.unwrap();
    
    assert_eq!(list1.len(), 1);
    assert_eq!(list2.len(), 1);
    assert_ne!(list1[0].1, list2[0].1); // Different data
}
<span class="boring">}</span></code></pre></pre>
<h3 id="query-operations-testing"><a class="header" href="#query-operations-testing">Query Operations Testing</a></h3>
<p>Test list, search, and pagination:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_list_operations() {
    let storage = InMemoryStorage::new();
    let prefix = StorageKey::prefix("tenant-1", "User");
    
    // Create multiple resources
    for i in 1..=10 {
        let key = StorageKey::new("tenant-1", "User", &amp;format!("user-{:03}", i));
        let data = json!({
            "userName": format!("user{}@example.com", i),
            "displayName": format!("User {}", i)
        });
        storage.put(key, data).await.unwrap();
    }
    
    // Test list all
    let all_users = storage.list(prefix.clone(), 0, 100).await.unwrap();
    assert_eq!(all_users.len(), 10);
    
    // Test pagination
    let page1 = storage.list(prefix.clone(), 0, 3).await.unwrap();
    let page2 = storage.list(prefix.clone(), 3, 3).await.unwrap();
    let page3 = storage.list(prefix.clone(), 6, 3).await.unwrap();
    let page4 = storage.list(prefix.clone(), 9, 3).await.unwrap();
    
    assert_eq!(page1.len(), 3);
    assert_eq!(page2.len(), 3);
    assert_eq!(page3.len(), 3);
    assert_eq!(page4.len(), 1);
    
    // Verify no overlap between pages
    let all_ids: HashSet&lt;_&gt; = page1.iter().chain(&amp;page2).chain(&amp;page3).chain(&amp;page4)
        .map(|(key, _)| key.resource_id())
        .collect();
    assert_eq!(all_ids.len(), 10);
}

#[tokio::test]
async fn test_find_by_attribute() {
    let storage = InMemoryStorage::new();
    let prefix = StorageKey::prefix("tenant-1", "User");
    
    // Create test users
    let users = vec![
        ("user-1", "alice@example.com", "Alice Smith"),
        ("user-2", "bob@example.com", "Bob Jones"),
        ("user-3", "alice@company.com", "Alice Johnson"),
    ];
    
    for (id, username, display_name) in users {
        let key = StorageKey::new("tenant-1", "User", id);
        let data = json!({
            "userName": username,
            "displayName": display_name
        });
        storage.put(key, data).await.unwrap();
    }
    
    // Test exact match
    let alice_users = storage.find_by_attribute(
        prefix.clone(),
        "userName",
        "alice@example.com"
    ).await.unwrap();
    assert_eq!(alice_users.len(), 1);
    assert_eq!(alice_users[0].0.resource_id(), "user-1");
    
    // Test no matches
    let no_matches = storage.find_by_attribute(
        prefix.clone(),
        "userName",
        "nonexistent@example.com"
    ).await.unwrap();
    assert_eq!(no_matches.len(), 0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="concurrent-access-testing"><a class="header" href="#concurrent-access-testing">Concurrent Access Testing</a></h3>
<p>Test thread safety and concurrent operations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::Arc;
use tokio::task::JoinSet;

#[tokio::test]
async fn test_concurrent_access() {
    let storage = Arc::new(InMemoryStorage::new());
    let mut join_set = JoinSet::new();
    
    // Spawn multiple concurrent operations
    for i in 0..10 {
        let storage_clone = Arc::clone(&amp;storage);
        join_set.spawn(async move {
            let key = StorageKey::new("tenant-1", "User", &amp;format!("user-{}", i));
            let data = json!({
                "userName": format!("user{}@example.com", i),
                "displayName": format!("User {}", i)
            });
            
            // Perform multiple operations
            storage_clone.put(key.clone(), data.clone()).await.unwrap();
            let retrieved = storage_clone.get(key.clone()).await.unwrap();
            assert_eq!(retrieved, Some(data));
            
            storage_clone.delete(key).await.unwrap()
        });
    }
    
    // Wait for all operations to complete
    while let Some(result) = join_set.join_next().await {
        result.unwrap(); // Panic if any task failed
    }
    
    // Verify final state
    let prefix = StorageKey::prefix("tenant-1", "User");
    let remaining = storage.list(prefix, 0, 100).await.unwrap();
    assert_eq!(remaining.len(), 0);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling-testing"><a class="header" href="#error-handling-testing">Error Handling Testing</a></h3>
<p>Test error conditions and edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_error_handling() {
    let storage = InMemoryStorage::new();
    
    // Test get non-existent resource
    let key = StorageKey::new("tenant-1", "User", "non-existent");
    let result = storage.get(key.clone()).await.unwrap();
    assert_eq!(result, None);
    
    // Test delete non-existent resource
    let deleted = storage.delete(key).await.unwrap();
    assert!(!deleted);
    
    // Test invalid operations (implementation specific)
    // For example, if your storage has size limits:
    // let large_data = json!({"data": "x".repeat(1_000_000)});
    // let result = storage.put(key, large_data).await;
    // assert!(result.is_err());
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resource-provider-testing"><a class="header" href="#resource-provider-testing">Resource Provider Testing</a></h2>
<h3 id="scim-protocol-testing"><a class="header" href="#scim-protocol-testing">SCIM Protocol Testing</a></h3>
<p>Test SCIM-specific functionality:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod resource_provider_tests {
    use super::*;
    use scim_server::{
        providers::StandardResourceProvider,
        storage::InMemoryStorage,
        resource::{RequestContext, TenantContext, ResourceProvider},
    };
    use serde_json::json;

    #[tokio::test]
    async fn test_resource_metadata_generation() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::with_generated_id();
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        let user = provider.create_resource("User", user_data, &amp;context).await.unwrap();
        
        // Verify SCIM metadata is generated
        assert!(user.get_id().is_some());
        assert!(user.get_created().is_some());
        assert!(user.get_last_modified().is_some());
        assert!(user.get_version().is_some());
        assert_eq!(user.get_username().unwrap(), "alice@example.com");
    }

    #[tokio::test]
    async fn test_tenant_context_handling() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        
        // Single-tenant context
        let single_context = RequestContext::with_generated_id();
        
        // Multi-tenant context
        let tenant_context = TenantContext::new("tenant-1".to_string(), "client-1".to_string());
        let multi_context = RequestContext::with_tenant_generated_id(tenant_context);
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        // Create users in different contexts
        let single_user = provider.create_resource("User", user_data.clone(), &amp;single_context).await.unwrap();
        let multi_user = provider.create_resource("User", user_data, &amp;multi_context).await.unwrap();
        
        // Verify they are isolated
        let single_list = provider.list_resources("User", None, &amp;single_context).await.unwrap();
        let multi_list = provider.list_resources("User", None, &amp;multi_context).await.unwrap();
        
        assert_eq!(single_list.len(), 1);
        assert_eq!(multi_list.len(), 1);
        assert_ne!(single_user.get_id(), multi_user.get_id());
    }

    #[tokio::test]
    async fn test_duplicate_username_handling() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::with_generated_id();
        
        let user_data = json!({
            "userName": "alice@example.com",
            "displayName": "Alice Smith"
        });
        
        // Create first user
        let user1 = provider.create_resource("User", user_data.clone(), &amp;context).await.unwrap();
        
        // Try to create duplicate username
        let result = provider.create_resource("User", user_data, &amp;context).await;
        
        // Should fail with conflict
        assert!(result.is_err());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="conditional-operations-testing"><a class="header" href="#conditional-operations-testing">Conditional Operations Testing</a></h3>
<p>Test ETag-based concurrency control:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_conditional_operations() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::with_generated_id();
    
    // Create a user
    let user_data = json!({
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    });
    
    let user = provider.create_resource("User", user_data, &amp;context).await.unwrap();
    let user_id = user.get_id().unwrap();
    let version = user.get_version().unwrap();
    
    // Test successful conditional update
    let updated_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "displayName": "Alice Updated"
    });
    
    let result = provider.conditional_update(
        "User",
        user_id,
        updated_data,
        &amp;ScimVersion::from_etag(version),
        &amp;context,
    ).await.unwrap();
    
    match result {
        ConditionalResult::Success(updated_user) =&gt; {
            assert_eq!(updated_user.get_display_name().unwrap(), "Alice Updated");
            assert_ne!(updated_user.get_version().unwrap(), version); // Version should change
        }
        ConditionalResult::Conflict(_) =&gt; panic!("Should not have conflict"),
    }
    
    // Test conditional update with wrong version (should conflict)
    let wrong_version_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "displayName": "Alice Wrong Version"
    });
    
    let conflict_result = provider.conditional_update(
        "User",
        user_id,
        wrong_version_data,
        &amp;ScimVersion::from_etag(version), // Old version
        &amp;context,
    ).await.unwrap();
    
    match conflict_result {
        ConditionalResult::Success(_) =&gt; panic!("Should have conflict"),
        ConditionalResult::Conflict(conflict) =&gt; {
            assert_eq!(conflict.expected_version, version);
            assert_ne!(conflict.current_version, version);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h2>
<h3 id="full-stack-testing"><a class="header" href="#full-stack-testing">Full Stack Testing</a></h3>
<p>Test the complete SCIM workflow:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_full_scim_workflow() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let context = RequestContext::with_generated_id();
    
    // Create user
    let create_data = json!({
        "userName": "alice@example.com",
        "name": {
            "givenName": "Alice",
            "familyName": "Smith"
        },
        "emails": [{
            "value": "alice@example.com",
            "primary": true
        }]
    });
    
    let user = provider.create_resource("User", create_data, &amp;context).await.unwrap();
    let user_id = user.get_id().unwrap();
    
    // Read user
    let retrieved = provider.get_resource("User", user_id, &amp;context).await.unwrap();
    assert!(retrieved.is_some());
    let retrieved_user = retrieved.unwrap();
    assert_eq!(retrieved_user.get_username().unwrap(), "alice@example.com");
    
    // Update user
    let update_data = json!({
        "id": user_id,
        "userName": "alice@example.com",
        "name": {
            "givenName": "Alice",
            "familyName": "Johnson"
        },
        "emails": [{
            "value": "alice@example.com",
            "primary": true
        }]
    });
    
    let updated_user = provider.update_resource("User", user_id, update_data, &amp;context).await.unwrap();
    assert_eq!(updated_user.get_family_name().unwrap(), "Johnson");
    
    // List users
    let users = provider.list_resources("User", None, &amp;context).await.unwrap();
    assert_eq!(users.len(), 1);
    
    // Search user
    let found = provider.find_resource_by_attribute(
        "User",
        "userName",
        &amp;json!("alice@example.com"),
        &amp;context,
    ).await.unwrap();
    assert!(found.is_some());
    
    // Delete user
    let deleted = provider.delete_resource("User", user_id, &amp;context).await.unwrap();
    assert!(deleted);
    
    // Verify deletion
    let after_delete = provider.get_resource("User", user_id, &amp;context).await.unwrap();
    assert!(after_delete.is_none());
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-tenant-integration-testing"><a class="header" href="#multi-tenant-integration-testing">Multi-Tenant Integration Testing</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_multi_tenant_integration() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    
    // Create contexts for different tenants
    let tenant1_context = RequestContext::with_tenant_generated_id(
        TenantContext::new("tenant-1".to_string(), "client-1".to_string())
    );
    let tenant2_context = RequestContext::with_tenant_generated_id(
        TenantContext::new("tenant-2".to_string(), "client-2".to_string())
    );
    
    // Create users in different tenants
    let user_data = json!({
        "userName": "alice@example.com",
        "displayName": "Alice Smith"
    });
    
    let tenant1_user = provider.create_resource("User", user_data.clone(), &amp;tenant1_context).await.unwrap();
    let tenant2_user = provider.create_resource("User", user_data, &amp;tenant2_context).await.unwrap();
    
    // Verify isolation
    let tenant1_users = provider.list_resources("User", None, &amp;tenant1_context).await.unwrap();
    let tenant2_users = provider.list_resources("User", None, &amp;tenant2_context).await.unwrap();
    
    assert_eq!(tenant1_users.len(), 1);
    assert_eq!(tenant2_users.len(), 1);
    assert_ne!(tenant1_user.get_id(), tenant2_user.get_id());
    
    // Verify cross-tenant access fails
    let cross_access = provider.get_resource(
        "User",
        tenant1_user.get_id().unwrap(),
        &amp;tenant2_context,
    ).await.unwrap();
    assert!(cross_access.is_none()); // Should not find user from different tenant
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-testing"><a class="header" href="#performance-testing">Performance Testing</a></h2>
<h3 id="load-testing"><a class="header" href="#load-testing">Load Testing</a></h3>
<p>Test provider performance under load:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;
use tokio::task::JoinSet;

#[tokio::test]
async fn test_provider_performance() {
    let storage = InMemoryStorage::new();
    let provider = Arc::new(StandardResourceProvider::new(storage));
    
    let num_operations = 1000;
    let num_concurrent = 10;
    
    let start = Instant::now();
    let mut join_set = JoinSet::new();
    
    for batch in 0..num_concurrent {
        let provider_clone = Arc::clone(&amp;provider);
        join_set.spawn(async move {
            let context = RequestContext::with_generated_id();
            
            for i in 0..(num_operations / num_concurrent) {
                let user_id = format!("user-{}-{}", batch, i);
                let user_data = json!({
                    "userName": format!("{}@example.com", user_id),
                    "displayName": format!("User {}", user_id)
                });
                
                // Create, read, update, delete cycle
                let user = provider_clone.create_resource("User", user_data, &amp;context).await.unwrap();
                let id = user.get_id().unwrap();
                
                let retrieved = provider_clone.get_resource("User", id, &amp;context).await.unwrap();
                assert!(retrieved.is_some());
                
                let updated_data = json!({
                    "id": id,
                    "userName": format!("{}@example.com", user_id),
                    "displayName": format!("Updated User {}", user_id)
                });
                
                let updated = provider_clone.update_resource("User", id, updated_data, &amp;context).await.unwrap();
                assert_eq!(updated.get_display_name().unwrap(), format!("Updated User {}", user_id));
                
                let deleted = provider_clone.delete_resource("User", id, &amp;context).await.unwrap();
                assert!(deleted);
            }
        });
    }
    
    // Wait for all operations to complete
    while let Some(result) = join_set.join_next().await {
        result.unwrap();
    }
    
    let duration = start.elapsed();
    let ops_per_second = (num_operations * 4) as f64 / duration.as_secs_f64(); // 4 ops per iteration
    
    println!("Completed {} operations in {:?}", num_operations * 4, duration);
    println!("Performance: {:.2} operations/second", ops_per_second);
    
    // Assert minimum performance threshold (adjust based on requirements)
    assert!(ops_per_second &gt; 100.0, "Performance below threshold: {:.2} ops/sec", ops_per_second);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-usage-testing"><a class="header" href="#memory-usage-testing">Memory Usage Testing</a></h3>
<p>Test memory efficiency and leak detection:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[tokio::test]
async fn test_memory_usage() {
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage.clone());
    let context = RequestContext::with_generated_id();
    
    // Create many resources
    let num_resources = 10000;
    for i in 0..num_resources {
        let user_data = json!({
            "userName": format!("user{}@example.com", i),
            "displayName": format!("User {}", i)
        });
        
        provider.create_resource("User", user_data, &amp;context).await.unwrap();
    }
    
    // Check storage stats
    let stats = storage.stats().await;
    assert_eq!(stats.total_resources, num_resources);
    assert_eq!(stats.tenant_count, 1); // All in default tenant
    
    // Delete all resources
    let users = provider.list_resources("User", None, &amp;context).await.unwrap();
    for user in users {
        provider.delete_resource("User", user.get_id().unwrap(), &amp;context).await.unwrap();
    }
    
    // Verify cleanup
    let final_stats = storage.stats().await;
    assert_eq!(final_stats.total_resources, 0);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="test-utilities-and-helpers"><a class="header" href="#test-utilities-and-helpers">Test Utilities and Helpers</a></h2>
<h3 id="reusable-test-fixtures"><a class="header" href="#reusable-test-fixtures">Reusable Test Fixtures</a></h3>
<p>Create common test utilities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod test_utils {
    use super::*;
    use serde_json::{json, Value};
    use uuid::Uuid;

    pub fn random_tenant_id() -&gt; String {
        format!("test-tenant-{}", Uuid::new_v4())
    }

    pub fn sample_user_data(username: &amp;str) -&gt; Value {
        json!({
            "userName": username,
            "name": {
                "givenName": "Test",
                "familyName": "User"
            },
            "displayName": format!("Test User {}", username),
            "emails": [{
                "value": username,
                "primary": true
            }]
        })
    }

    pub fn sample_group_data(name: &amp;str) -&gt; Value {
        json!({
            "displayName": name,
            "members": []
        })
    }

    pub async fn create_test_provider() -&gt; StandardResourceProvider&lt;InMemoryStorage&gt; {
        let storage = InMemoryStorage::new();
        StandardResourceProvider::new(storage)
    }

    pub async fn setup_test_data(
        provider: &amp;StandardResourceProvider&lt;InMemoryStorage&gt;,
        context: &amp;RequestContext,
    ) -&gt; Vec&lt;String&gt; {
        let mut user_ids = Vec::new();
        
        for i in 1..=5 {
            let username = format!("testuser{}@example.com", i);
            let user_data = sample_user_data(&amp;username);
            
            let user = provider.create_resource("User", user_data, context).await.unwrap();
            user_ids.push(user.get_id().unwrap().to_string());
        }
        
        user_ids
    }
}

// Usage in tests
#[tokio::test]
async fn test_with_utilities() {
    let provider = test_utils::create_test_provider().await;
    let context = RequestContext::with_generated_id();
    
    let user_ids = test_utils::setup_test_data(&amp;provider, &amp;context).await;
    assert_eq!(user_ids.len(), 5);
    
    // Your test logic here...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="property-based-testing"><a class="header" href="#property-based-testing">Property-Based Testing</a></h3>
<p>Use property-based testing for edge cases:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use proptest::prelude::*;

proptest! {
    #[test]
    fn test_resource_id_roundtrip(
        tenant_id in "[a-zA-Z0-9-]{1,50}",
        resource_type in "[a-zA-Z]{1,20}",
        resource_id in "[a-zA-Z0-9-]{1,50}"
    ) {
        tokio_test::block_on(async {
            let storage = InMemoryStorage::new();
            let key = StorageKey::new(&amp;tenant_id, &amp;resource_type, &amp;resource_id);
            let data = json!({"test": "data"});
            
            let stored = storage.put(key.clone(), data.clone()).await.unwrap();
            let retrieved = storage.get(key).await.unwrap();
            
            prop_assert_eq!(retrieved, Some(stored));
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="continuous-integration-testing"><a class="header" href="#continuous-integration-testing">Continuous Integration Testing</a></h2>
<h3 id="github-actions-example"><a class="header" href="#github-actions-example">GitHub Actions Example</a></h3>
<pre><code class="language-yaml">name: Provider Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rust: [stable, beta, nightly]
        
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: ${{ matrix.rust }}
        override: true
        components: rustfmt, clippy
        
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/registry
          ~/.cargo/git
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        
    - name: Run tests
      run: cargo test --all-features
      
    - name: Run storage provider tests
      run: cargo test storage::tests --all-features
      
    - name: Run resource provider tests  
      run: cargo test providers::tests --all-features
      
    - name: Run integration tests
      run: cargo test integration --all-features
      
    - name: Check formatting
      run: cargo fmt -- --check
      
    - name: Run clippy
      run: cargo clippy -- -D warnings
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="test-organization"><a class="header" href="#test-organization">Test Organization</a></h3>
<ol>
<li><strong>Separate Concerns</strong>: Test storage and resource providers separately</li>
<li><strong>Use Descriptive Names</strong>: Test names should clearly indicate what is being tested</li>
<li><strong>Test Edge Cases</strong>: Include tests for error conditions and boundary cases</li>
<li><strong>Performance Regression</strong>: Include performance tests in CI</li>
<li><strong>Documentation</strong>: Document complex test scenarios</li>
</ol>
<h3 id="test-data-management"><a class="header" href="#test-data-management">Test Data Management</a></h3>
<ol>
<li><strong>Isolated Tests</strong>: Each test should create its own data</li>
<li><strong>Cleanup</strong>: Tests should clean up after themselves</li>
<li><strong>Deterministic</strong>: Tests should produce consistent results</li>
<li><strong>Realistic Data</strong>: Use realistic test data that matches production patterns</li>
</ol>
<h3 id="error-testing"><a class="header" href="#error-testing">Error Testing</a></h3>
<ol>
<li><strong>Expected Errors</strong>: Test that errors are properly handled and returned</li>
<li><strong>Recovery</strong>: Test that providers can recover from transient errors</li>
<li><strong>Resource Cleanup</strong>: Ensure resources are properly cleaned up on errors</li>
</ol>
<p>This comprehensive testing approach ensures your providers are reliable, performant, and ready for production use.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../providers/advanced.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../schemas/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../providers/advanced.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../schemas/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
