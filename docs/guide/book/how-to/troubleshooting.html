<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Troubleshooting - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>This guide helps you diagnose and resolve common issues when working with the SCIM Server library. It covers typical problems, debugging techniques, and performance optimization.</p>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<h3 id="connection-and-network-problems"><a class="header" href="#connection-and-network-problems">Connection and Network Problems</a></h3>
<h4 id="connection-refused-or-unable-to-connect"><a class="header" href="#connection-refused-or-unable-to-connect">"Connection refused" or "Unable to connect"</a></h4>
<p><strong>Symptoms:</strong></p>
<ul>
<li>Server fails to start</li>
<li>Client connections are rejected</li>
<li>Network timeouts</li>
</ul>
<p><strong>Causes &amp; Solutions:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check if port is already in use
use tokio::net::TcpListener;

// This will fail if port is occupied
let listener = TcpListener::bind("0.0.0.0:3000").await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution 1: Change port</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Try a different port
let listener = TcpListener::bind("0.0.0.0:3001").await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Solution 2: Find and kill process using port</strong></p>
<pre><code class="language-bash"># Find process using port 3000
lsof -i :3000
# Kill the process
kill -9 &lt;PID&gt;
</code></pre>
<p><strong>Solution 3: Bind to correct interface</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For local development
let listener = TcpListener::bind("127.0.0.1:3000").await?;

// For production (all interfaces)
let listener = TcpListener::bind("0.0.0.0:3000").await?;
<span class="boring">}</span></code></pre></pre>
<h4 id="database-connection-issues"><a class="header" href="#database-connection-issues">Database Connection Issues</a></h4>
<p><strong>Error: "Failed to connect to database"</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::DatabaseProvider;

// Add connection retry logic
async fn connect_with_retry(url: &amp;str, max_retries: u32) -&gt; Result&lt;DatabaseProvider, Error&gt; {
    let mut attempts = 0;
    
    loop {
        match DatabaseProvider::new(url).await {
            Ok(provider) =&gt; return Ok(provider),
            Err(e) if attempts &lt; max_retries =&gt; {
                attempts += 1;
                println!("Connection attempt {} failed: {}. Retrying in 5 seconds...", attempts, e);
                tokio::time::sleep(Duration::from_secs(5)).await;
            },
            Err(e) =&gt; return Err(e.into()),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Common database URL formats:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// PostgreSQL
"postgresql://username:password@localhost:5432/scim_db"

// SQLite
"sqlite:./scim.db"
"sqlite::memory:" // For testing

// MySQL
"mysql://username:password@localhost:3306/scim_db"
<span class="boring">}</span></code></pre></pre>
<h3 id="authentication-and-authorization-issues"><a class="header" href="#authentication-and-authorization-issues">Authentication and Authorization Issues</a></h3>
<h4 id="401-unauthorized-responses"><a class="header" href="#401-unauthorized-responses">"401 Unauthorized" responses</a></h4>
<p><strong>Check authentication configuration:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn debug_auth_middleware(
    headers: HeaderMap,
    request: Request,
    next: Next,
) -&gt; Result&lt;Response, StatusCode&gt; {
    // Log all headers for debugging
    for (name, value) in headers.iter() {
        println!("Header: {} = {:?}", name, value);
    }
    
    // Check for Authorization header
    if let Some(auth_header) = headers.get("Authorization") {
        println!("Auth header found: {:?}", auth_header);
    } else {
        println!("No Authorization header found");
        return Err(StatusCode::UNAUTHORIZED);
    }
    
    Ok(next.run(request).await)
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Common authentication problems:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Problem: Missing Bearer prefix
// Wrong: "abc123def456"
// Correct: "Bearer abc123def456"

// Problem: Expired tokens
let now = chrono::Utc::now().timestamp() as usize;
if token_claims.exp &lt; now {
    return Err(StatusCode::UNAUTHORIZED);
}

// Problem: Incorrect Base64 encoding for Basic auth
use base64::{Engine as _, engine::general_purpose};
let encoded = general_purpose::STANDARD.encode("username:password");
println!("Correct Basic auth: Basic {}", encoded);
<span class="boring">}</span></code></pre></pre>
<h4 id="403-forbidden-responses"><a class="header" href="#403-forbidden-responses">"403 Forbidden" responses</a></h4>
<p><strong>Debug permission checking:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_permissions(user_perms: &amp;[String], required_perm: &amp;str) -&gt; bool {
    println!("User permissions: {:?}", user_perms);
    println!("Required permission: {}", required_perm);
    
    let has_permission = user_perms.contains(&amp;required_perm.to_string());
    println!("Permission granted: {}", has_permission);
    
    has_permission
}
<span class="boring">}</span></code></pre></pre>
<h3 id="resource-and-data-issues"><a class="header" href="#resource-and-data-issues">Resource and Data Issues</a></h3>
<h4 id="404-not-found-for-existing-resources"><a class="header" href="#404-not-found-for-existing-resources">"404 Not Found" for existing resources</a></h4>
<p><strong>Check tenant isolation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you're using the correct tenant ID
let user = provider.get_user("correct-tenant-id", &amp;user_id).await?;

// Debug tenant data
let all_tenants = provider.list_all_tenants().await?;
println!("Available tenants: {:?}", all_tenants);
<span class="boring">}</span></code></pre></pre>
<p><strong>Verify resource IDs:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// UUIDs are case-sensitive
let user_id = "2819c223-7f76-453a-919d-413861904646"; // Correct
let user_id = "2819C223-7F76-453A-919D-413861904646"; // Wrong case

// Check if resource exists
if let Some(user) = provider.get_user(tenant_id, user_id).await? {
    println!("User found: {}", user.username());
} else {
    println!("User not found with ID: {}", user_id);
    
    // List all users to debug
    let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
    for user in all_users.resources {
        println!("Existing user: {} ({})", user.username(), user.id());
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="409-conflict-on-resource-creation"><a class="header" href="#409-conflict-on-resource-creation">"409 Conflict" on resource creation</a></h4>
<p><strong>Check for duplicate constraints:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Debug uniqueness violations
match provider.create_user(tenant_id, user).await {
    Err(ProviderError::Conflict(msg)) =&gt; {
        println!("Conflict detected: {}", msg);
        
        // Check for existing username
        if let Some(existing) = provider.find_user_by_username(tenant_id, &amp;user.username()).await? {
            println!("User with username '{}' already exists: {}", user.username(), existing.id());
        }
        
        // Check for existing email
        if let Some(email) = user.primary_email() {
            if let Some(existing) = provider.find_user_by_email(tenant_id, email).await? {
                println!("User with email '{}' already exists: {}", email, existing.id());
            }
        }
    },
    Ok(created_user) =&gt; println!("User created successfully: {}", created_user.id()),
    Err(e) =&gt; println!("Unexpected error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="412-precondition-failed-on-updates"><a class="header" href="#412-precondition-failed-on-updates">"412 Precondition Failed" on updates</a></h4>
<p><strong>ETag version conflicts:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Always fetch latest version before update
let mut user = provider.get_user(tenant_id, user_id).await?
    .ok_or("User not found")?;

println!("Current user version: {}", user.meta().version);

// Make your changes
user.set_given_name("Updated Name");

// Update with current version
match provider.update_user(tenant_id, user).await {
    Ok(updated_user) =&gt; {
        println!("Update successful. New version: {}", updated_user.meta().version);
    },
    Err(ProviderError::VersionConflict { current_version, provided_version }) =&gt; {
        println!("Version conflict: expected {}, got {}", current_version, provided_version);
        
        // Retry with fresh data
        let fresh_user = provider.get_user(tenant_id, user_id).await?;
        // Apply changes to fresh user and retry
    },
    Err(e) =&gt; println!("Update failed: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="validation-and-schema-issues"><a class="header" href="#validation-and-schema-issues">Validation and Schema Issues</a></h3>
<h4 id="400-bad-request-with-validation-errors"><a class="header" href="#400-bad-request-with-validation-errors">"400 Bad Request" with validation errors</a></h4>
<p><strong>Debug JSON parsing:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json;

// Test JSON deserialization
let json_str = r#"{"invalid": "json"}"#;
match serde_json::from_str::&lt;ScimUser&gt;(json_str) {
    Ok(user) =&gt; println!("User parsed successfully"),
    Err(e) =&gt; {
        println!("JSON parsing failed: {}", e);
        println!("Error location: line {}, column {}", e.line(), e.column());
    }
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Validate required fields:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check for missing required fields
match ScimUser::builder()
    .username("test@example.com")
    // Missing other required fields
    .build() 
{
    Ok(user) =&gt; println!("User created: {}", user.id()),
    Err(ValidationError::RequiredField(field)) =&gt; {
        println!("Missing required field: {}", field);
    },
    Err(e) =&gt; println!("Validation error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Schema validation debugging:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Check schema compliance
let user = ScimUser::builder()
    .username("test@example.com")
    .given_name("Test")
    .family_name("User")
    .build()?;

// Validate against schema
match schema_registry.validate_user(&amp;user) {
    Ok(_) =&gt; println!("User is valid according to schema"),
    Err(ValidationError::SchemaViolation { field, message }) =&gt; {
        println!("Schema violation in field '{}': {}", field, message);
    },
    Err(e) =&gt; println!("Validation error: {}", e),
}
<span class="boring">}</span></code></pre></pre>
<h2 id="debugging-techniques"><a class="header" href="#debugging-techniques">Debugging Techniques</a></h2>
<h3 id="enable-detailed-logging"><a class="header" href="#enable-detailed-logging">Enable Detailed Logging</a></h3>
<pre><pre class="playground"><code class="language-rust">use tracing::{info, warn, error, debug};
use tracing_subscriber::{EnvFilter, fmt};

// Set up comprehensive logging
fn setup_logging() {
    let filter = EnvFilter::from_default_env()
        .add_directive("scim_server=debug".parse().unwrap())
        .add_directive("sqlx=info".parse().unwrap())
        .add_directive("hyper=info".parse().unwrap());

    fmt()
        .with_env_filter(filter)
        .with_target(true)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();
}

// Use in your application
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    setup_logging();
    
    info!("Starting SCIM server");
    
    // Your application code...
    
    Ok(())
}</code></pre></pre>
<p><strong>Environment variables for logging:</strong></p>
<pre><code class="language-bash"># Enable debug logging
export RUST_LOG=scim_server=debug,sqlx=info

# Enable trace-level logging (very verbose)
export RUST_LOG=scim_server=trace

# Log only errors
export RUST_LOG=scim_server=error
</code></pre>
<h3 id="requestresponse-debugging"><a class="header" href="#requestresponse-debugging">Request/Response Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{
    body::Body,
    extract::Request,
    middleware::Next,
    response::Response,
};

async fn debug_middleware(
    request: Request,
    next: Next,
) -&gt; Response {
    let method = request.method().clone();
    let uri = request.uri().clone();
    let headers = request.headers().clone();
    
    // Log request
    debug!("Incoming request: {} {}", method, uri);
    for (name, value) in headers.iter() {
        debug!("Request header: {}: {:?}", name, value);
    }
    
    let start = std::time::Instant::now();
    let response = next.run(request).await;
    let duration = start.elapsed();
    
    // Log response
    debug!(
        "Response: {} {} - {} in {:?}",
        method,
        uri,
        response.status(),
        duration
    );
    
    response
}

// Add to your router
let app = Router::new()
    .nest("/scim/v2", scim_routes())
    .layer(middleware::from_fn(debug_middleware));
<span class="boring">}</span></code></pre></pre>
<h3 id="database-query-debugging"><a class="header" href="#database-query-debugging">Database Query Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Enable SQL query logging for sqlx
use sqlx::postgres::PgPoolOptions;

let pool = PgPoolOptions::new()
    .max_connections(10)
    .connect(&amp;database_url)
    .await?;

// Queries will be logged when RUST_LOG includes sqlx=debug
<span class="boring">}</span></code></pre></pre>
<h3 id="provider-state-inspection"><a class="header" href="#provider-state-inspection">Provider State Inspection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For InMemoryProvider, add debugging methods
impl InMemoryProvider {
    pub async fn debug_state(&amp;self) {
        let users = self.users.read().await;
        let groups = self.groups.read().await;
        
        println!("=== Provider State Debug ===");
        for (tenant_id, tenant_users) in users.iter() {
            println!("Tenant '{}' has {} users:", tenant_id, tenant_users.len());
            for (user_id, user) in tenant_users.iter() {
                println!("  User: {} ({})", user.username(), user_id);
            }
        }
        
        for (tenant_id, tenant_groups) in groups.iter() {
            println!("Tenant '{}' has {} groups:", tenant_id, tenant_groups.len());
            for (group_id, group) in tenant_groups.iter() {
                println!("  Group: {} ({}) with {} members", 
                         group.display_name(), group_id, group.members().len());
            }
        }
        println!("=== End Debug ===");
    }
}

// Use in your code
provider.debug_state().await;
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-issues"><a class="header" href="#performance-issues">Performance Issues</a></h2>
<h3 id="slow-database-queries"><a class="header" href="#slow-database-queries">Slow Database Queries</a></h3>
<p><strong>Add query timing:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Instant;

async fn timed_query&lt;T, F, Fut&gt;(operation: F) -&gt; Result&lt;T, Error&gt;
where
    F: FnOnce() -&gt; Fut,
    Fut: Future&lt;Output = Result&lt;T, Error&gt;&gt;,
{
    let start = Instant::now();
    let result = operation().await;
    let duration = start.elapsed();
    
    if duration &gt; Duration::from_millis(100) {
        warn!("Slow query detected: {:?}", duration);
    }
    
    result
}

// Usage
let users = timed_query(|| provider.list_users(tenant_id, &amp;options)).await?;
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize filtering:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current approach: Load all users then filter in memory
// Note: Database-level filtering is not yet implemented
let all_users = provider.list_users(tenant_id, &amp;ListOptions::default()).await?;
let filtered: Vec&lt;_&gt; = all_users.resources.into_iter()
    .filter(|u| u.department() == Some("Engineering"))
    .collect();

// For large datasets, consider implementing pagination
let options = ListOptions::builder()
    .count(Some(50))  // Limit results
    .start_index(Some(1))
    .build();
let paginated_users = provider.list_users(tenant_id, &amp;options).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="memory-issues"><a class="header" href="#memory-issues">Memory Issues</a></h3>
<p><strong>Monitor memory usage:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sysinfo::{System, SystemExt};

fn log_memory_usage() {
    let mut system = System::new_all();
    system.refresh_memory();
    
    let used = system.used_memory();
    let total = system.total_memory();
    let percentage = (used as f64 / total as f64) * 100.0;
    
    info!("Memory usage: {} MB / {} MB ({:.1}%)", 
          used / 1024 / 1024, 
          total / 1024 / 1024, 
          percentage);
}

// Check periodically
tokio::spawn(async {
    loop {
        log_memory_usage();
        tokio::time::sleep(Duration::from_secs(60)).await;
    }
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Optimize large result sets:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Use pagination for large datasets
let mut start_index = 1;
let page_size = 100;

loop {
    let options = ListOptions::builder()
        .start_index(start_index)
        .count(page_size)
        .build();
    
    let page = provider.list_users(tenant_id, &amp;options).await?;
    
    // Process page
    for user in page.resources {
        process_user(user).await?;
    }
    
    // Check if we're done
    if page.resources.len() &lt; page_size {
        break;
    }
    
    start_index += page_size;
}
<span class="boring">}</span></code></pre></pre>
<h2 id="health-checks-and-monitoring"><a class="header" href="#health-checks-and-monitoring">Health Checks and Monitoring</a></h2>
<h3 id="implement-health-endpoints"><a class="header" href="#implement-health-endpoints">Implement Health Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::Json, http::StatusCode};
use serde_json::json;

async fn health_check(
    State(state): State&lt;AppState&gt;,
) -&gt; Result&lt;Json&lt;serde_json::Value&gt;, StatusCode&gt; {
    // Check provider health
    let provider_health = state.provider.health_check().await
        .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;
    
    // Check database connectivity
    let db_status = match state.provider.get_user("health-check", "non-existent").await {
        Ok(None) | Err(ProviderError::NotFound { .. }) =&gt; "healthy",
        Err(_) =&gt; "unhealthy",
    };
    
    let response = json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now(),
        "version": env!("CARGO_PKG_VERSION"),
        "components": {
            "provider": provider_health.status,
            "database": db_status
        }
    });
    
    Ok(Json(response))
}

// Add to router
let app = Router::new()
    .route("/health", get(health_check))
    .nest("/scim/v2", scim_routes());
<span class="boring">}</span></code></pre></pre>
<h3 id="metrics-collection"><a class="header" href="#metrics-collection">Metrics Collection</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;

#[derive(Clone)]
struct Metrics {
    requests_total: Arc&lt;AtomicU64&gt;,
    requests_errors: Arc&lt;AtomicU64&gt;,
    users_created: Arc&lt;AtomicU64&gt;,
    users_updated: Arc&lt;AtomicU64&gt;,
}

impl Metrics {
    fn new() -&gt; Self {
        Self {
            requests_total: Arc::new(AtomicU64::new(0)),
            requests_errors: Arc::new(AtomicU64::new(0)),
            users_created: Arc::new(AtomicU64::new(0)),
            users_updated: Arc::new(AtomicU64::new(0)),
        }
    }
    
    fn increment_requests(&amp;self) {
        self.requests_total.fetch_add(1, Ordering::Relaxed);
    }
    
    fn increment_errors(&amp;self) {
        self.requests_errors.fetch_add(1, Ordering::Relaxed);
    }
}

async fn metrics_endpoint(
    State(metrics): State&lt;Metrics&gt;,
) -&gt; Json&lt;serde_json::Value&gt; {
    Json(json!({
        "requests_total": metrics.requests_total.load(Ordering::Relaxed),
        "requests_errors": metrics.requests_errors.load(Ordering::Relaxed),
        "users_created": metrics.users_created.load(Ordering::Relaxed),
        "users_updated": metrics.users_updated.load(Ordering::Relaxed),
    }))
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-and-validation"><a class="header" href="#testing-and-validation">Testing and Validation</a></h2>
<h3 id="unit-test-debugging"><a class="header" href="#unit-test-debugging">Unit Test Debugging</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    
    #[tokio::test]
    async fn debug_user_creation() {
        // Enable logging in tests
        let _ = tracing_subscriber::fmt::try_init();
        
        let provider = InMemoryProvider::new();
        let tenant_id = "test-tenant";
        
        // Create test user
        let user = ScimUser::builder()
            .username("test@example.com")
            .given_name("Test")
            .family_name("User")
            .build()
            .unwrap();
        
        println!("Creating user: {:?}", user);
        
        let created = provider.create_user(tenant_id, user).await.unwrap();
        
        println!("Created user with ID: {}", created.id());
        
        // Verify creation
        let fetched = provider.get_user(tenant_id, created.id()).await.unwrap();
        assert!(fetched.is_some());
        
        println!("Test passed: user creation and retrieval");
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-test-setup"><a class="header" href="#integration-test-setup">Integration Test Setup</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create test helper functions
pub async fn setup_test_server() -&gt; (TestServer, String) {
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder()
        .provider(provider)
        .build();
    
    let app = create_app(scim_server);
    let server = TestServer::new(app).unwrap();
    let tenant_id = "test-tenant".to_string();
    
    (server, tenant_id)
}

pub fn create_test_user() -&gt; ScimUser {
    ScimUser::builder()
        .username("test@example.com")
        .given_name("Test")
        .family_name("User")
        .email("test@example.com")
        .active(true)
        .build()
        .unwrap()
}

#[tokio::test]
async fn integration_test_user_lifecycle() {
    let (server, tenant_id) = setup_test_server().await;
    let user = create_test_user();
    
    // Create user
    let response = server
        .post(&amp;format!("/scim/v2/{}/Users", tenant_id))
        .json(&amp;user)
        .await;
    
    assert_eq!(response.status_code(), 201);
    
    let created_user: ScimUser = response.json();
    println!("Created user: {}", created_user.id());
    
    // Get user
    let response = server
        .get(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    // Update user
    let mut updated_user = created_user.clone();
    updated_user.set_given_name("Updated");
    
    let response = server
        .put(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .json(&amp;updated_user)
        .await;
    
    assert_eq!(response.status_code(), 200);
    
    // Delete user
    let response = server
        .delete(&amp;format!("/scim/v2/{}/Users/{}", tenant_id, created_user.id()))
        .await;
    
    assert_eq!(response.status_code(), 204);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<h3 id="collect-diagnostic-information"><a class="header" href="#collect-diagnostic-information">Collect Diagnostic Information</a></h3>
<p>When reporting issues, include:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Version information
println!("SCIM Server version: {}", env!("CARGO_PKG_VERSION"));
println!("Rust version: {}", env!("RUSTC_VERSION"));

// System information
use sysinfo::{System, SystemExt};
let mut system = System::new_all();
system.refresh_all();
println!("OS: {} {}", system.name().unwrap_or("Unknown"), system.os_version().unwrap_or("Unknown"));
println!("Total memory: {} MB", system.total_memory() / 1024 / 1024);

// Configuration
println!("Database URL: {}", env::var("DATABASE_URL").unwrap_or("Not set".to_string()));
println!("Log level: {}", env::var("RUST_LOG").unwrap_or("Not set".to_string()));
<span class="boring">}</span></code></pre></pre>
<h3 id="enable-maximum-logging"><a class="header" href="#enable-maximum-logging">Enable Maximum Logging</a></h3>
<pre><code class="language-bash"># Set maximum verbosity
export RUST_LOG=trace

# Run with backtrace
export RUST_BACKTRACE=full

# Run your application
cargo run
</code></pre>
<h3 id="create-minimal-reproduction"><a class="header" href="#create-minimal-reproduction">Create Minimal Reproduction</a></h3>
<pre><pre class="playground"><code class="language-rust">// Create the smallest possible example that reproduces the issue
use scim_server::{ScimServer, InMemoryProvider, ScimUser};

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let provider = InMemoryProvider::new();
    let scim_server = ScimServer::builder().provider(provider).build();
    
    // Minimal reproduction of your issue
    let user = ScimUser::builder()
        .username("test@example.com")
        .build()?;
    
    let result = scim_server.create_user("tenant-1", user).await;
    println!("Result: {:?}", result);
    
    Ok(())
}</code></pre></pre>
<p>This troubleshooting guide should help you identify and resolve most common issues with the SCIM Server library. For additional help, check the <a href="https://github.com/your-repo/scim-server/issues">GitHub Issues</a> or create a new issue with your diagnostic information.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../how-to/migrate-versions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../advanced/production-deployment.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../how-to/migrate-versions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../advanced/production-deployment.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
