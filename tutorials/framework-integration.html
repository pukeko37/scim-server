<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Web Framework Integration - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="web-framework-integration"><a class="header" href="#web-framework-integration">Web Framework Integration</a></h1>
<p>This tutorial shows how to integrate SCIM Server with popular Rust web frameworks. SCIM Server is framework-agnostic, meaning it works with any HTTP library while providing consistent SCIM functionality.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>SCIM Server follows a layered architecture that separates HTTP handling from SCIM logic:</p>
<pre><code>┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   HTTP Layer    │    │ Resource Provider│    │   Storage       │
│                 │    │                  │    │                 │
│  • Axum         │───▶│  • Validation    │───▶│  • In-Memory    │
│  • Warp         │    │  • Operations    │    │  • Database     │
│  • Actix        │    │  • Type Safety   │    │  • Custom       │
│  • Custom       │    │  • Multi-tenant  │    │                 │
└─────────────────┘    └──────────────────┘    └─────────────────┘
</code></pre>
<p>This design allows you to use your preferred web framework while leveraging SCIM Server's enterprise-grade capabilities.</p>
<h2 id="integration-patterns"><a class="header" href="#integration-patterns">Integration Patterns</a></h2>
<h3 id="common-integration-pattern"><a class="header" href="#common-integration-pattern">Common Integration Pattern</a></h3>
<p>All framework integrations follow a similar pattern:</p>
<ol>
<li><strong>Create RequestContext</strong> from request metadata</li>
<li><strong>Parse JSON body</strong> for create/update operations</li>
<li><strong>Handle ETags</strong> for concurrency control</li>
<li><strong>Call StandardResourceProvider</strong> with the extracted data</li>
<li><strong>Return SCIM-compliant responses</strong> with proper headers</li>
</ol>
<h2 id="axum-integration"><a class="header" href="#axum-integration">Axum Integration</a></h2>
<p>Axum is a modern, ergonomic web framework built on tokio and hyper.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
axum = "0.7"
tokio = { version = "1.0", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors"] }
serde_json = "1.0"
</code></pre>
<h3 id="basic-server-setup"><a class="header" href="#basic-server-setup">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use axum::{
    extract::{Path, Query, State},
    http::{StatusCode, HeaderMap, HeaderValue},
    response::Json,
    routing::{get, post, put, delete},
    Router,
};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::collections::HashMap;
use tower_http::cors::CorsLayer;
use uuid::Uuid;

type AppState = StandardResourceProvider&lt;InMemoryStorage&gt;;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);

    // Build application with routes
    let app = Router::new()
        // SCIM v2 endpoints
        .route("/scim/v2/Users", post(create_user).get(list_users))
        .route("/scim/v2/Users/:id", 
            get(get_user).put(update_user).delete(delete_user))
        .route("/scim/v2/Groups", post(create_group).get(list_groups))
        .route("/scim/v2/Groups/:id", 
            get(get_group).put(update_group).delete(delete_group))
        // Multi-tenant endpoints
        .route("/tenants/:tenant_id/scim/v2/Users", post(create_user_mt).get(list_users_mt))
        .route("/tenants/:tenant_id/scim/v2/Users/:id", 
            get(get_user_mt).put(update_user_mt).delete(delete_user_mt))
        .with_state(provider)
        .layer(CorsLayer::permissive());

    // Start server
    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000").await?;
    println!("SCIM Server running on http://127.0.0.1:3000");
    axum::serve(listener, app).await?;

    Ok(())
}</code></pre></pre>
<h3 id="crud-operations"><a class="header" href="#crud-operations">CRUD Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Helper to create RequestContext from HTTP request
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

// Create User
async fn create_user(
    State(provider): State&lt;AppState&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let user = provider.create_resource("User", user_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", format!("/scim/v2/Users/{}", 
        user.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(user.data)))
}

// Get User
async fn get_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(user.data)))
}

// List Users with Filtering
async fn list_users(
    State(provider): State&lt;AppState&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = create_request_context();
    
    // Get all users (provider handles this internally)
    let users = provider.list_resources("User", None, &amp;context).await?;
    
    // Apply client-side filtering if filter parameter provided
    let filtered_users = if let Some(filter_str) = params.get("filter") {
        // Simple filtering example - extend for full SCIM filter syntax
        users.into_iter()
            .filter(|user| {
                if filter_str.contains("active eq true") {
                    user.get_active().unwrap_or(true)
                } else {
                    true
                }
            })
            .collect::&lt;Vec&lt;_&gt;&gt;()
    } else {
        users
    };
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(filtered_users.len());
    let end = (start + count).min(filtered_users.len());
    let page_users = &amp;filtered_users[start..end];
    
    // Create SCIM list response
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": filtered_users.len(),
        "startIndex": start_index,
        "itemsPerPage": page_users.len(),
        "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Update User with ETag support
async fn update_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
    headers: HeaderMap,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    
    // Extract If-Match header for conditional updates
    let if_match = headers.get("if-match")
        .and_then(|v| v.to_str().ok())
        .map(|s| s.trim_matches('"'));
    
    // For ETag support, you could verify the version matches current resource
    if let Some(_expected_version) = if_match {
        // Get current user to check version
        let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
        if let Some(meta) = current_user.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != _expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let user = provider.update_resource("User", &amp;user_id, user_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(user.data)))
}

// Delete User
async fn delete_user(
    State(provider): State&lt;AppState&gt;,
    Path(user_id): Path&lt;String&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = create_request_context();
    provider.delete_resource("User", &amp;user_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="multi-tenant-endpoints"><a class="header" href="#multi-tenant-endpoints">Multi-Tenant Endpoints</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Multi-tenant user creation
async fn create_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    // Create context with tenant information
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let user = provider.create_resource("User", user_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", 
        format!("/tenants/{}/scim/v2/Users/{}", tenant_id, 
        user.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(user.data)))
}

// Multi-tenant user retrieval
async fn get_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(user.data)))
}

// Multi-tenant user listing
async fn list_users_mt(
    State(provider): State&lt;AppState&gt;,
    Path(tenant_id): Path&lt;String&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    let users = provider.list_resources("User", None, &amp;context).await?;
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(users.len());
    let end = (start + count).min(users.len());
    let page_users = &amp;users[start..end];
    
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": users.len(),
        "startIndex": start_index,
        "itemsPerPage": page_users.len(),
        "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Multi-tenant user update
async fn update_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
    headers: HeaderMap,
    Json(user_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    
    // Handle ETag if present
    if let Some(if_match) = headers.get("if-match").and_then(|v| v.to_str().ok()) {
        let expected_version = if_match.trim_matches('"');
        let current_user = provider.get_resource("User", &amp;user_id, &amp;context).await?;
        if let Some(meta) = current_user.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let user = provider.update_resource("User", &amp;user_id, user_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = user.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(user.data)))
}

// Multi-tenant user deletion
async fn delete_user_mt(
    State(provider): State&lt;AppState&gt;,
    Path((tenant_id, user_id)): Path&lt;(String, String)&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
    provider.delete_resource("User", &amp;user_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use axum::{response::{Response, IntoResponse}, http::StatusCode};
use serde_json::json;

#[derive(Debug)]
enum AppError {
    NotFound,
    VersionMismatch,
    ValidationError(String),
    InternalError(String),
}

impl IntoResponse for AppError {
    fn into_response(self) -&gt; Response {
        let (status, error_code, message) = match self {
            AppError::NotFound =&gt; (
                StatusCode::NOT_FOUND,
                "resourceNotFound",
                "The specified resource was not found",
            ),
            AppError::VersionMismatch =&gt; (
                StatusCode::PRECONDITION_FAILED,
                "versionMismatch", 
                "The resource version does not match",
            ),
            AppError::ValidationError(msg) =&gt; (
                StatusCode::BAD_REQUEST,
                "invalidData",
                &amp;msg,
            ),
            AppError::InternalError(msg) =&gt; (
                StatusCode::INTERNAL_SERVER_ERROR,
                "internalError",
                &amp;msg,
            ),
        };

        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": status.as_u16().to_string(),
            "scimType": error_code,
            "detail": message
        });

        (status, axum::Json(body)).into_response()
    }
}

impl&lt;E&gt; From&lt;E&gt; for AppError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -&gt; Self {
        let error_str = err.to_string();
        if error_str.contains("not found") {
            AppError::NotFound
        } else if error_str.contains("validation") {
            AppError::ValidationError(error_str)
        } else {
            AppError::InternalError(error_str)
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="group-operations"><a class="header" href="#group-operations">Group Operations</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create Group
async fn create_group(
    State(provider): State&lt;AppState&gt;,
    Json(group_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(StatusCode, HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let group = provider.create_resource("Group", group_data, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    headers.insert("Location", format!("/scim/v2/Groups/{}", 
        group.get_id().unwrap_or("unknown")).parse()?);
    
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((StatusCode::CREATED, headers, Json(group.data)))
}

// Get Group
async fn get_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    let group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;
    
    let mut headers = HeaderMap::new();
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((headers, Json(group.data)))
}

// List Groups
async fn list_groups(
    State(provider): State&lt;AppState&gt;,
    Query(params): Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;Json&lt;Value&gt;, AppError&gt; {
    let context = create_request_context();
    let groups = provider.list_resources("Group", None, &amp;context).await?;
    
    // Apply pagination
    let start_index = params.get("startIndex")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(1);
    let count = params.get("count")
        .and_then(|s| s.parse::&lt;usize&gt;().ok())
        .unwrap_or(20);
    
    let start = (start_index - 1).min(groups.len());
    let end = (start + count).min(groups.len());
    let page_groups = &amp;groups[start..end];
    
    let response = json!({
        "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
        "totalResults": groups.len(),
        "startIndex": start_index,
        "itemsPerPage": page_groups.len(),
        "Resources": page_groups.iter().map(|g| &amp;g.data).collect::&lt;Vec&lt;_&gt;&gt;()
    });
    
    Ok(Json(response))
}

// Update Group
async fn update_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
    headers: HeaderMap,
    Json(group_data): Json&lt;Value&gt;,
) -&gt; Result&lt;(HeaderMap, Json&lt;Value&gt;), AppError&gt; {
    let context = create_request_context();
    
    // Handle ETag if present
    if let Some(if_match) = headers.get("if-match").and_then(|v| v.to_str().ok()) {
        let expected_version = if_match.trim_matches('"');
        let current_group = provider.get_resource("Group", &amp;group_id, &amp;context).await?;
        if let Some(meta) = current_group.get_meta() {
            if let Some(current_version) = &amp;meta.version {
                if current_version != expected_version {
                    return Err(AppError::VersionMismatch);
                }
            }
        }
    }
    
    let group = provider.update_resource("Group", &amp;group_id, group_data, &amp;context).await?;
    
    let mut response_headers = HeaderMap::new();
    if let Some(meta) = group.get_meta() {
        if let Some(version) = &amp;meta.version {
            response_headers.insert("ETag", format!("\"{}\"", version).parse()?);
        }
    }
    
    Ok((response_headers, Json(group.data)))
}

// Delete Group
async fn delete_group(
    State(provider): State&lt;AppState&gt;,
    Path(group_id): Path&lt;String&gt;,
) -&gt; Result&lt;StatusCode, AppError&gt; {
    let context = create_request_context();
    provider.delete_resource("Group", &amp;group_id, &amp;context).await?;
    Ok(StatusCode::NO_CONTENT)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="warp-integration"><a class="header" href="#warp-integration">Warp Integration</a></h2>
<p>Warp is a composable web framework focusing on filters and type safety.</p>
<h3 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
warp = "0.3"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
uuid = { version = "1.0", features = ["v4"] }
</code></pre>
<h3 id="basic-server-setup-1"><a class="header" href="#basic-server-setup-1">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use warp::{Filter, Reply, Rejection};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::convert::Infallible;
use std::sync::Arc;
use uuid::Uuid;

type SharedProvider = Arc&lt;StandardResourceProvider&lt;InMemoryStorage&gt;&gt;;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = Arc::new(StandardResourceProvider::new(storage));

    // CORS configuration
    let cors = warp::cors()
        .allow_any_origin()
        .allow_headers(vec!["content-type", "authorization", "if-match"])
        .allow_methods(vec!["GET", "POST", "PUT", "DELETE"]);

    // Base path filter
    let scim_v2 = warp::path("scim").and(warp::path("v2"));
    
    // Provider state filter
    let with_provider = warp::any().map(move || provider.clone());

    // User routes
    let users = scim_v2
        .and(warp::path("Users"))
        .and(with_provider.clone())
        .and(
            // POST /scim/v2/Users
            warp::post()
                .and(warp::body::json())
                .and_then(create_user_handler)
            .or(
                // GET /scim/v2/Users
                warp::get()
                    .and(warp::query::query())
                    .and_then(list_users_handler)
            )
        );

    let user_by_id = scim_v2
        .and(warp::path("Users"))
        .and(warp::path::param::&lt;String&gt;())
        .and(with_provider.clone())
        .and(
            // GET /scim/v2/Users/{id}
            warp::get()
                .and_then(get_user_handler)
            .or(
                // PUT /scim/v2/Users/{id}
                warp::put()
                    .and(warp::header::optional::&lt;String&gt;("if-match"))
                    .and(warp::body::json())
                    .and_then(update_user_handler)
            )
            .or(
                // DELETE /scim/v2/Users/{id}
                warp::delete()
                    .and_then(delete_user_handler)
            )
        );

    let routes = users
        .or(user_by_id)
        .with(cors)
        .recover(handle_rejection);
    // Start server
    println!("SCIM Server running on http://127.0.0.1:3030");
    warp::serve(routes)
        .run(([127, 0, 0, 1], 3030))
        .await;

    Ok(())
}

// Helper to create RequestContext
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

// Warp handlers
async fn create_user_handler(
    provider: SharedProvider,
    user_data: Value,
) -&gt; Result&lt;impl Reply, Rejection&gt; {
    let context = create_request_context();
    
    match provider.create_resource("User", user_data, &amp;context).await {
        Ok(user) =&gt; {
            let mut response = warp::reply::with_status(
                warp::reply::json(&amp;user.data), 
                warp::http::StatusCode::CREATED
            );
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response = warp::reply::with_header(
                        response,
                        "ETag",
                        format!("\"{}\"", version)
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Err(warp::reject::custom(WarpError::from(e))),
    }
}

async fn list_users_handler(
    provider: SharedProvider,
    params: std::collections::HashMap&lt;String, String&gt;,
) -&gt; Result&lt;impl Reply, Rejection&gt; {
    let context = create_request_context();
    
    match provider.list_resources("User", None, &amp;context).await {
        Ok(users) =&gt; {
            let start_index = params.get("startIndex")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(1);
            let count = params.get("count")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(20);
            
            let start = (start_index - 1).min(users.len());
            let end = (start + count).min(users.len());
            let page_users = &amp;users[start..end];
            
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": users.len(),
                "startIndex": start_index,
                "itemsPerPage": page_users.len(),
                "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(warp::reply::json(&amp;response))
        },
        Err(e) =&gt; Err(warp::reject::custom(WarpError::from(e))),
    }
}

// Error handling for Warp
#[derive(Debug)]
struct WarpError {
    message: String,
    status: warp::http::StatusCode,
}

impl warp::reject::Reject for WarpError {}

impl&lt;E&gt; From&lt;E&gt; for WarpError
where
    E: std::error::Error + Send + Sync + 'static,
{
    fn from(err: E) -&gt; Self {
        let error_str = err.to_string();
        let status = if error_str.contains("not found") {
            warp::http::StatusCode::NOT_FOUND
        } else if error_str.contains("validation") {
            warp::http::StatusCode::BAD_REQUEST
        } else {
            warp::http::StatusCode::INTERNAL_SERVER_ERROR
        };
        
        Self { message: error_str, status }
    }
}

async fn handle_rejection(err: Rejection) -&gt; Result&lt;impl Reply, std::convert::Infallible&gt; {
    if let Some(warp_error) = err.find::&lt;WarpError&gt;() {
        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": warp_error.status.as_u16().to_string(),
            "detail": warp_error.message
        });
        
        Ok(warp::reply::with_status(
            warp::reply::json(&amp;body),
            warp_error.status
        ))
    } else {
        let body = json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "status": "500",
            "detail": "Internal server error"
        });
        
        Ok(warp::reply::with_status(
            warp::reply::json(&amp;body),
            warp::http::StatusCode::INTERNAL_SERVER_ERROR
        ))
    }
}</code></pre></pre>
<h2 id="actix-web-integration"><a class="header" href="#actix-web-integration">Actix Web Integration</a></h2>
<p>Actix Web is a powerful, pragmatic web framework for Rust.</p>
<h3 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h3>
<pre><code class="language-toml">[dependencies]
scim-server = "=0.3.2"
actix-web = "4"
tokio = { version = "1.0", features = ["full"] }
serde_json = "1.0"
</code></pre>
<h3 id="basic-server-setup-2"><a class="header" href="#basic-server-setup-2">Basic Server Setup</a></h3>
<pre><pre class="playground"><code class="language-rust">use actix_web::{
    web, App, HttpServer, HttpRequest, HttpResponse, Result,
    middleware::Logger,
};
use scim_server::{
    providers::StandardResourceProvider,
    storage::InMemoryStorage,
    RequestContext,
};
use serde_json::{Value, json};
use std::sync::Arc;
use uuid::Uuid;

type AppData = web::Data&lt;StandardResourceProvider&lt;InMemoryStorage&gt;&gt;;

// Helper to create RequestContext
fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}

#[actix_web::main]
async fn main() -&gt; std::io::Result&lt;()&gt; {
    env_logger::init();

    // Initialize SCIM Server with StandardResourceProvider
    let storage = InMemoryStorage::new();
    let provider = StandardResourceProvider::new(storage);
    let app_data = web::Data::new(provider);

    HttpServer::new(move || {
        App::new()
            .app_data(app_data.clone())
            .wrap(Logger::default())
            .service(
                web::scope("/scim/v2")
                    .service(
                        web::resource("/Users")
                            .route(web::post().to(create_user))
                            .route(web::get().to(list_users))
                    )
                    .service(
                        web::resource("/Users/{id}")
                            .route(web::get().to(get_user))
                            .route(web::put().to(update_user))
                            .route(web::delete().to(delete_user))
                    )
                    .service(
                        web::resource("/Groups")
                            .route(web::post().to(create_group))
                            .route(web::get().to(list_groups))
                    )
            )
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}</code></pre></pre>
<h3 id="handler-functions"><a class="header" href="#handler-functions">Handler Functions</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use actix_web::{web::Path, web::Json, web::Query, HttpRequest};
use std::collections::HashMap;

async fn create_user(
    provider: AppData,
    user_data: Json&lt;Value&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.create_resource("User", user_data.into_inner(), &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Created().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn get_user(
    provider: AppData,
    path: Path&lt;String&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    match provider.get_resource("User", &amp;user_id, &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Ok().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::NotFound().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "404"
        }))),
    }
}

async fn list_users(
    provider: AppData,
    query: Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.list_resources("User", None, &amp;context).await {
        Ok(users) =&gt; {
            let start_index = query.get("startIndex")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(1);
            let count = query.get("count")
                .and_then(|s| s.parse::&lt;usize&gt;().ok())
                .unwrap_or(20);
            
            let start = (start_index - 1).min(users.len());
            let end = (start + count).min(users.len());
            let page_users = &amp;users[start..end];
            
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": users.len(),
                "startIndex": start_index,
                "itemsPerPage": page_users.len(),
                "Resources": page_users.iter().map(|u| &amp;u.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(HttpResponse::Ok().json(response))
        },
        Err(e) =&gt; Ok(HttpResponse::InternalServerError().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "500"
        }))),
    }
}

async fn update_user(
    provider: AppData,
    path: Path&lt;String&gt;,
    user_data: Json&lt;Value&gt;,
    req: HttpRequest,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    // Handle ETag if present
    if let Some(if_match) = req.headers().get("if-match") {
        if let Ok(expected_version) = if_match.to_str() {
            let expected_version = expected_version.trim_matches('"');
            
            match provider.get_resource("User", &amp;user_id, &amp;context).await {
                Ok(current_user) =&gt; {
                    if let Some(meta) = current_user.get_meta() {
                        if let Some(current_version) = &amp;meta.version {
                            if current_version != expected_version {
                                return Ok(HttpResponse::PreconditionFailed().json(json!({
                                    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
                                    "detail": "Version mismatch",
                                    "status": "412"
                                })));
                            }
                        }
                    }
                },
                Err(_) =&gt; return Ok(HttpResponse::NotFound().json(json!({
                    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
                    "detail": "User not found",
                    "status": "404"
                }))),
            }
        }
    }
    
    match provider.update_resource("User", &amp;user_id, user_data.into_inner(), &amp;context).await {
        Ok(user) =&gt; {
            let mut response = HttpResponse::Ok().json(&amp;user.data);
            
            if let Some(meta) = user.get_meta() {
                if let Some(version) = &amp;meta.version {
                    response.headers_mut().insert(
                        actix_web::http::header::ETAG,
                        actix_web::http::header::HeaderValue::from_str(&amp;format!("\"{}\"", version)).unwrap()
                    );
                }
            }
            
            Ok(response)
        },
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn delete_user(
    provider: AppData,
    path: Path&lt;String&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let user_id = path.into_inner();
    let context = create_request_context();
    
    match provider.delete_resource("User", &amp;user_id, &amp;context).await {
        Ok(_) =&gt; Ok(HttpResponse::NoContent().finish()),
        Err(e) =&gt; Ok(HttpResponse::NotFound().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "404"
        }))),
    }
}

// Group handlers follow the same pattern
async fn create_group(
    provider: AppData,
    group_data: Json&lt;Value&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.create_resource("Group", group_data.into_inner(), &amp;context).await {
        Ok(group) =&gt; Ok(HttpResponse::Created().json(&amp;group.data)),
        Err(e) =&gt; Ok(HttpResponse::BadRequest().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "400"
        }))),
    }
}

async fn list_groups(
    provider: AppData,
    query: Query&lt;HashMap&lt;String, String&gt;&gt;,
) -&gt; Result&lt;HttpResponse&gt; {
    let context = create_request_context();
    
    match provider.list_resources("Group", None, &amp;context).await {
        Ok(groups) =&gt; {
            let response = json!({
                "schemas": ["urn:ietf:params:scim:api:messages:2.0:ListResponse"],
                "totalResults": groups.len(),
                "startIndex": 1,
                "itemsPerPage": groups.len(),
                "Resources": groups.iter().map(|g| &amp;g.data).collect::&lt;Vec&lt;_&gt;&gt;()
            });
            
            Ok(HttpResponse::Ok().json(response))
        },
        Err(e) =&gt; Ok(HttpResponse::InternalServerError().json(json!({
            "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
            "detail": e.to_string(),
            "status": "500"
        }))),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="framework-specific-considerations"><a class="header" href="#framework-specific-considerations">Framework-Specific Considerations</a></h2>
<h3 id="axum"><a class="header" href="#axum">Axum</a></h3>
<ul>
<li><strong>Strengths</strong>: Modern async design, excellent type safety, minimal boilerplate</li>
<li><strong>Best for</strong>: New projects, type-safe APIs, microservices</li>
<li><strong>SCIM Integration</strong>: Clean state management with <code>State&lt;T&gt;</code>, built-in JSON handling</li>
</ul>
<h3 id="warp"><a class="header" href="#warp">Warp</a></h3>
<ul>
<li><strong>Strengths</strong>: Functional approach, composable filters, zero-cost abstractions</li>
<li><strong>Best for</strong>: High-performance APIs, functional programming enthusiasts</li>
<li><strong>SCIM Integration</strong>: Filter composition allows flexible middleware</li>
</ul>
<h3 id="actix-web"><a class="header" href="#actix-web">Actix Web</a></h3>
<ul>
<li><strong>Strengths</strong>: Mature ecosystem, high performance, extensive middleware</li>
<li><strong>Best for</strong>: Production applications, teams familiar with traditional web frameworks</li>
<li><strong>SCIM Integration</strong>: Straightforward handler patterns, robust error handling</li>
</ul>
<h2 id="common-patterns-across-frameworks"><a class="header" href="#common-patterns-across-frameworks">Common Patterns Across Frameworks</a></h2>
<h3 id="request-context-creation"><a class="header" href="#request-context-creation">Request Context Creation</a></h3>
<p>All integrations use the same pattern for creating request contexts:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn create_request_context() -&gt; RequestContext {
    RequestContext::new(Uuid::new_v4().to_string())
}
<span class="boring">}</span></code></pre></pre>
<h3 id="etag-handling"><a class="header" href="#etag-handling">ETag Handling</a></h3>
<p>Consistent ETag support across frameworks:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Extract If-Match header
let if_match = headers.get("if-match")
    .and_then(|v| v.to_str().ok())
    .map(|s| s.trim_matches('"'));

// Set ETag in response
if let Some(version) = &amp;meta.version {
    headers.insert("ETag", format!("\"{}\"", version));
}
<span class="boring">}</span></code></pre></pre>
<h3 id="error-response-format"><a class="header" href="#error-response-format">Error Response Format</a></h3>
<p>Standard SCIM error responses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let error_response = json!({
    "schemas": ["urn:ietf:params:scim:api:messages:2.0:Error"],
    "status": status_code.to_string(),
    "detail": error_message
});
<span class="boring">}</span></code></pre></pre>
<h2 id="multi-tenant-url-patterns"><a class="header" href="#multi-tenant-url-patterns">Multi-Tenant URL Patterns</a></h2>
<p>All frameworks support multi-tenant deployments with URL patterns like:</p>
<ul>
<li>Single tenant: <code>/scim/v2/Users</code></li>
<li>Multi-tenant: <code>/tenants/{tenant_id}/scim/v2/Users</code></li>
</ul>
<p>The key is creating request contexts that include tenant information:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let context = RequestContext::new(format!("tenant-{}-{}", tenant_id, Uuid::new_v4()));
<span class="boring">}</span></code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-consistent-error-handling"><a class="header" href="#1-consistent-error-handling">1. Consistent Error Handling</a></h3>
<ul>
<li>Always return SCIM-compliant error responses</li>
<li>Include proper HTTP status codes</li>
<li>Provide meaningful error messages</li>
</ul>
<h3 id="2-etag-support"><a class="header" href="#2-etag-support">2. ETag Support</a></h3>
<ul>
<li>Implement conditional requests for concurrency control</li>
<li>Return ETags in response headers</li>
<li>Handle If-Match headers for updates</li>
</ul>
<h3 id="3-request-context-management"><a class="header" href="#3-request-context-management">3. Request Context Management</a></h3>
<ul>
<li>Create unique request contexts for operation tracking</li>
<li>Include tenant information for multi-tenant scenarios</li>
<li>Use UUIDs for request correlation</li>
</ul>
<h3 id="4-performance-considerations"><a class="header" href="#4-performance-considerations">4. Performance Considerations</a></h3>
<ul>
<li>Use async/await throughout the request pipeline</li>
<li>Leverage framework-specific optimizations</li>
<li>Consider connection pooling for database storage</li>
</ul>
<h3 id="5-security"><a class="header" href="#5-security">5. Security</a></h3>
<ul>
<li>Validate all input data</li>
<li>Implement proper authentication middleware</li>
<li>Use HTTPS in production</li>
<li>Sanitize error messages to avoid information leakage</li>
</ul>
<h2 id="testing-your-integration"><a class="header" href="#testing-your-integration">Testing Your Integration</a></h2>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Test individual handlers with mock data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use scim_server::storage::InMemoryStorage;

    #[tokio::test]
    async fn test_create_user() {
        let storage = InMemoryStorage::new();
        let provider = StandardResourceProvider::new(storage);
        let context = RequestContext::new("test".to_string());
        
        let user_data = json!({
            "userName": "test@example.com",
            "active": true
        });
        
        let result = provider.create_resource("User", user_data, &amp;context).await;
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Test complete HTTP request/response cycles:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[actix_web::test]
async fn test_user_creation_endpoint() {
    let app = test::init_service(
        App::new()
            .app_data(create_test_app_data())
            .service(web::resource("/Users").route(web::post().to(create_user)))
    ).await;

    let req = test::TestRequest::post()
        .uri("/Users")
        .set_json(&amp;json!({"userName": "test@example.com"}))
        .to_request();

    let resp = test::call_service(&amp;app, req).await;
    assert_eq!(resp.status(), 201);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>This tutorial demonstrated how to integrate SCIM Server with three popular Rust web frameworks:</p>
<p>✅ <strong>Framework Integration Patterns</strong>:</p>
<ul>
<li>Axum: Modern, type-safe with excellent async support</li>
<li>Warp: Functional, composable filters for flexibility</li>
<li>Actix Web: Mature, high-performance with extensive middleware</li>
</ul>
<p>✅ <strong>Key Implementation Details</strong>:</p>
<ul>
<li>StandardResourceProvider usage across all frameworks</li>
<li>RequestContext creation and management</li>
<li>ETag support for concurrency control</li>
<li>SCIM-compliant error handling</li>
<li>Multi-tenant URL patterns</li>
</ul>
<p>✅ <strong>Production Considerations</strong>:</p>
<ul>
<li>Security best practices</li>
<li>Performance optimization</li>
<li>Testing strategies</li>
<li>Error handling standards</li>
</ul>
<p>Choose the framework that best fits your team's expertise and project requirements. All three provide excellent foundations for building production SCIM servers with the SCIM Server library.</p>
<p><strong>Next Steps</strong>:</p>
<ul>
<li><a href="./authentication-setup.html">Authentication Setup</a> - Secure your SCIM endpoints</li>
<li><a href="./multi-tenant-deployment.html">Multi-Tenant Deployment</a> - Scale to multiple organizations</li>
<li><a href="./custom-resources.html">Custom Resources</a> - Extend beyond Users and Groups
let tenant_id = TenantId::default();</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../tutorials/multi-tenant-deployment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../tutorials/mcp-integration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../tutorials/multi-tenant-deployment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../tutorials/mcp-integration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
