<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced Validation - SCIM Server Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">SCIM Server Guide</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advanced-validation"><a class="header" href="#advanced-validation">Advanced Validation</a></h1>
<p>This guide covers complex validation scenarios including external system integration, conditional validation, and sophisticated business logic that requires asynchronous operations or external dependencies.</p>
<h2 id="external-system-integration"><a class="header" href="#external-system-integration">External System Integration</a></h2>
<h3 id="hr-system-validation"><a class="header" href="#hr-system-validation">HR System Validation</a></h3>
<p>Validate users against external HR systems to ensure data consistency:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use reqwest::Client;
use serde_json::json;
use std::time::Duration;
use async_trait::async_trait;

pub struct ExternalValidationService {
    http_client: Client,
    hr_system_url: String,
    compliance_service_url: String,
    api_key: String,
}

impl ExternalValidationService {
    pub fn new(hr_system_url: String, compliance_service_url: String, api_key: String) -&gt; Self {
        Self {
            http_client: Client::new(),
            hr_system_url,
            compliance_service_url,
            api_key,
        }
    }
}

#[async_trait]
impl CustomValidator for ExternalValidationService {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate against HR system
        self.validate_against_hr_system(user).await?;
        
        // Validate compliance requirements
        self.validate_compliance_requirements(user, context).await?;
        
        // Validate security clearance if present
        if let Some(security_clearance) = self.extract_security_clearance(user) {
            self.validate_security_clearance(&amp;security_clearance, user).await?;
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate group against organizational structure
        self.validate_group_structure(group, context).await?;
        Ok(())
    }
}

impl ExternalValidationService {
    async fn validate_against_hr_system(&amp;self, user: &amp;User) -&gt; Result&lt;(), ValidationError&gt; {
        if let Some(employee_number) = self.extract_employee_number(user) {
            let response = self.http_client
                .get(&amp;format!("{}/employees/{}", self.hr_system_url, employee_number))
                .header("Authorization", format!("Bearer {}", self.api_key))
                .timeout(Duration::from_secs(5))
                .send()
                .await
                .map_err(|e| ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("Failed to validate employee: {}", e),
                ))?;
            
            if response.status() == 404 {
                return Err(ValidationError::new(
                    "EMPLOYEE_NOT_FOUND",
                    "Employee not found in HR system",
                ).with_field("enterpriseUser:employeeNumber"));
            }
            
            if !response.status().is_success() {
                return Err(ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("HR system returned status: {}", response.status()),
                ));
            }
            
            let hr_employee: HrEmployee = response.json().await
                .map_err(|e| ValidationError::new(
                    "HR_SYSTEM_ERROR",
                    &amp;format!("Failed to parse HR response: {}", e),
                ))?;
            
            // Validate employee status
            if hr_employee.status != "ACTIVE" {
                return Err(ValidationError::new(
                    "EMPLOYEE_INACTIVE",
                    &amp;format!("Employee status in HR system is: {}", hr_employee.status),
                ).with_field("active"));
            }
            
            // Validate department consistency
            if let Some(department) = self.extract_department(user) {
                if hr_employee.department != department {
                    return Err(ValidationError::new(
                        "DEPARTMENT_MISMATCH",
                        "Department does not match HR system",
                    ).with_field("enterpriseUser:department"));
                }
            }

            // Validate manager hierarchy
            if let Some(manager_id) = self.extract_manager_id(user) {
                if let Some(hr_manager_id) = hr_employee.manager_id {
                    if manager_id != hr_manager_id {
                        return Err(ValidationError::new(
                            "MANAGER_MISMATCH",
                            "Manager does not match HR system",
                        ).with_field("enterpriseUser:manager"));
                    }
                }
            }
        }
        
        Ok(())
    }
    
    async fn validate_compliance_requirements(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let compliance_request = json!({
            "user_data": {
                "name": user.name,
                "emails": user.emails,
                "phone_numbers": user.phone_numbers,
                "addresses": user.addresses,
                "country": self.extract_country(user),
            },
            "tenant_id": context.tenant_id,
            "operation": context.operation,
        });
        
        let response = self.http_client
            .post(&amp;format!("{}/validate", self.compliance_service_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(&amp;compliance_request)
            .timeout(Duration::from_secs(10))
            .send()
            .await
            .map_err(|e| ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Failed to validate compliance: {}", e),
            ))?;
        
        if !response.status().is_success() {
            return Err(ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Compliance service returned status: {}", response.status()),
            ));
        }
        
        let compliance_result: ComplianceValidationResult = response.json().await
            .map_err(|e| ValidationError::new(
                "COMPLIANCE_SYSTEM_ERROR",
                &amp;format!("Failed to parse compliance response: {}", e),
            ))?;
        
        if !compliance_result.is_compliant {
            let violations = compliance_result.violations.join(", ");
            return Err(ValidationError::new(
                "COMPLIANCE_VIOLATION",
                &amp;format!("Compliance violations: {}", violations),
            ));
        }
        
        Ok(())
    }
    
    async fn validate_security_clearance(
        &amp;self,
        security_clearance: &amp;str,
        user: &amp;User,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate security clearance levels
        let valid_clearances = ["PUBLIC", "CONFIDENTIAL", "SECRET", "TOP_SECRET"];
        if !valid_clearances.contains(&amp;security_clearance) {
            return Err(ValidationError::new(
                "INVALID_SECURITY_CLEARANCE",
                &amp;format!("Invalid security clearance level: {}", security_clearance),
            ).with_field("enterpriseUser:securityClearance"));
        }
        
        // Validate clearance requirements based on department
        if let Some(department) = self.extract_department(user) {
            match department.as_str() {
                "Defense" | "Intelligence" =&gt; {
                    if security_clearance == "PUBLIC" {
                        return Err(ValidationError::new(
                            "INSUFFICIENT_CLEARANCE",
                            "Department requires minimum CONFIDENTIAL clearance",
                        ).with_field("enterpriseUser:securityClearance"));
                    }
                }
                "Research" =&gt; {
                    if !["CONFIDENTIAL", "SECRET", "TOP_SECRET"].contains(&amp;security_clearance) {
                        return Err(ValidationError::new(
                            "INSUFFICIENT_CLEARANCE",
                            "Research department requires minimum CONFIDENTIAL clearance",
                        ).with_field("enterpriseUser:securityClearance"));
                    }
                }
                _ =&gt; {} // No special requirements
            }
        }
        
        Ok(())
    }

    async fn validate_group_structure(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Validate against organizational chart
        let org_response = self.http_client
            .get(&amp;format!("{}/organizational-chart/{}", self.hr_system_url, context.tenant_id))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await
            .map_err(|e| ValidationError::new(
                "ORG_CHART_ERROR",
                &amp;format!("Failed to fetch organizational chart: {}", e),
            ))?;

        let org_chart: OrganizationalChart = org_response.json().await
            .map_err(|e| ValidationError::new(
                "ORG_CHART_ERROR", 
                &amp;format!("Failed to parse org chart: {}", e),
            ))?;

        // Validate group exists in org chart
        if !org_chart.groups.iter().any(|g| g.name == group.display_name) {
            return Err(ValidationError::new(
                "GROUP_NOT_IN_ORG_CHART",
                "Group does not exist in organizational chart",
            ).with_field("displayName"));
        }

        Ok(())
    }

    // Helper methods for extracting user attributes
    fn extract_employee_number(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("employeeNumber"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_department(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("department"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_manager_id(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("manager"))
            .and_then(|v| v.get("value"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_security_clearance(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("securityClearance"))
            .and_then(|v| v.as_str())
            .map(|s| s.to_string())
    }

    fn extract_country(&amp;self, user: &amp;User) -&gt; Option&lt;String&gt; {
        user.addresses
            .as_ref()
            .and_then(|addrs| addrs.first())
            .map(|addr| addr.country.clone())
            .unwrap_or_default()
    }
}

// Supporting types
#[derive(serde::Deserialize)]
struct HrEmployee {
    employee_id: String,
    status: String,
    department: String,
    manager_id: Option&lt;String&gt;,
    hire_date: String,
    termination_date: Option&lt;String&gt;,
}

#[derive(serde::Deserialize)]
struct ComplianceValidationResult {
    is_compliant: bool,
    violations: Vec&lt;String&gt;,
    severity: String,
}

#[derive(serde::Deserialize)]
struct OrganizationalChart {
    groups: Vec&lt;OrgGroup&gt;,
}

#[derive(serde::Deserialize)]
struct OrgGroup {
    name: String,
    parent: Option&lt;String&gt;,
    level: u32,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conditional-validation"><a class="header" href="#conditional-validation">Conditional Validation</a></h2>
<p>Implement validation rules that apply only under specific conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use std::collections::HashMap;

pub struct ConditionalValidator {
    rules: Vec&lt;ConditionalRule&gt;,
}

pub struct ConditionalRule {
    pub name: String,
    pub condition: fn(&amp;User, &amp;ValidationContext) -&gt; bool,
    pub validator: fn(&amp;User, &amp;ValidationContext) -&gt; Result&lt;(), ValidationError&gt;,
}

impl ConditionalValidator {
    pub fn new() -&gt; Self {
        let mut rules = Vec::new();
        
        // Rule: Contractors must have end date
        rules.push(ConditionalRule {
            name: "contractor_end_date".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("userType"))
                    .and_then(|v| v.as_str()) == Some("Contractor")
            },
            validator: |user, _| {
                let has_end_date = user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("employmentEndDate"))
                    .is_some();
                    
                if !has_end_date {
                    return Err(ValidationError::new(
                        "MISSING_END_DATE",
                        "Contractors must have an employment end date",
                    ).with_field("enterpriseUser:employmentEndDate"));
                }
                Ok(())
            },
        });
        
        // Rule: VIP users require additional security
        rules.push(ConditionalRule {
            name: "vip_security_requirements".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("vipStatus"))
                    .and_then(|v| v.as_bool())
                    .unwrap_or(false)
            },
            validator: |user, _| {
                // Check for required security attributes
                let security_attrs = ["securityClearance", "backgroundCheckDate", "securityTraining"];
                
                for attr in &amp;security_attrs {
                    if !user.extension_attributes
                        .as_ref()
                        .map(|attrs| attrs.contains_key(*attr))
                        .unwrap_or(false) {
                        return Err(ValidationError::new(
                            "MISSING_VIP_SECURITY_ATTR",
                            &amp;format!("VIP users must have {} attribute", attr),
                        ).with_field(&amp;format!("enterpriseUser:{}", attr)));
                    }
                }
                Ok(())
            },
        });
        
        // Rule: Remote workers require specific equipment
        rules.push(ConditionalRule {
            name: "remote_worker_equipment".to_string(),
            condition: |user, _| {
                user.extension_attributes
                    .as_ref()
                    .and_then(|attrs| attrs.get("workLocation"))
                    .and_then(|v| v.as_str()) == Some("Remote")
            },
            validator: |user, _| {
                let required_equipment = ["laptop", "vpnAccess", "phoneStipend"];
                
                for equipment in &amp;required_equipment {
                    if !user.extension_attributes
                        .as_ref()
                        .and_then(|attrs| attrs.get("equipment"))
                        .and_then(|v| v.as_array())
                        .map(|arr| arr.iter().any(|item| 
                            item.as_str().map(|s| s == *equipment).unwrap_or(false)
                        ))
                        .unwrap_or(false) {
                        return Err(ValidationError::new(
                            "MISSING_REMOTE_EQUIPMENT",
                            &amp;format!("Remote workers must have {} assigned", equipment),
                        ).with_field("enterpriseUser:equipment"));
                    }
                }
                Ok(())
            },
        });

        Self { rules }
    }
}

#[async_trait]
impl CustomValidator for ConditionalValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        for rule in &amp;self.rules {
            if (rule.condition)(user, context) {
                (rule.validator)(user, context)?;
            }
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        _group: &amp;Group,
        _context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Groups don't typically need conditional validation
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="async-workflow-integration"><a class="header" href="#async-workflow-integration">Async Workflow Integration</a></h2>
<p>Integrate with approval workflows and external processes:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use scim_server::validation::{CustomValidator, ValidationContext, ValidationError};
use tokio::time::{sleep, Duration};

pub struct WorkflowValidator {
    workflow_client: WorkflowClient,
    approval_timeout: Duration,
}

impl WorkflowValidator {
    pub fn new(workflow_url: String, api_key: String) -&gt; Self {
        Self {
            workflow_client: WorkflowClient::new(workflow_url, api_key),
            approval_timeout: Duration::from_secs(30),
        }
    }
}

#[async_trait]
impl CustomValidator for WorkflowValidator {
    async fn validate_user(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        match context.operation {
            Operation::Create =&gt; {
                // Check if user creation requires approval
                if self.requires_approval(user, context).await? {
                    self.validate_approval_exists(user, context).await?;
                }
            }
            Operation::Update =&gt; {
                // Check for sensitive attribute changes
                if self.has_sensitive_changes(user, context).await? {
                    self.validate_change_approval(user, context).await?;
                }
            }
            _ =&gt; {}
        }
        
        Ok(())
    }

    async fn validate_group(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Group creation/modification might require approval for certain types
        if self.is_privileged_group(group) {
            self.validate_group_approval(group, context).await?;
        }
        
        Ok(())
    }
}

impl WorkflowValidator {
    async fn requires_approval(&amp;self, user: &amp;User, context: &amp;ValidationContext) -&gt; Result&lt;bool, ValidationError&gt; {
        // External users always require approval
        if self.is_external_user(user) {
            return Ok(true);
        }
        
        // High-privilege roles require approval
        if let Some(roles) = &amp;user.roles {
            let privileged_roles = ["Admin", "Security", "HR"];
            if roles.iter().any(|role| privileged_roles.contains(&amp;role.value.as_str())) {
                return Ok(true);
            }
        }
        
        // Users with high security clearance require approval
        if let Some(clearance) = user.extension_attributes
            .as_ref()
            .and_then(|attrs| attrs.get("securityClearance"))
            .and_then(|v| v.as_str()) {
            if ["SECRET", "TOP_SECRET"].contains(&amp;clearance) {
                return Ok(true);
            }
        }
        
        Ok(false)
    }

    async fn validate_approval_exists(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let approval_request = ApprovalRequest {
            request_type: "user_creation".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: user.username.clone().unwrap_or_default(),
            details: serde_json::to_value(user).unwrap_or_default(),
        };

        let approval_status = self.workflow_client
            .check_approval_status(&amp;approval_request)
            .await
            .map_err(|e| ValidationError::new(
                "WORKFLOW_ERROR",
                &amp;format!("Failed to check approval status: {}", e),
            ))?;

        match approval_status.status.as_str() {
            "approved" =&gt; Ok(()),
            "pending" =&gt; {
                // Wait for approval with timeout
                self.wait_for_approval(&amp;approval_request).await
            }
            "rejected" =&gt; {
                Err(ValidationError::new(
                    "APPROVAL_REJECTED",
                    &amp;format!("User creation was rejected: {}", approval_status.reason.unwrap_or_default()),
                ))
            }
            _ =&gt; {
                // Create new approval request
                self.workflow_client
                    .create_approval_request(&amp;approval_request)
                    .await
                    .map_err(|e| ValidationError::new(
                        "WORKFLOW_ERROR",
                        &amp;format!("Failed to create approval request: {}", e),
                    ))?;
                
                Err(ValidationError::new(
                    "APPROVAL_PENDING",
                    "User creation requires approval. Request has been submitted.",
                ))
            }
        }
    }

    async fn wait_for_approval(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;(), ValidationError&gt; {
        let mut attempts = 0;
        let max_attempts = (self.approval_timeout.as_secs() / 5) as usize; // Check every 5 seconds

        while attempts &lt; max_attempts {
            sleep(Duration::from_secs(5)).await;
            
            let status = self.workflow_client
                .check_approval_status(request)
                .await
                .map_err(|e| ValidationError::new(
                    "WORKFLOW_ERROR",
                    &amp;format!("Failed to check approval status: {}", e),
                ))?;

            match status.status.as_str() {
                "approved" =&gt; return Ok(()),
                "rejected" =&gt; return Err(ValidationError::new(
                    "APPROVAL_REJECTED",
                    &amp;format!("Request was rejected: {}", status.reason.unwrap_or_default()),
                )),
                "pending" =&gt; {
                    attempts += 1;
                    continue;
                }
                _ =&gt; return Err(ValidationError::new(
                    "WORKFLOW_ERROR",
                    "Unexpected approval status",
                )),
            }
        }

        Err(ValidationError::new(
            "APPROVAL_TIMEOUT",
            "Approval request timed out",
        ))
    }

    async fn has_sensitive_changes(&amp;self, user: &amp;User, context: &amp;ValidationContext) -&gt; Result&lt;bool, ValidationError&gt; {
        // This would typically compare with the existing user record
        // For brevity, we'll assume sensitive attributes are being checked
        let sensitive_attributes = [
            "roles", "permissions", "securityClearance", 
            "department", "manager", "salary"
        ];
        
        // In a real implementation, you would fetch the existing user
        // and compare the attributes to detect changes
        Ok(true) // Simplified for example
    }

    async fn validate_change_approval(
        &amp;self,
        user: &amp;User,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Similar to validate_approval_exists but for user changes
        let approval_request = ApprovalRequest {
            request_type: "user_modification".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: user.username.clone().unwrap_or_default(),
            details: serde_json::to_value(user).unwrap_or_default(),
        };

        // Check for existing approval or create new request
        self.validate_approval_exists(user, context).await
    }

    async fn validate_group_approval(
        &amp;self,
        group: &amp;Group,
        context: &amp;ValidationContext,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        let approval_request = ApprovalRequest {
            request_type: "privileged_group_creation".to_string(),
            tenant_id: context.tenant_id.clone(),
            requester: context.authenticated_user.clone().unwrap_or_default(),
            subject: group.display_name.clone(),
            details: serde_json::to_value(group).unwrap_or_default(),
        };

        self.validate_approval_exists_for_group(group, &amp;approval_request).await
    }

    async fn validate_approval_exists_for_group(
        &amp;self,
        group: &amp;Group,
        approval_request: &amp;ApprovalRequest,
    ) -&gt; Result&lt;(), ValidationError&gt; {
        // Similar logic to user approval validation
        let approval_status = self.workflow_client
            .check_approval_status(approval_request)
            .await
            .map_err(|e| ValidationError::new(
                "WORKFLOW_ERROR",
                &amp;format!("Failed to check group approval status: {}", e),
            ))?;

        match approval_status.status.as_str() {
            "approved" =&gt; Ok(()),
            "pending" =&gt; self.wait_for_approval(approval_request).await,
            "rejected" =&gt; Err(ValidationError::new(
                "GROUP_APPROVAL_REJECTED",
                &amp;format!("Group creation was rejected: {}", approval_status.reason.unwrap_or_default()),
            )),
            _ =&gt; {
                self.workflow_client
                    .create_approval_request(approval_request)
                    .await
                    .map_err(|e| ValidationError::new(
                        "WORKFLOW_ERROR",
                        &amp;format!("Failed to create group approval request: {}", e),
                    ))?;
                
                Err(ValidationError::new(
                    "GROUP_APPROVAL_PENDING",
                    "Privileged group creation requires approval. Request has been submitted.",
                ))
            }
        }
    }

    fn is_external_user(&amp;self, user: &amp;User) -&gt; bool {
        if let Some(emails) = &amp;user.emails {
            return emails.iter().any(|email| {
                !email.value.ends_with("@company.com") &amp;&amp; 
                !email.value.ends_with("@subsidiary.com")
            });
        }
        false
    }

    fn is_privileged_group(&amp;self, group: &amp;Group) -&gt; bool {
        let privileged_patterns = ["admin", "security", "hr", "finance", "executive"];
        privileged_patterns.iter().any(|pattern| {
            group.display_name.to_lowercase().contains(pattern)
        })
    }
}

// Supporting types and client
struct WorkflowClient {
    base_url: String,
    api_key: String,
    client: reqwest::Client,
}

impl WorkflowClient {
    fn new(base_url: String, api_key: String) -&gt; Self {
        Self {
            base_url,
            api_key,
            client: reqwest::Client::new(),
        }
    }

    async fn check_approval_status(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;ApprovalStatus, Box&lt;dyn std::error::Error&gt;&gt; {
        let response = self.client
            .get(&amp;format!("{}/approvals/{}", self.base_url, request.get_id()))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .send()
            .await?;
        
        Ok(response.json().await?)
    }

    async fn create_approval_request(&amp;self, request: &amp;ApprovalRequest) -&gt; Result&lt;ApprovalStatus, Box&lt;dyn std::error::Error&gt;&gt; {
        let response = self.client
            .post(&amp;format!("{}/approvals", self.base_url))
            .header("Authorization", format!("Bearer {}", self.api_key))
            .json(request)
            .send()
            .await?;
        
        Ok(response.json().await?)
    }
}

#[derive(serde::Serialize, serde::Deserialize)]
struct ApprovalRequest {
    request_type: String,
    tenant_id: String,
    requester: String,
    subject: String,
    details: serde_json::Value,
}

impl ApprovalRequest {
    fn get_id(&amp;self) -&gt; String {
        // Generate ID based on request content
        format!("{}_{}_{}_{}", 
            self.request_type, 
            self.tenant_id, 
            self.requester, 
            self.subject
        )
    }
}

#[derive(serde::Deserialize)]
struct ApprovalStatus {
    status: String,
    reason: Option&lt;String&gt;,
    approved_by: Option&lt;String&gt;,
    approved_at: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-advanced-validators"><a class="header" href="#testing-advanced-validators">Testing Advanced Validators</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;
    use wiremock::{MockServer, Mock, ResponseTemplate};

    #[tokio::test]
    async fn test_external_validation_service() {
        // Setup mock HR system
        let mock_server = MockServer::start().await;
        
        Mock::given(wiremock::matchers::method("GET"))
            .and(wiremock::matchers::path("/employees/EMP123456"))
            .respond_with(ResponseTemplate::new(200).set_body_json(json!({
                "employee_id": "EMP123456",
                "status": "ACTIVE",
                "department": "Engineering",
                "manager_id": "MGR789"
            })))
            .mount(&amp;mock_server)
            .await;

        let validator = ExternalValidationService::new(
            mock_server.uri(),
            "http://compliance.test".to_string(),
            "test-api-key".to_string(),
        );

        let mut user = User::default();
        user.extension_attributes = Some(serde_json::json!({
            "employeeNumber": "EMP123456",
            "department": "Engineering"
        }).as_object().unwrap().clone());

        let context = ValidationContext::default();
        let result = validator.validate_user(&amp;user, &amp;context).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_conditional_validation() {
        let validator = ConditionalValidator::new();
        
        // Test contractor without end date
        let mut contractor = User::default();
        contractor.extension_attributes = Some(serde_json::json!({
            "userType": "Contractor"
        }).as_object().unwrap().clone());

        let context = ValidationContext::default();
        let result = validator.validate_user(&amp;contractor, &amp;context).await;
        assert!(result.is_err());
        assert_eq!(result.unwrap_err().code, "MISSING_END_DATE");

        // Test contractor with end date
        contractor.extension_attributes = Some(serde_json::json!({
            "userType": "Contractor",
            "employmentEndDate": "2024-12-31"
        }).as_object().unwrap().clone());

        let result = validator.validate_user(&amp;contractor, &amp;context).await;
        assert!(result.is_ok());
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h2>
<pre><pre class="playground"><code class="language-rust">use scim_server::ScimServerBuilder;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let server = ScimServerBuilder::new()
        .with_provider(my_provider)
        .add_validator(ExternalValidationService::new(
            "https://hr.company.com/api".to_string(),
            "https://compliance.company.com/api".to_string(),
            std::env::var("API_KEY")?,
        ))
        .add_validator(ConditionalValidator::new())
        .add_validator(WorkflowValidator::new(
            "https://workflow.company.com/api".to_string(),
            std::env::var("WORKFLOW_API_KEY")?,
        ))
        .build();

    server.run().await?;
    Ok(())
}</code></pre></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<ul>
<li>[Field-</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../validation/basic.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../validation/field-level.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../validation/basic.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../validation/field-level.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
